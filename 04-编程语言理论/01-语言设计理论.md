# 语言设计理论

## 1. 概述

语言设计理论研究编程语言的设计原则、语法结构和语义定义，为创建新的编程语言提供理论基础。

## 2. 基本概念

### 2.1 设计原则

- **简洁性**：语言应该简洁明了
- **一致性**：语法和语义应该一致
- **正交性**：特性之间应该相互独立
- **可读性**：代码应该易于阅读和理解

### 2.2 语法设计

- **BNF语法**：巴科斯-诺尔范式
- **抽象语法**：程序的抽象表示
- **具体语法**：程序的具体文本表示
- **语法糖**：简化语法的语法扩展

### 2.3 语义设计

- **操作语义**：程序执行步骤
- **指称语义**：程序含义的数学表示
- **公理语义**：程序性质的逻辑描述

## 3. 形式化表示

### 3.1 BNF语法

```latex
\text{表达式: } E ::= n | E + E | E * E | (E)
```

```latex
\text{语句: } S ::= x := E | S; S | \text{if } E \text{ then } S \text{ else } S
```

### 3.2 抽象语法树

```latex
\text{AST: } \text{Node}(\text{type}, \text{children})
```

### 3.3 语义规则

```latex
\langle n, \sigma \rangle \Downarrow n \quad \text{(数值求值)}
```

```latex
\langle e_1, \sigma \rangle \Downarrow v_1 \quad \langle e_2, \sigma \rangle \Downarrow v_2
\over \langle e_1 + e_2, \sigma \rangle \Downarrow v_1 + v_2
```

## 4. 软件架构应用

### 4.1 领域特定语言

- **配置语言**：系统配置的DSL
- **查询语言**：数据查询的DSL
- **建模语言**：系统建模的DSL

### 4.2 接口语言

- **API语言**：接口定义的语法
- **协议语言**：通信协议的语法
- **序列化语言**：数据序列化的语法

## 5. 代码示例

```rust
use std::collections::HashMap;

// 抽象语法树节点
#[derive(Clone, Debug)]
enum ASTNode {
    Number(i64),
    Variable(String),
    BinaryOp(Box<ASTNode>, BinaryOperator, Box<ASTNode>),
    Assignment(String, Box<ASTNode>),
    If(Box<ASTNode>, Box<ASTNode>, Option<Box<ASTNode>>),
    While(Box<ASTNode>, Box<ASTNode>),
    Block(Vec<ASTNode>),
    Function(String, Vec<String>, Box<ASTNode>),
    FunctionCall(String, Vec<ASTNode>),
}

#[derive(Clone, Debug)]
enum BinaryOperator {
    Add,
    Subtract,
    Multiply,
    Divide,
    Equal,
    LessThan,
    GreaterThan,
    And,
    Or,
}

// 语言设计器
struct LanguageDesigner {
    syntax_rules: Vec<SyntaxRule>,
    semantic_rules: Vec<SemanticRule>,
    type_rules: Vec<TypeRule>,
}

#[derive(Clone, Debug)]
struct SyntaxRule {
    name: String,
    pattern: String,
    precedence: usize,
    associativity: Associativity,
}

#[derive(Clone, Debug)]
enum Associativity {
    Left,
    Right,
    None,
}

#[derive(Clone, Debug)]
struct SemanticRule {
    name: String,
    condition: String,
    action: String,
}

#[derive(Clone, Debug)]
struct TypeRule {
    name: String,
    input_types: Vec<String>,
    output_type: String,
}

impl LanguageDesigner {
    fn new() -> Self {
        LanguageDesigner {
            syntax_rules: Vec::new(),
            semantic_rules: Vec::new(),
            type_rules: Vec::new(),
        }
    }
    
    fn add_syntax_rule(&mut self, rule: SyntaxRule) {
        self.syntax_rules.push(rule);
    }
    
    fn add_semantic_rule(&mut self, rule: SemanticRule) {
        self.semantic_rules.push(rule);
    }
    
    fn add_type_rule(&mut self, rule: TypeRule) {
        self.type_rules.push(rule);
    }
    
    fn design_language(&self) -> ProgrammingLanguage {
        ProgrammingLanguage {
            name: "CustomLanguage".to_string(),
            syntax_rules: self.syntax_rules.clone(),
            semantic_rules: self.semantic_rules.clone(),
            type_rules: self.type_rules.clone(),
        }
    }
}

// 编程语言
struct ProgrammingLanguage {
    name: String,
    syntax_rules: Vec<SyntaxRule>,
    semantic_rules: Vec<SemanticRule>,
    type_rules: Vec<TypeRule>,
}

impl ProgrammingLanguage {
    fn new(name: String) -> Self {
        ProgrammingLanguage {
            name,
            syntax_rules: Vec::new(),
            semantic_rules: Vec::new(),
            type_rules: Vec::new(),
        }
    }
    
    fn add_syntax_rule(&mut self, rule: SyntaxRule) {
        self.syntax_rules.push(rule);
    }
    
    fn add_semantic_rule(&mut self, rule: SemanticRule) {
        self.semantic_rules.push(rule);
    }
    
    fn add_type_rule(&mut self, rule: TypeRule) {
        self.type_rules.push(rule);
    }
    
    fn parse(&self, input: &str) -> Option<ASTNode> {
        // 解析输入（简化实现）
        Parser::new(self).parse(input)
    }
    
    fn type_check(&self, ast: &ASTNode) -> Option<String> {
        // 类型检查（简化实现）
        TypeChecker::new(self).check(ast)
    }
    
    fn evaluate(&self, ast: &ASTNode, env: &Environment) -> Option<Value> {
        // 语义求值（简化实现）
        Interpreter::new(self).evaluate(ast, env)
    }
}

// 解析器
struct Parser {
    language: ProgrammingLanguage,
}

impl Parser {
    fn new(language: ProgrammingLanguage) -> Self {
        Parser { language }
    }
    
    fn parse(&self, input: &str) -> Option<ASTNode> {
        // 简化的递归下降解析器
        let tokens = self.tokenize(input);
        self.parse_expression(&tokens, 0).map(|(node, _)| node)
    }
    
    fn tokenize(&self, input: &str) -> Vec<Token> {
        // 词法分析（简化实现）
        input
            .split_whitespace()
            .map(|s| {
                if let Ok(n) = s.parse::<i64>() {
                    Token::Number(n)
                } else if s == "+" {
                    Token::Plus
                } else if s == "*" {
                    Token::Multiply
                } else if s == "(" {
                    Token::LeftParen
                } else if s == ")" {
                    Token::RightParen
                } else {
                    Token::Identifier(s.to_string())
                }
            })
            .collect()
    }
    
    fn parse_expression(&self, tokens: &[Token], pos: usize) -> Option<(ASTNode, usize)> {
        // 解析表达式
        if pos >= tokens.len() {
            return None;
        }
        
        match &tokens[pos] {
            Token::Number(n) => Some((ASTNode::Number(*n), pos + 1)),
            Token::Identifier(name) => Some((ASTNode::Variable(name.clone()), pos + 1)),
            Token::LeftParen => {
                if let Some((expr, new_pos)) = self.parse_expression(tokens, pos + 1) {
                    if new_pos < tokens.len() && matches!(tokens[new_pos], Token::RightParen) {
                        Some((expr, new_pos + 1))
                    } else {
                        None
                    }
                } else {
                    None
                }
            }
            _ => None,
        }
    }
}

#[derive(Clone, Debug)]
enum Token {
    Number(i64),
    Identifier(String),
    Plus,
    Multiply,
    LeftParen,
    RightParen,
}

// 类型检查器
struct TypeChecker {
    language: ProgrammingLanguage,
}

impl TypeChecker {
    fn new(language: ProgrammingLanguage) -> Self {
        TypeChecker { language }
    }
    
    fn check(&self, ast: &ASTNode) -> Option<String> {
        match ast {
            ASTNode::Number(_) => Some("int".to_string()),
            ASTNode::Variable(_) => Some("unknown".to_string()),
            ASTNode::BinaryOp(left, op, right) => {
                let left_type = self.check(left)?;
                let right_type = self.check(right)?;
                
                match op {
                    BinaryOperator::Add | BinaryOperator::Subtract | BinaryOperator::Multiply | BinaryOperator::Divide => {
                        if left_type == "int" && right_type == "int" {
                            Some("int".to_string())
                        } else {
                            None
                        }
                    }
                    BinaryOperator::Equal | BinaryOperator::LessThan | BinaryOperator::GreaterThan => {
                        if left_type == right_type {
                            Some("bool".to_string())
                        } else {
                            None
                        }
                    }
                    BinaryOperator::And | BinaryOperator::Or => {
                        if left_type == "bool" && right_type == "bool" {
                            Some("bool".to_string())
                        } else {
                            None
                        }
                    }
                }
            }
            _ => Some("unknown".to_string()),
        }
    }
}

// 解释器
struct Interpreter {
    language: ProgrammingLanguage,
}

#[derive(Clone, Debug)]
enum Value {
    Integer(i64),
    Boolean(bool),
    String(String),
    Function(String, Vec<String>, Box<ASTNode>),
}

#[derive(Clone, Debug)]
struct Environment {
    variables: HashMap<String, Value>,
}

impl Interpreter {
    fn new(language: ProgrammingLanguage) -> Self {
        Interpreter { language }
    }
    
    fn evaluate(&self, ast: &ASTNode, env: &Environment) -> Option<Value> {
        match ast {
            ASTNode::Number(n) => Some(Value::Integer(*n)),
            ASTNode::Variable(name) => env.variables.get(name).cloned(),
            ASTNode::BinaryOp(left, op, right) => {
                let left_val = self.evaluate(left, env)?;
                let right_val = self.evaluate(right, env)?;
                self.evaluate_binary_op(&left_val, op, &right_val)
            }
            ASTNode::Assignment(name, value) => {
                let val = self.evaluate(value, env)?;
                let mut new_env = env.clone();
                new_env.variables.insert(name.clone(), val.clone());
                Some(val)
            }
            _ => None,
        }
    }
    
    fn evaluate_binary_op(&self, left: &Value, op: &BinaryOperator, right: &Value) -> Option<Value> {
        match (left, op, right) {
            (Value::Integer(a), BinaryOperator::Add, Value::Integer(b)) => {
                Some(Value::Integer(a + b))
            }
            (Value::Integer(a), BinaryOperator::Subtract, Value::Integer(b)) => {
                Some(Value::Integer(a - b))
            }
            (Value::Integer(a), BinaryOperator::Multiply, Value::Integer(b)) => {
                Some(Value::Integer(a * b))
            }
            (Value::Integer(a), BinaryOperator::Divide, Value::Integer(b)) => {
                if *b != 0 {
                    Some(Value::Integer(a / b))
                } else {
                    None
                }
            }
            (Value::Integer(a), BinaryOperator::Equal, Value::Integer(b)) => {
                Some(Value::Boolean(a == b))
            }
            (Value::Integer(a), BinaryOperator::LessThan, Value::Integer(b)) => {
                Some(Value::Boolean(a < b))
            }
            (Value::Integer(a), BinaryOperator::GreaterThan, Value::Integer(b)) => {
                Some(Value::Boolean(a > b))
            }
            (Value::Boolean(a), BinaryOperator::And, Value::Boolean(b)) => {
                Some(Value::Boolean(*a && *b))
            }
            (Value::Boolean(a), BinaryOperator::Or, Value::Boolean(b)) => {
                Some(Value::Boolean(*a || *b))
            }
            _ => None,
        }
    }
}

// 语言设计工具
struct LanguageDesignTools;

impl LanguageDesignTools {
    fn create_arithmetic_language() -> ProgrammingLanguage {
        let mut language = ProgrammingLanguage::new("Arithmetic".to_string());
        
        // 添加语法规则
        language.add_syntax_rule(SyntaxRule {
            name: "expression".to_string(),
            pattern: "number | expression + expression | expression * expression".to_string(),
            precedence: 0,
            associativity: Associativity::Left,
        });
        
        // 添加语义规则
        language.add_semantic_rule(SemanticRule {
            name: "addition".to_string(),
            condition: "both operands are integers".to_string(),
            action: "return sum of operands".to_string(),
        });
        
        // 添加类型规则
        language.add_type_rule(TypeRule {
            name: "addition_type".to_string(),
            input_types: vec!["int".to_string(), "int".to_string()],
            output_type: "int".to_string(),
        });
        
        language
    }
    
    fn create_boolean_language() -> ProgrammingLanguage {
        let mut language = ProgrammingLanguage::new("Boolean".to_string());
        
        // 添加语法规则
        language.add_syntax_rule(SyntaxRule {
            name: "boolean_expression".to_string(),
            pattern: "true | false | expression and expression | expression or expression".to_string(),
            precedence: 0,
            associativity: Associativity::Left,
        });
        
        // 添加语义规则
        language.add_semantic_rule(SemanticRule {
            name: "logical_and".to_string(),
            condition: "both operands are booleans".to_string(),
            action: "return logical AND of operands".to_string(),
        });
        
        // 添加类型规则
        language.add_type_rule(TypeRule {
            name: "logical_and_type".to_string(),
            input_types: vec!["bool".to_string(), "bool".to_string()],
            output_type: "bool".to_string(),
        });
        
        language
    }
    
    fn validate_language_design(&self, language: &ProgrammingLanguage) -> Vec<String> {
        let mut errors = Vec::new();
        
        // 检查语法规则的一致性
        for rule in &language.syntax_rules {
            if rule.pattern.is_empty() {
                errors.push(format!("Empty pattern in rule: {}", rule.name));
            }
        }
        
        // 检查语义规则的一致性
        for rule in &language.semantic_rules {
            if rule.condition.is_empty() {
                errors.push(format!("Empty condition in rule: {}", rule.name));
            }
        }
        
        // 检查类型规则的一致性
        for rule in &language.type_rules {
            if rule.input_types.is_empty() {
                errors.push(format!("Empty input types in rule: {}", rule.name));
            }
        }
        
        errors
    }
}
```

## 6. 交叉引用

- [[00-编程语言理论总论]]
- [[02-编译器理论]]
- [[03-类型系统理论]]

## 7. 导航

- [返回总目录](../README.md)
- [上一章：编程语言理论总论](00-编程语言理论总论.md)
- [下一章：编译器理论](02-编译器理论.md)
