# 编译器理论

## 1. 概述

编译器理论研究如何将高级编程语言转换为机器可执行的代码，包括词法分析、语法分析、语义分析、优化和代码生成等阶段。

## 2. 基本概念

### 2.1 编译阶段

- **词法分析**：将源代码转换为token流
- **语法分析**：构建抽象语法树
- **语义分析**：类型检查和语义验证
- **中间代码生成**：生成中间表示
- **代码优化**：优化中间代码
- **目标代码生成**：生成机器代码

### 2.2 编译器架构

- **前端**：语言相关的分析阶段
- **中端**：语言无关的优化阶段
- **后端**：目标机器相关的代码生成

### 2.3 编译技术

- **递归下降解析**：自顶向下的语法分析
- **LR解析**：自底向上的语法分析
- **静态单赋值**：中间代码表示
- **寄存器分配**：目标代码优化

## 3. 形式化表示

### 3.1 词法分析

```latex
\text{Token} = (\text{type}, \text{value}, \text{position})
```

### 3.2 语法分析

```latex
\text{AST} = \text{Node}(\text{type}, \text{children}, \text{attributes})
```

### 3.3 类型检查

```latex
\Gamma \vdash e : \tau \quad \text{(类型判断)}
```

## 4. 软件架构应用

### 4.1 代码生成

- **模板引擎**：基于模板的代码生成
- **DSL编译器**：领域特定语言的编译器
- **配置编译器**：配置文件的编译器

### 4.2 静态分析

- **代码检查**：静态代码分析工具
- **依赖分析**：代码依赖关系分析
- **安全分析**：代码安全漏洞检测

## 5. 代码示例

```rust
use std::collections::HashMap;

// 词法分析器
#[derive(Clone, Debug, PartialEq)]
enum TokenType {
    Number,
    Identifier,
    Plus,
    Minus,
    Multiply,
    Divide,
    LeftParen,
    RightParen,
    Semicolon,
    Assign,
    If,
    Then,
    Else,
    While,
    Do,
    End,
    EOF,
}

#[derive(Clone, Debug)]
struct Token {
    token_type: TokenType,
    value: String,
    line: usize,
    column: usize,
}

struct Lexer {
    source: Vec<char>,
    position: usize,
    line: usize,
    column: usize,
}

impl Lexer {
    fn new(source: &str) -> Self {
        Lexer {
            source: source.chars().collect(),
            position: 0,
            line: 1,
            column: 1,
        }
    }
    
    fn next_token(&mut self) -> Option<Token> {
        self.skip_whitespace();
        
        if self.position >= self.source.len() {
            return Some(Token {
                token_type: TokenType::EOF,
                value: "".to_string(),
                line: self.line,
                column: self.column,
            });
        }
        
        let current_char = self.source[self.position];
        
        match current_char {
            '0'..='9' => self.read_number(),
            'a'..='z' | 'A'..='Z' | '_' => self.read_identifier(),
            '+' => self.read_single_char_token(TokenType::Plus),
            '-' => self.read_single_char_token(TokenType::Minus),
            '*' => self.read_single_char_token(TokenType::Multiply),
            '/' => self.read_single_char_token(TokenType::Divide),
            '(' => self.read_single_char_token(TokenType::LeftParen),
            ')' => self.read_single_char_token(TokenType::RightParen),
            ';' => self.read_single_char_token(TokenType::Semicolon),
            ':' => self.read_assignment(),
            _ => None,
        }
    }
    
    fn skip_whitespace(&mut self) {
        while self.position < self.source.len() {
            let c = self.source[self.position];
            match c {
                ' ' | '\t' => {
                    self.position += 1;
                    self.column += 1;
                }
                '\n' => {
                    self.position += 1;
                    self.line += 1;
                    self.column = 1;
                }
                _ => break,
            }
        }
    }
    
    fn read_number(&mut self) -> Option<Token> {
        let start = self.position;
        let start_column = self.column;
        
        while self.position < self.source.len() {
            let c = self.source[self.position];
            if c.is_ascii_digit() {
                self.position += 1;
                self.column += 1;
            } else {
                break;
            }
        }
        
        let value: String = self.source[start..self.position].iter().collect();
        Some(Token {
            token_type: TokenType::Number,
            value,
            line: self.line,
            column: start_column,
        })
    }
    
    fn read_identifier(&mut self) -> Option<Token> {
        let start = self.position;
        let start_column = self.column;
        
        while self.position < self.source.len() {
            let c = self.source[self.position];
            if c.is_alphanumeric() || c == '_' {
                self.position += 1;
                self.column += 1;
            } else {
                break;
            }
        }
        
        let value: String = self.source[start..self.position].iter().collect();
        let token_type = match value.as_str() {
            "if" => TokenType::If,
            "then" => TokenType::Then,
            "else" => TokenType::Else,
            "while" => TokenType::While,
            "do" => TokenType::Do,
            "end" => TokenType::End,
            _ => TokenType::Identifier,
        };
        
        Some(Token {
            token_type,
            value,
            line: self.line,
            column: start_column,
        })
    }
    
    fn read_single_char_token(&mut self, token_type: TokenType) -> Option<Token> {
        let value = self.source[self.position].to_string();
        let column = self.column;
        self.position += 1;
        self.column += 1;
        
        Some(Token {
            token_type,
            value,
            line: self.line,
            column,
        })
    }
    
    fn read_assignment(&mut self) -> Option<Token> {
        if self.position + 1 < self.source.len() && self.source[self.position + 1] == '=' {
            self.position += 2;
            self.column += 2;
            Some(Token {
                token_type: TokenType::Assign,
                value: ":=".to_string(),
                line: self.line,
                column: self.column - 2,
            })
        } else {
            None
        }
    }
}

// 语法分析器
#[derive(Clone, Debug)]
enum ASTNode {
    Number(i64),
    Variable(String),
    BinaryOp(Box<ASTNode>, BinaryOperator, Box<ASTNode>),
    Assignment(String, Box<ASTNode>),
    If(Box<ASTNode>, Box<ASTNode>, Option<Box<ASTNode>>),
    While(Box<ASTNode>, Box<ASTNode>),
    Block(Vec<ASTNode>),
}

#[derive(Clone, Debug)]
enum BinaryOperator {
    Add,
    Subtract,
    Multiply,
    Divide,
}

struct Parser {
    tokens: Vec<Token>,
    position: usize,
}

impl Parser {
    fn new(tokens: Vec<Token>) -> Self {
        Parser {
            tokens,
            position: 0,
        }
    }
    
    fn parse(&mut self) -> Option<ASTNode> {
        self.parse_statement()
    }
    
    fn parse_statement(&mut self) -> Option<ASTNode> {
        if self.position >= self.tokens.len() {
            return None;
        }
        
        match self.tokens[self.position].token_type {
            TokenType::If => self.parse_if_statement(),
            TokenType::While => self.parse_while_statement(),
            TokenType::Identifier => self.parse_assignment(),
            _ => None,
        }
    }
    
    fn parse_if_statement(&mut self) -> Option<ASTNode> {
        self.expect(TokenType::If)?;
        let condition = self.parse_expression()?;
        self.expect(TokenType::Then)?;
        let then_branch = self.parse_statement()?;
        
        let else_branch = if self.peek() == Some(TokenType::Else) {
            self.expect(TokenType::Else)?;
            Some(Box::new(self.parse_statement()?))
        } else {
            None
        };
        
        self.expect(TokenType::End)?;
        
        Some(ASTNode::If(Box::new(condition), Box::new(then_branch), else_branch))
    }
    
    fn parse_while_statement(&mut self) -> Option<ASTNode> {
        self.expect(TokenType::While)?;
        let condition = self.parse_expression()?;
        self.expect(TokenType::Do)?;
        let body = self.parse_statement()?;
        self.expect(TokenType::End)?;
        
        Some(ASTNode::While(Box::new(condition), Box::new(body)))
    }
    
    fn parse_assignment(&mut self) -> Option<ASTNode> {
        let identifier = self.expect_identifier()?;
        self.expect(TokenType::Assign)?;
        let value = self.parse_expression()?;
        self.expect(TokenType::Semicolon)?;
        
        Some(ASTNode::Assignment(identifier, Box::new(value)))
    }
    
    fn parse_expression(&mut self) -> Option<ASTNode> {
        self.parse_term()
    }
    
    fn parse_term(&mut self) -> Option<ASTNode> {
        let mut left = self.parse_factor()?;
        
        while let Some(token) = self.peek() {
            match token {
                TokenType::Plus => {
                    self.advance();
                    let right = self.parse_factor()?;
                    left = ASTNode::BinaryOp(Box::new(left), BinaryOperator::Add, Box::new(right));
                }
                TokenType::Minus => {
                    self.advance();
                    let right = self.parse_factor()?;
                    left = ASTNode::BinaryOp(Box::new(left), BinaryOperator::Subtract, Box::new(right));
                }
                _ => break,
            }
        }
        
        Some(left)
    }
    
    fn parse_factor(&mut self) -> Option<ASTNode> {
        let mut left = self.parse_primary()?;
        
        while let Some(token) = self.peek() {
            match token {
                TokenType::Multiply => {
                    self.advance();
                    let right = self.parse_primary()?;
                    left = ASTNode::BinaryOp(Box::new(left), BinaryOperator::Multiply, Box::new(right));
                }
                TokenType::Divide => {
                    self.advance();
                    let right = self.parse_primary()?;
                    left = ASTNode::BinaryOp(Box::new(left), BinaryOperator::Divide, Box::new(right));
                }
                _ => break,
            }
        }
        
        Some(left)
    }
    
    fn parse_primary(&mut self) -> Option<ASTNode> {
        if self.position >= self.tokens.len() {
            return None;
        }
        
        match self.tokens[self.position].token_type {
            TokenType::Number => {
                let value = self.tokens[self.position].value.parse::<i64>().ok()?;
                self.advance();
                Some(ASTNode::Number(value))
            }
            TokenType::Identifier => {
                let name = self.tokens[self.position].value.clone();
                self.advance();
                Some(ASTNode::Variable(name))
            }
            TokenType::LeftParen => {
                self.advance();
                let expr = self.parse_expression()?;
                self.expect(TokenType::RightParen)?;
                Some(expr)
            }
            _ => None,
        }
    }
    
    fn expect(&mut self, token_type: TokenType) -> Option<()> {
        if self.peek() == Some(token_type) {
            self.advance();
            Some(())
        } else {
            None
        }
    }
    
    fn expect_identifier(&mut self) -> Option<String> {
        if let Some(TokenType::Identifier) = self.peek() {
            let name = self.tokens[self.position].value.clone();
            self.advance();
            Some(name)
        } else {
            None
        }
    }
    
    fn peek(&self) -> Option<TokenType> {
        if self.position < self.tokens.len() {
            Some(self.tokens[self.position].token_type.clone())
        } else {
            None
        }
    }
    
    fn advance(&mut self) {
        self.position += 1;
    }
}

// 语义分析器
struct SemanticAnalyzer {
    symbol_table: HashMap<String, SymbolInfo>,
    errors: Vec<String>,
}

#[derive(Clone, Debug)]
struct SymbolInfo {
    name: String,
    type_: String,
    scope: usize,
}

impl SemanticAnalyzer {
    fn new() -> Self {
        SemanticAnalyzer {
            symbol_table: HashMap::new(),
            errors: Vec::new(),
        }
    }
    
    fn analyze(&mut self, ast: &ASTNode) -> Option<String> {
        match ast {
            ASTNode::Number(_) => Some("int".to_string()),
            ASTNode::Variable(name) => {
                if let Some(info) = self.symbol_table.get(name) {
                    Some(info.type_.clone())
                } else {
                    self.errors.push(format!("Undefined variable: {}", name));
                    None
                }
            }
            ASTNode::BinaryOp(left, op, right) => {
                let left_type = self.analyze(left)?;
                let right_type = self.analyze(right)?;
                
                if left_type != right_type {
                    self.errors.push(format!("Type mismatch: {} and {}", left_type, right_type));
                    return None;
                }
                
                match op {
                    BinaryOperator::Add | BinaryOperator::Subtract | BinaryOperator::Multiply | BinaryOperator::Divide => {
                        if left_type == "int" {
                            Some("int".to_string())
                        } else {
                            self.errors.push("Arithmetic operations require integer operands".to_string());
                            None
                        }
                    }
                }
            }
            ASTNode::Assignment(name, value) => {
                let value_type = self.analyze(value)?;
                self.symbol_table.insert(name.clone(), SymbolInfo {
                    name: name.clone(),
                    type_: value_type.clone(),
                    scope: 0,
                });
                Some(value_type)
            }
            ASTNode::If(condition, then_branch, else_branch) => {
                let condition_type = self.analyze(condition)?;
                if condition_type != "bool" {
                    self.errors.push("Condition must be boolean".to_string());
                    return None;
                }
                
                let then_type = self.analyze(then_branch)?;
                if let Some(else_branch) = else_branch {
                    let else_type = self.analyze(else_branch)?;
                    if then_type != else_type {
                        self.errors.push("If branches must have same type".to_string());
                        return None;
                    }
                }
                
                Some(then_type)
            }
            ASTNode::While(condition, body) => {
                let condition_type = self.analyze(condition)?;
                if condition_type != "bool" {
                    self.errors.push("While condition must be boolean".to_string());
                    return None;
                }
                
                self.analyze(body)?;
                Some("void".to_string())
            }
            ASTNode::Block(statements) => {
                let mut last_type = "void".to_string();
                for stmt in statements {
                    last_type = self.analyze(stmt)?;
                }
                Some(last_type)
            }
        }
    }
    
    fn get_errors(&self) -> &[String] {
        &self.errors
    }
}

// 代码生成器
struct CodeGenerator {
    instructions: Vec<Instruction>,
    symbol_table: HashMap<String, usize>,
    next_temp: usize,
}

#[derive(Clone, Debug)]
enum Instruction {
    Load(usize, String),      // Load value from variable
    Store(String, usize),     // Store value to variable
    Add(usize, usize, usize), // Add two values
    Sub(usize, usize, usize), // Subtract two values
    Mul(usize, usize, usize), // Multiply two values
    Div(usize, usize, usize), // Divide two values
    Jump(usize),              // Unconditional jump
    JumpIfZero(usize, usize), // Conditional jump
    Label(usize),             // Label for jumps
    Halt,                     // Stop execution
}

impl CodeGenerator {
    fn new() -> Self {
        CodeGenerator {
            instructions: Vec::new(),
            symbol_table: HashMap::new(),
            next_temp: 0,
        }
    }
    
    fn generate(&mut self, ast: &ASTNode) -> Vec<Instruction> {
        self.instructions.clear();
        self.generate_node(ast);
        self.instructions.push(Instruction::Halt);
        self.instructions.clone()
    }
    
    fn generate_node(&mut self, ast: &ASTNode) -> usize {
        match ast {
            ASTNode::Number(n) => {
                let temp = self.new_temp();
                self.instructions.push(Instruction::Load(temp, n.to_string()));
                temp
            }
            ASTNode::Variable(name) => {
                let temp = self.new_temp();
                if let Some(&addr) = self.symbol_table.get(name) {
                    self.instructions.push(Instruction::Load(temp, addr.to_string()));
                } else {
                    // 假设变量已分配地址
                    self.instructions.push(Instruction::Load(temp, "0".to_string()));
                }
                temp
            }
            ASTNode::BinaryOp(left, op, right) => {
                let left_temp = self.generate_node(left);
                let right_temp = self.generate_node(right);
                let result_temp = self.new_temp();
                
                match op {
                    BinaryOperator::Add => {
                        self.instructions.push(Instruction::Add(result_temp, left_temp, right_temp));
                    }
                    BinaryOperator::Subtract => {
                        self.instructions.push(Instruction::Sub(result_temp, left_temp, right_temp));
                    }
                    BinaryOperator::Multiply => {
                        self.instructions.push(Instruction::Mul(result_temp, left_temp, right_temp));
                    }
                    BinaryOperator::Divide => {
                        self.instructions.push(Instruction::Div(result_temp, left_temp, right_temp));
                    }
                }
                
                result_temp
            }
            ASTNode::Assignment(name, value) => {
                let value_temp = self.generate_node(value);
                let addr = self.allocate_variable(name);
                self.instructions.push(Instruction::Store(name.clone(), value_temp));
                value_temp
            }
            ASTNode::If(condition, then_branch, else_branch) => {
                let condition_temp = self.generate_node(condition);
                let else_label = self.new_label();
                let end_label = self.new_label();
                
                self.instructions.push(Instruction::JumpIfZero(condition_temp, else_label));
                self.generate_node(then_branch);
                self.instructions.push(Instruction::Jump(end_label));
                self.instructions.push(Instruction::Label(else_label));
                
                if let Some(else_branch) = else_branch {
                    self.generate_node(else_branch);
                }
                
                self.instructions.push(Instruction::Label(end_label));
                0 // void result
            }
            ASTNode::While(condition, body) => {
                let start_label = self.new_label();
                let end_label = self.new_label();
                
                self.instructions.push(Instruction::Label(start_label));
                let condition_temp = self.generate_node(condition);
                self.instructions.push(Instruction::JumpIfZero(condition_temp, end_label));
                self.generate_node(body);
                self.instructions.push(Instruction::Jump(start_label));
                self.instructions.push(Instruction::Label(end_label));
                0 // void result
            }
            ASTNode::Block(statements) => {
                let mut last_result = 0;
                for stmt in statements {
                    last_result = self.generate_node(stmt);
                }
                last_result
            }
        }
    }
    
    fn new_temp(&mut self) -> usize {
        let temp = self.next_temp;
        self.next_temp += 1;
        temp
    }
    
    fn new_label(&mut self) -> usize {
        self.instructions.len()
    }
    
    fn allocate_variable(&mut self, name: &str) -> usize {
        if !self.symbol_table.contains_key(name) {
            let addr = self.symbol_table.len();
            self.symbol_table.insert(name.to_string(), addr);
        }
        self.symbol_table[name]
    }
}

// 编译器
struct Compiler {
    lexer: Lexer,
    parser: Parser,
    semantic_analyzer: SemanticAnalyzer,
    code_generator: CodeGenerator,
}

impl Compiler {
    fn new(source: &str) -> Self {
        let lexer = Lexer::new(source);
        Compiler {
            lexer,
            parser: Parser::new(Vec::new()),
            semantic_analyzer: SemanticAnalyzer::new(),
            code_generator: CodeGenerator::new(),
        }
    }
    
    fn compile(&mut self) -> Result<Vec<Instruction>, Vec<String>> {
        // 词法分析
        let mut tokens = Vec::new();
        while let Some(token) = self.lexer.next_token() {
            if token.token_type == TokenType::EOF {
                break;
            }
            tokens.push(token);
        }
        
        // 语法分析
        self.parser = Parser::new(tokens);
        let ast = self.parser.parse().ok_or(vec!["Parse error".to_string()])?;
        
        // 语义分析
        self.semantic_analyzer.analyze(&ast).ok_or(self.semantic_analyzer.get_errors().to_vec())?;
        
        // 代码生成
        let instructions = self.code_generator.generate(&ast);
        
        Ok(instructions)
    }
}
```

## 6. 交叉引用

- [[00-编程语言理论总论]]
- [[01-语言设计理论]]
- [[03-类型系统理论]]

## 7. 导航

- [返回总目录](../README.md)
- [上一章：语言设计理论](01-语言设计理论.md)
- [下一章：类型系统理论](03-类型系统理论.md)
