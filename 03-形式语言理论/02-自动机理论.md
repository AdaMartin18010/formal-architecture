# 自动机理论

## 1. 概述

自动机理论研究抽象计算模型，包括有限自动机、下推自动机和图灵机，为形式语言识别和计算理论提供基础。

## 2. 基本概念

### 2.1 有限自动机

- **DFA**：确定性有限自动机 $M = (Q, \Sigma, \delta, q_0, F)$
- **NFA**：非确定性有限自动机
- **ε-NFA**：带ε转移的非确定性有限自动机

### 2.2 下推自动机

- **PDA**：下推自动机 $M = (Q, \Sigma, \Gamma, \delta, q_0, Z_0, F)$
- **栈操作**：压栈、弹栈、替换
- **上下文无关语言**：PDA识别的语言类

### 2.3 图灵机

- **TM**：图灵机 $M = (Q, \Sigma, \Gamma, \delta, q_0, B, F)$
- **通用计算**：图灵完备性
- **停机问题**：不可判定性

## 3. 形式化表示

### 3.1 有限自动机

```latex
\delta: Q \times \Sigma \rightarrow Q \quad \text{(DFA转移函数)}
```

```latex
\delta: Q \times \Sigma \rightarrow 2^Q \quad \text{(NFA转移函数)}
```

### 3.2 下推自动机

```latex
\delta: Q \times \Sigma \times \Gamma \rightarrow 2^{Q \times \Gamma^*} \quad \text{(PDA转移函数)}
```

### 3.3 图灵机

```latex
\delta: Q \times \Gamma \rightarrow Q \times \Gamma \times \{L, R\} \quad \text{(TM转移函数)}
```

## 4. 软件架构应用

### 4.1 状态机

- **协议状态机**：网络协议的状态转换
- **工作流引擎**：业务流程的状态管理
- **UI状态机**：用户界面的状态转换

### 4.2 解析器

- **词法分析器**：基于DFA的token识别
- **语法分析器**：基于PDA的语法分析
- **语义分析器**：基于TM的语义处理

## 5. 代码示例

```rust
use std::collections::{HashMap, HashSet};

// 有限自动机
#[derive(Clone, Debug, Eq, PartialEq, Hash)]
struct State(String);

#[derive(Clone, Debug, Eq, PartialEq, Hash)]
struct Symbol(char);

struct FiniteAutomaton {
    states: HashSet<State>,
    alphabet: HashSet<Symbol>,
    transitions: HashMap<(State, Symbol), State>,
    initial_state: State,
    final_states: HashSet<State>,
}

impl FiniteAutomaton {
    fn new(initial_state: State) -> Self {
        FiniteAutomaton {
            states: HashSet::new(),
            alphabet: HashSet::new(),
            transitions: HashMap::new(),
            initial_state,
            final_states: HashSet::new(),
        }
    }
    
    fn add_state(&mut self, state: State) {
        self.states.insert(state);
    }
    
    fn add_symbol(&mut self, symbol: Symbol) {
        self.alphabet.insert(symbol);
    }
    
    fn add_transition(&mut self, from: State, symbol: Symbol, to: State) {
        self.transitions.insert((from, symbol), to);
    }
    
    fn add_final_state(&mut self, state: State) {
        self.final_states.insert(state);
    }
    
    fn accepts(&self, input: &str) -> bool {
        let mut current_state = self.initial_state.clone();
        
        for c in input.chars() {
            let symbol = Symbol(c);
            if let Some(next_state) = self.transitions.get(&(current_state.clone(), symbol)) {
                current_state = next_state.clone();
            } else {
                return false;
            }
        }
        
        self.final_states.contains(&current_state)
    }
    
    fn minimize(&self) -> FiniteAutomaton {
        // 最小化DFA（简化实现）
        self.clone()
    }
    
    fn to_regex(&self) -> String {
        // 转换为正则表达式（简化实现）
        ".*".to_string()
    }
}

// 非确定性有限自动机
struct NondeterministicFiniteAutomaton {
    states: HashSet<State>,
    alphabet: HashSet<Symbol>,
    transitions: HashMap<(State, Symbol), HashSet<State>>,
    initial_states: HashSet<State>,
    final_states: HashSet<State>,
}

impl NondeterministicFiniteAutomaton {
    fn new() -> Self {
        NondeterministicFiniteAutomaton {
            states: HashSet::new(),
            alphabet: HashSet::new(),
            transitions: HashMap::new(),
            initial_states: HashSet::new(),
            final_states: HashSet::new(),
        }
    }
    
    fn add_transition(&mut self, from: State, symbol: Symbol, to: State) {
        self.transitions
            .entry((from, symbol))
            .or_insert_with(HashSet::new)
            .insert(to);
    }
    
    fn accepts(&self, input: &str) -> bool {
        let mut current_states = self.initial_states.clone();
        
        for c in input.chars() {
            let symbol = Symbol(c);
            let mut next_states = HashSet::new();
            
            for state in &current_states {
                if let Some(targets) = self.transitions.get(&(state.clone(), symbol.clone())) {
                    next_states.extend(targets.clone());
                }
            }
            
            current_states = next_states;
            if current_states.is_empty() {
                return false;
            }
        }
        
        current_states.iter().any(|state| self.final_states.contains(state))
    }
    
    fn to_dfa(&self) -> FiniteAutomaton {
        // 子集构造法转换为DFA（简化实现）
        let initial_state = State("q0".to_string());
        FiniteAutomaton::new(initial_state)
    }
}

// 下推自动机
#[derive(Clone, Debug, Eq, PartialEq, Hash)]
struct StackSymbol(String);

struct PushdownAutomaton {
    states: HashSet<State>,
    input_alphabet: HashSet<Symbol>,
    stack_alphabet: HashSet<StackSymbol>,
    transitions: HashMap<(State, Symbol, StackSymbol), Vec<(State, Vec<StackSymbol>)>>,
    initial_state: State,
    initial_stack_symbol: StackSymbol,
    final_states: HashSet<State>,
}

impl PushdownAutomaton {
    fn new(initial_state: State, initial_stack_symbol: StackSymbol) -> Self {
        PushdownAutomaton {
            states: HashSet::new(),
            input_alphabet: HashSet::new(),
            stack_alphabet: HashSet::new(),
            transitions: HashMap::new(),
            initial_state,
            initial_stack_symbol,
            final_states: HashSet::new(),
        }
    }
    
    fn add_transition(&mut self, from: State, input: Symbol, stack_top: StackSymbol, 
                     to: State, stack_push: Vec<StackSymbol>) {
        self.transitions
            .entry((from, input, stack_top))
            .or_insert_with(Vec::new)
            .push((to, stack_push));
    }
    
    fn accepts(&self, input: &str) -> bool {
        let mut configurations = vec![(
            self.initial_state.clone(),
            input.chars().collect::<Vec<_>>(),
            vec![self.initial_stack_symbol.clone()]
        )];
        
        while !configurations.is_empty() {
            let mut next_configurations = Vec::new();
            
            for (state, input_remaining, stack) in configurations {
                if input_remaining.is_empty() {
                    if self.final_states.contains(&state) {
                        return true;
                    }
                    continue;
                }
                
                let current_symbol = Symbol(input_remaining[0]);
                let stack_top = stack.last().unwrap().clone();
                
                if let Some(transitions) = self.transitions.get(&(state.clone(), current_symbol, stack_top.clone())) {
                    for (next_state, stack_push) in transitions {
                        let mut new_stack = stack.clone();
                        new_stack.pop(); // 弹出栈顶
                        new_stack.extend(stack_push.clone()); // 压入新符号
                        
                        next_configurations.push((
                            next_state.clone(),
                            input_remaining[1..].to_vec(),
                            new_stack
                        ));
                    }
                }
            }
            
            configurations = next_configurations;
        }
        
        false
    }
}

// 图灵机
#[derive(Clone, Debug, Eq, PartialEq)]
enum Direction {
    Left,
    Right,
}

struct TuringMachine {
    states: HashSet<State>,
    input_alphabet: HashSet<Symbol>,
    tape_alphabet: HashSet<Symbol>,
    transitions: HashMap<(State, Symbol), (State, Symbol, Direction)>,
    initial_state: State,
    blank_symbol: Symbol,
    final_states: HashSet<State>,
}

impl TuringMachine {
    fn new(initial_state: State, blank_symbol: Symbol) -> Self {
        TuringMachine {
            states: HashSet::new(),
            input_alphabet: HashSet::new(),
            tape_alphabet: HashSet::new(),
            transitions: HashMap::new(),
            initial_state,
            blank_symbol,
            final_states: HashSet::new(),
        }
    }
    
    fn add_transition(&mut self, from: State, read: Symbol, to: State, write: Symbol, direction: Direction) {
        self.transitions.insert((from, read), (to, write, direction));
    }
    
    fn run(&self, input: &str) -> Option<String> {
        let mut tape: Vec<Symbol> = input.chars().map(Symbol).collect();
        let mut head = 0;
        let mut current_state = self.initial_state.clone();
        let mut steps = 0;
        let max_steps = 10000; // 防止无限循环
        
        while steps < max_steps {
            if self.final_states.contains(&current_state) {
                // 返回磁带内容
                return Some(tape.iter().map(|s| s.0).collect());
            }
            
            // 扩展磁带
            while head >= tape.len() {
                tape.push(self.blank_symbol.clone());
            }
            while head < 0 {
                tape.insert(0, self.blank_symbol.clone());
                head += 1;
            }
            
            let current_symbol = &tape[head];
            
            if let Some((next_state, write_symbol, direction)) = self.transitions.get(&(current_state.clone(), current_symbol.clone())) {
                tape[head] = write_symbol.clone();
                current_state = next_state.clone();
                
                match direction {
                    Direction::Left => head -= 1,
                    Direction::Right => head += 1,
                }
            } else {
                // 没有转移规则，停机
                break;
            }
            
            steps += 1;
        }
        
        None
    }
    
    fn is_decider(&self) -> bool {
        // 检查是否为判定器（总是停机）
        // 简化实现
        true
    }
}

// 自动机工具
struct AutomatonTools;

impl AutomatonTools {
    fn dfa_to_regex(dfa: &FiniteAutomaton) -> String {
        // 状态消除法转换为正则表达式
        ".*".to_string()
    }
    
    fn nfa_to_dfa(nfa: &NondeterministicFiniteAutomaton) -> FiniteAutomaton {
        nfa.to_dfa()
    }
    
    fn minimize_dfa(dfa: &FiniteAutomaton) -> FiniteAutomaton {
        dfa.minimize()
    }
    
    fn is_regular(language: &str) -> bool {
        // 检查语言是否为正则语言
        language.len() < 100 // 简化判断
    }
    
    fn is_context_free(language: &str) -> bool {
        // 检查语言是否为上下文无关语言
        true
    }
}

// 状态机实现
struct StateMachine<S, E> {
    current_state: S,
    transitions: HashMap<(S, E), S>,
    initial_state: S,
    final_states: HashSet<S>,
}

impl<S: Clone + Eq + std::hash::Hash, E: Clone + Eq + std::hash::Hash> StateMachine<S, E> {
    fn new(initial_state: S) -> Self {
        StateMachine {
            current_state: initial_state.clone(),
            transitions: HashMap::new(),
            initial_state,
            final_states: HashSet::new(),
        }
    }
    
    fn add_transition(&mut self, from: S, event: E, to: S) {
        self.transitions.insert((from, event), to);
    }
    
    fn add_final_state(&mut self, state: S) {
        self.final_states.insert(state);
    }
    
    fn transition(&mut self, event: E) -> bool {
        if let Some(next_state) = self.transitions.get(&(self.current_state.clone(), event.clone())) {
            self.current_state = next_state.clone();
            true
        } else {
            false
        }
    }
    
    fn is_final(&self) -> bool {
        self.final_states.contains(&self.current_state)
    }
    
    fn reset(&mut self) {
        self.current_state = self.initial_state.clone();
    }
}
```

## 6. 交叉引用

- [[00-形式语言理论总论]]
- [[01-形式语言基础]]
- [[03-语法分析理论]]

## 7. 导航

- [返回总目录](../README.md)
- [上一章：形式语言基础](01-形式语言基础.md)
- [下一章：语法分析理论](03-语法分析理论.md)
