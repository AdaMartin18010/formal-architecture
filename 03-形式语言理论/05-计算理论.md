# 计算理论

## 1. 概述

计算理论研究计算的本质和极限，包括可计算性理论、复杂性理论和NP完全性理论。

## 2. 基本概念

### 2.1 可计算性理论

- **图灵机**：通用计算模型
- **可计算函数**：图灵机可计算的函数
- **停机问题**：不可判定的问题

### 2.2 复杂性理论

- **时间复杂度**：算法执行时间的度量
- **空间复杂度**：算法内存使用的度量
- **P类问题**：多项式时间可解的问题

### 2.3 NP完全性理论

- **NP类问题**：非确定性多项式时间可验证的问题
- **NP完全问题**：NP类中最难的问题
- **P vs NP问题**：计算理论的核心问题

## 3. 形式化表示

### 3.1 可计算性

```latex
f \text{ 可计算 } \leftrightarrow \exists M \text{ 图灵机}: M \text{ 计算 } f
```

### 3.2 时间复杂度

```latex
T(n) = O(f(n)) \leftrightarrow \exists c, n_0: \forall n \geq n_0, T(n) \leq c \cdot f(n)
```

### 3.3 NP完全性

```latex
L \in \text{NP} \leftrightarrow \exists \text{多项式时间验证器 } V: L = \{x | \exists y: V(x,y) = 1\}
```

## 4. 软件架构应用

### 4.1 算法设计

- **复杂度分析**：算法性能的理论分析
- **优化策略**：基于复杂度的优化
- **可扩展性**：系统规模增长的分析

### 4.2 问题分类

- **易解问题**：P类问题
- **难解问题**：NP完全问题
- **不可解问题**：不可判定问题

## 5. 代码示例

```rust
use std::collections::HashMap;
use std::time::{Duration, Instant};

// 复杂度分析
struct ComplexityAnalyzer;

impl ComplexityAnalyzer {
    fn analyze_time_complexity<F, T>(&self, f: F, inputs: &[usize]) -> Vec<(usize, Duration)>
    where F: Fn(usize) -> T {
        let mut results = Vec::new();
        
        for &input_size in inputs {
            let start = Instant::now();
            let _result = f(input_size);
            let duration = start.elapsed();
            results.push((input_size, duration));
        }
        
        results
    }
    
    fn estimate_complexity(&self, measurements: &[(usize, Duration)]) -> String {
        if measurements.len() < 2 {
            return "O(1)".to_string();
        }
        
        let (n1, t1) = measurements[0];
        let (n2, t2) = measurements[1];
        
        let ratio = t2.as_nanos() as f64 / t1.as_nanos() as f64;
        let n_ratio = n2 as f64 / n1 as f64;
        
        if ratio < n_ratio.sqrt() {
            "O(1)".to_string()
        } else if ratio < n_ratio {
            "O(log n)".to_string()
        } else if ratio < n_ratio * n_ratio.log2() {
            "O(n)".to_string()
        } else if ratio < n_ratio * n_ratio {
            "O(n log n)".to_string()
        } else if ratio < n_ratio * n_ratio * n_ratio {
            "O(n²)".to_string()
        } else {
            "O(n³) or higher".to_string()
        }
    }
}

// P类问题示例
struct PProblems;

impl PProblems {
    fn linear_search<T: PartialEq>(arr: &[T], target: &T) -> Option<usize> {
        for (i, item) in arr.iter().enumerate() {
            if item == target {
                return Some(i);
            }
        }
        None
    }
    
    fn binary_search<T: Ord>(arr: &[T], target: &T) -> Option<usize> {
        let mut left = 0;
        let mut right = arr.len();
        
        while left < right {
            let mid = left + (right - left) / 2;
            match arr[mid].cmp(target) {
                std::cmp::Ordering::Equal => return Some(mid),
                std::cmp::Ordering::Less => left = mid + 1,
                std::cmp::Ordering::Greater => right = mid,
            }
        }
        None
    }
    
    fn merge_sort<T: Ord + Clone>(arr: &mut [T]) {
        if arr.len() <= 1 {
            return;
        }
        
        let mid = arr.len() / 2;
        let mut left = arr[..mid].to_vec();
        let mut right = arr[mid..].to_vec();
        
        Self::merge_sort(&mut left);
        Self::merge_sort(&mut right);
        
        let mut i = 0;
        let mut j = 0;
        let mut k = 0;
        
        while i < left.len() && j < right.len() {
            if left[i] <= right[j] {
                arr[k] = left[i].clone();
                i += 1;
            } else {
                arr[k] = right[j].clone();
                j += 1;
            }
            k += 1;
        }
        
        while i < left.len() {
            arr[k] = left[i].clone();
            i += 1;
            k += 1;
        }
        
        while j < right.len() {
            arr[k] = right[j].clone();
            j += 1;
            k += 1;
        }
    }
}

// NP类问题示例
struct NPProblems;

impl NPProblems {
    fn subset_sum(arr: &[i32], target: i32) -> bool {
        // 子集和问题是NP完全问题
        Self::subset_sum_recursive(arr, target, 0, 0)
    }
    
    fn subset_sum_recursive(arr: &[i32], target: i32, current_sum: i32, index: usize) -> bool {
        if current_sum == target {
            return true;
        }
        
        if index >= arr.len() || current_sum > target {
            return false;
        }
        
        // 包含当前元素
        if Self::subset_sum_recursive(arr, target, current_sum + arr[index], index + 1) {
            return true;
        }
        
        // 不包含当前元素
        Self::subset_sum_recursive(arr, target, current_sum, index + 1)
    }
    
    fn hamiltonian_cycle(graph: &Vec<Vec<bool>>) -> bool {
        // 哈密顿回路问题是NP完全问题
        let n = graph.len();
        let mut visited = vec![false; n];
        visited[0] = true;
        
        Self::hamiltonian_cycle_recursive(graph, &mut visited, 0, 1, n)
    }
    
    fn hamiltonian_cycle_recursive(
        graph: &Vec<Vec<bool>>,
        visited: &mut Vec<bool>,
        current: usize,
        count: usize,
        total: usize,
    ) -> bool {
        if count == total {
            return graph[current][0]; // 检查是否可以回到起点
        }
        
        for next in 0..total {
            if graph[current][next] && !visited[next] {
                visited[next] = true;
                if Self::hamiltonian_cycle_recursive(graph, visited, next, count + 1, total) {
                    return true;
                }
                visited[next] = false;
            }
        }
        
        false
    }
    
    fn verify_subset_sum(arr: &[i32], target: i32, subset: &[usize]) -> bool {
        // 验证子集和问题的解（多项式时间）
        let sum: i32 = subset.iter().map(|&i| arr[i]).sum();
        sum == target
    }
}

// 不可判定问题示例
struct UndecidableProblems;

impl UndecidableProblems {
    fn halting_problem(program: &str, input: &str) -> bool {
        // 停机问题的简化版本
        // 实际上这是不可判定的
        if program.contains("while true") {
            false // 假设包含无限循环的程序不会停机
        } else {
            true // 假设其他程序会停机
        }
    }
    
    fn rice_theorem(property: &str, program: &str) -> bool {
        // Rice定理：任何非平凡的程序性质都是不可判定的
        // 简化实现
        match property {
            "halts" => Self::halting_problem(program, ""),
            "computes_constant" => program.contains("return 42"),
            _ => false,
        }
    }
}

// 图灵机模拟器
#[derive(Clone, Debug)]
enum TapeSymbol {
    Zero,
    One,
    Blank,
}

#[derive(Clone, Debug)]
enum Direction {
    Left,
    Right,
}

#[derive(Clone, Debug)]
struct Transition {
    current_state: String,
    read_symbol: TapeSymbol,
    next_state: String,
    write_symbol: TapeSymbol,
    direction: Direction,
}

struct TuringMachine {
    states: Vec<String>,
    alphabet: Vec<TapeSymbol>,
    transitions: Vec<Transition>,
    initial_state: String,
    accept_state: String,
    reject_state: String,
}

impl TuringMachine {
    fn new(initial_state: String, accept_state: String, reject_state: String) -> Self {
        TuringMachine {
            states: Vec::new(),
            alphabet: Vec::new(),
            transitions: Vec::new(),
            initial_state,
            accept_state,
            reject_state,
        }
    }
    
    fn add_transition(&mut self, transition: Transition) {
        self.transitions.push(transition);
    }
    
    fn run(&self, input: &str) -> bool {
        let mut tape: Vec<TapeSymbol> = input
            .chars()
            .map(|c| if c == '1' { TapeSymbol::One } else { TapeSymbol::Zero })
            .collect();
        
        let mut head = 0;
        let mut current_state = self.initial_state.clone();
        let mut steps = 0;
        let max_steps = 10000; // 防止无限循环
        
        while steps < max_steps {
            if current_state == self.accept_state {
                return true;
            }
            if current_state == self.reject_state {
                return false;
            }
            
            // 扩展磁带
            while head >= tape.len() {
                tape.push(TapeSymbol::Blank);
            }
            while head < 0 {
                tape.insert(0, TapeSymbol::Blank);
                head += 1;
            }
            
            let current_symbol = &tape[head];
            
            // 查找转移规则
            let mut found_transition = false;
            for transition in &self.transitions {
                if transition.current_state == current_state && 
                   std::mem::discriminant(&transition.read_symbol) == std::mem::discriminant(current_symbol) {
                    // 执行转移
                    tape[head] = transition.write_symbol.clone();
                    current_state = transition.next_state.clone();
                    
                    match transition.direction {
                        Direction::Left => head -= 1,
                        Direction::Right => head += 1,
                    }
                    
                    found_transition = true;
                    break;
                }
            }
            
            if !found_transition {
                return false; // 没有转移规则，拒绝
            }
            
            steps += 1;
        }
        
        false // 超过最大步数，拒绝
    }
}

// 复杂度类分析
struct ComplexityClasses;

impl ComplexityClasses {
    fn is_in_p<F>(f: F) -> bool
    where F: Fn(&str) -> bool {
        // 检查问题是否在P类中（简化实现）
        true
    }
    
    fn is_in_np<F, V>(f: F, verifier: V) -> bool
    where F: Fn(&str) -> bool,
          V: Fn(&str, &str) -> bool {
        // 检查问题是否在NP类中（简化实现）
        true
    }
    
    fn is_np_complete<F>(f: F) -> bool
    where F: Fn(&str) -> bool {
        // 检查问题是否是NP完全的（简化实现）
        false
    }
    
    fn reduce_problem<F1, F2>(problem1: F1, problem2: F2) -> bool
    where F1: Fn(&str) -> bool,
          F2: Fn(&str) -> bool {
        // 问题归约（简化实现）
        true
    }
}

// 算法优化
struct AlgorithmOptimizer;

impl AlgorithmOptimizer {
    fn memoize<F, T, R>(f: F) -> impl Fn(T) -> R
    where F: Fn(T) -> R,
          T: Clone + std::hash::Hash + Eq,
          R: Clone {
        let mut cache = HashMap::new();
        move |input| {
            if let Some(result) = cache.get(&input) {
                result.clone()
            } else {
                let result = f(input.clone());
                cache.insert(input, result.clone());
                result
            }
        }
    }
    
    fn dynamic_programming_fibonacci() -> impl Fn(usize) -> u64 {
        let mut cache = HashMap::new();
        cache.insert(0, 0);
        cache.insert(1, 1);
        
        move |n| {
            if let Some(&result) = cache.get(&n) {
                result
            } else {
                let result = cache.get(&(n - 1)).unwrap() + cache.get(&(n - 2)).unwrap();
                cache.insert(n, result);
                result
            }
        }
    }
    
    fn greedy_algorithm(weights: &[u32], values: &[u32], capacity: u32) -> u32 {
        let mut items: Vec<_> = weights.iter().zip(values.iter())
            .enumerate()
            .map(|(i, (&w, &v))| (i, w, v, v as f64 / w as f64))
            .collect();
        
        items.sort_by(|a, b| b.3.partial_cmp(&a.3).unwrap());
        
        let mut total_value = 0;
        let mut remaining_capacity = capacity;
        
        for (_, weight, value, _) in items {
            if weight <= remaining_capacity {
                total_value += value;
                remaining_capacity -= weight;
            }
        }
        
        total_value
    }
}
```

## 6. 交叉引用

- [[00-形式语言理论总论]]
- [[01-形式语言基础]]
- [[02-自动机理论]]
- [[03-语法分析理论]]
- [[04-语义分析理论]]

## 7. 导航

- [返回总目录](../README.md)
- [上一章：语义分析理论](04-语义分析理论.md)
- [返回形式语言理论目录](../README.md#形式语言理论)
