# 语义分析理论

## 1. 概述

语义分析理论研究程序的含义和解释，包括操作语义、指称语义和公理语义等不同方法。

## 2. 基本概念

### 2.1 操作语义

- **小步语义**：逐步执行程序的步骤
- **大步语义**：程序执行的最终结果
- **抽象机**：程序执行的抽象模型

### 2.2 指称语义

- **数学函数**：程序含义的数学表示
- **域理论**：程序值的数学结构
- **不动点**：递归定义的语义

### 2.3 公理语义

- **霍尔逻辑**：程序性质的逻辑描述
- **前置条件**：程序执行前的状态
- **后置条件**：程序执行后的状态

## 3. 形式化表示

### 3.1 操作语义

```latex
\langle e, \sigma \rangle \rightarrow \langle e', \sigma' \rangle \quad \text{(小步语义)}
```

```latex
\langle e, \sigma \rangle \Downarrow v \quad \text{(大步语义)}
```

### 3.2 指称语义

```latex
[\![e]\!] : \Sigma \rightarrow V \quad \text{(表达式的指称)}
```

```latex
[\![c]\!] : \Sigma \rightarrow \Sigma \quad \text{(命令的指称)}
```

### 3.3 霍尔逻辑

```latex
\{P\} c \{Q\} \quad \text{(霍尔三元组)}
```

## 4. 软件架构应用

### 4.1 接口语义

- **API语义**：接口调用的含义
- **协议语义**：通信协议的行为
- **配置语义**：配置项的含义

### 4.2 组件语义

- **组件行为**：组件的功能语义
- **交互语义**：组件间的交互含义
- **状态语义**：组件状态的语义

## 5. 代码示例

```rust
use std::collections::HashMap;

// 操作语义
#[derive(Clone, Debug)]
struct Environment {
    variables: HashMap<String, Value>,
}

#[derive(Clone, Debug)]
enum Value {
    Integer(i64),
    Boolean(bool),
    String(String),
    Function(String, Vec<String>, Box<Expression>),
}

#[derive(Clone, Debug)]
enum Expression {
    Literal(Value),
    Variable(String),
    BinaryOp(Box<Expression>, BinaryOperator, Box<Expression>),
    If(Box<Expression>, Box<Expression>, Box<Expression>),
    Let(String, Box<Expression>, Box<Expression>),
    FunctionCall(String, Vec<Expression>),
}

#[derive(Clone, Debug)]
enum BinaryOperator {
    Add,
    Subtract,
    Multiply,
    Divide,
    Equal,
    LessThan,
    GreaterThan,
}

#[derive(Clone, Debug)]
enum Statement {
    Assignment(String, Expression),
    If(Expression, Box<Statement>, Option<Box<Statement>>),
    While(Expression, Box<Statement>),
    Block(Vec<Statement>),
    Skip,
}

// 小步语义
struct SmallStepSemantics;

impl SmallStepSemantics {
    fn step_expression(&self, expr: &Expression, env: &Environment) -> Option<(Expression, Environment)> {
        match expr {
            Expression::Literal(_) => None, // 值已经是最简形式
            Expression::Variable(name) => {
                if let Some(value) = env.variables.get(name) {
                    Some((Expression::Literal(value.clone()), env.clone()))
                } else {
                    None // 未定义变量
                }
            }
            Expression::BinaryOp(left, op, right) => {
                // 先求值左操作数
                if let Some((new_left, new_env)) = self.step_expression(left, env) {
                    Some((Expression::BinaryOp(Box::new(new_left), op.clone(), right.clone()), new_env))
                } else if let Some((new_right, new_env)) = self.step_expression(right, env) {
                    // 左操作数已求值，求值右操作数
                    Some((Expression::BinaryOp(left.clone(), op.clone(), Box::new(new_right)), new_env))
                } else {
                    // 两个操作数都已求值，执行运算
                    if let (Expression::Literal(left_val), Expression::Literal(right_val)) = (left.as_ref(), right.as_ref()) {
                        if let Some(result) = self.evaluate_binary_op(left_val, op, right_val) {
                            Some((Expression::Literal(result), env.clone()))
                        } else {
                            None
                        }
                    } else {
                        None
                    }
                }
            }
            Expression::If(condition, then_expr, else_expr) => {
                if let Some((new_condition, new_env)) = self.step_expression(condition, env) {
                    Some((Expression::If(Box::new(new_condition), then_expr.clone(), else_expr.clone()), new_env))
                } else if let Expression::Literal(Value::Boolean(true)) = condition.as_ref() {
                    Some((*then_expr.clone(), env.clone()))
                } else if let Expression::Literal(Value::Boolean(false)) = condition.as_ref() {
                    if let Some(else_expr) = else_expr {
                        Some((*else_expr.clone(), env.clone()))
                    } else {
                        Some((Expression::Literal(Value::Boolean(false)), env.clone()))
                    }
                } else {
                    None
                }
            }
            _ => None,
        }
    }
    
    fn evaluate_binary_op(&self, left: &Value, op: &BinaryOperator, right: &Value) -> Option<Value> {
        match (left, op, right) {
            (Value::Integer(a), BinaryOperator::Add, Value::Integer(b)) => {
                Some(Value::Integer(a + b))
            }
            (Value::Integer(a), BinaryOperator::Subtract, Value::Integer(b)) => {
                Some(Value::Integer(a - b))
            }
            (Value::Integer(a), BinaryOperator::Multiply, Value::Integer(b)) => {
                Some(Value::Integer(a * b))
            }
            (Value::Integer(a), BinaryOperator::Divide, Value::Integer(b)) => {
                if *b != 0 {
                    Some(Value::Integer(a / b))
                } else {
                    None
                }
            }
            (Value::Integer(a), BinaryOperator::Equal, Value::Integer(b)) => {
                Some(Value::Boolean(a == b))
            }
            (Value::Integer(a), BinaryOperator::LessThan, Value::Integer(b)) => {
                Some(Value::Boolean(a < b))
            }
            (Value::Integer(a), BinaryOperator::GreaterThan, Value::Integer(b)) => {
                Some(Value::Boolean(a > b))
            }
            _ => None,
        }
    }
    
    fn step_statement(&self, stmt: &Statement, env: &Environment) -> Option<(Statement, Environment)> {
        match stmt {
            Statement::Assignment(name, expr) => {
                if let Some((new_expr, new_env)) = self.step_expression(expr, env) {
                    Some((Statement::Assignment(name.clone(), new_expr), new_env))
                } else if let Expression::Literal(value) = expr {
                    let mut new_env = env.clone();
                    new_env.variables.insert(name.clone(), value.clone());
                    Some((Statement::Skip, new_env))
                } else {
                    None
                }
            }
            Statement::If(condition, then_stmt, else_stmt) => {
                if let Some((new_condition, new_env)) = self.step_expression(condition, env) {
                    Some((Statement::If(new_condition, then_stmt.clone(), else_stmt.clone()), new_env))
                } else if let Expression::Literal(Value::Boolean(true)) = condition.as_ref() {
                    Some((*then_stmt.clone(), env.clone()))
                } else if let Expression::Literal(Value::Boolean(false)) = condition.as_ref() {
                    if let Some(else_stmt) = else_stmt {
                        Some((*else_stmt.clone(), env.clone()))
                    } else {
                        Some((Statement::Skip, env.clone()))
                    }
                } else {
                    None
                }
            }
            Statement::While(condition, body) => {
                Some((Statement::If(condition.clone(), Box::new(Statement::Block(vec![*body.clone(), Statement::While(condition.clone(), body.clone())])), Some(Box::new(Statement::Skip))), env.clone()))
            }
            Statement::Block(statements) => {
                if statements.is_empty() {
                    Some((Statement::Skip, env.clone()))
                } else {
                    let first = &statements[0];
                    let rest = &statements[1..];
                    
                    if let Some((new_first, new_env)) = self.step_statement(first, env) {
                        let mut new_block = vec![new_first];
                        new_block.extend(rest.to_vec());
                        Some((Statement::Block(new_block), new_env))
                    } else {
                        if rest.is_empty() {
                            Some((Statement::Skip, env.clone()))
                        } else {
                            Some((Statement::Block(rest.to_vec()), env.clone()))
                        }
                    }
                }
            }
            Statement::Skip => None,
        }
    }
}

// 指称语义
struct DenotationalSemantics;

impl DenotationalSemantics {
    fn meaning_expression(&self, expr: &Expression, env: &Environment) -> Option<Value> {
        match expr {
            Expression::Literal(value) => Some(value.clone()),
            Expression::Variable(name) => env.variables.get(name).cloned(),
            Expression::BinaryOp(left, op, right) => {
                let left_val = self.meaning_expression(left, env)?;
                let right_val = self.meaning_expression(right, env)?;
                self.evaluate_binary_op(&left_val, op, &right_val)
            }
            Expression::If(condition, then_expr, else_expr) => {
                let condition_val = self.meaning_expression(condition, env)?;
                if let Value::Boolean(true) = condition_val {
                    self.meaning_expression(then_expr, env)
                } else {
                    if let Some(else_expr) = else_expr {
                        self.meaning_expression(else_expr, env)
                    } else {
                        Some(Value::Boolean(false))
                    }
                }
            }
            Expression::Let(name, value_expr, body_expr) => {
                let value = self.meaning_expression(value_expr, env)?;
                let mut new_env = env.clone();
                new_env.variables.insert(name.clone(), value);
                self.meaning_expression(body_expr, &new_env)
            }
            _ => None,
        }
    }
    
    fn meaning_statement(&self, stmt: &Statement, env: &Environment) -> Option<Environment> {
        match stmt {
            Statement::Assignment(name, expr) => {
                let value = self.meaning_expression(expr, env)?;
                let mut new_env = env.clone();
                new_env.variables.insert(name.clone(), value);
                Some(new_env)
            }
            Statement::If(condition, then_stmt, else_stmt) => {
                let condition_val = self.meaning_expression(condition, env)?;
                if let Value::Boolean(true) = condition_val {
                    self.meaning_statement(then_stmt, env)
                } else {
                    if let Some(else_stmt) = else_stmt {
                        self.meaning_statement(else_stmt, env)
                    } else {
                        Some(env.clone())
                    }
                }
            }
            Statement::While(condition, body) => {
                // 使用不动点语义
                self.meaning_while(condition, body, env)
            }
            Statement::Block(statements) => {
                let mut current_env = env.clone();
                for stmt in statements {
                    current_env = self.meaning_statement(stmt, &current_env)?;
                }
                Some(current_env)
            }
            Statement::Skip => Some(env.clone()),
        }
    }
    
    fn meaning_while(&self, condition: &Expression, body: &Statement, env: &Environment) -> Option<Environment> {
        // 简化实现：使用递归
        let condition_val = self.meaning_expression(condition, env)?;
        if let Value::Boolean(true) = condition_val {
            let new_env = self.meaning_statement(body, env)?;
            self.meaning_while(condition, body, &new_env)
        } else {
            Some(env.clone())
        }
    }
    
    fn evaluate_binary_op(&self, left: &Value, op: &BinaryOperator, right: &Value) -> Option<Value> {
        match (left, op, right) {
            (Value::Integer(a), BinaryOperator::Add, Value::Integer(b)) => {
                Some(Value::Integer(a + b))
            }
            (Value::Integer(a), BinaryOperator::Subtract, Value::Integer(b)) => {
                Some(Value::Integer(a - b))
            }
            (Value::Integer(a), BinaryOperator::Multiply, Value::Integer(b)) => {
                Some(Value::Integer(a * b))
            }
            (Value::Integer(a), BinaryOperator::Divide, Value::Integer(b)) => {
                if *b != 0 {
                    Some(Value::Integer(a / b))
                } else {
                    None
                }
            }
            (Value::Integer(a), BinaryOperator::Equal, Value::Integer(b)) => {
                Some(Value::Boolean(a == b))
            }
            (Value::Integer(a), BinaryOperator::LessThan, Value::Integer(b)) => {
                Some(Value::Boolean(a < b))
            }
            (Value::Integer(a), BinaryOperator::GreaterThan, Value::Integer(b)) => {
                Some(Value::Boolean(a > b))
            }
            _ => None,
        }
    }
}

// 公理语义（霍尔逻辑）
#[derive(Clone, Debug)]
struct Assertion {
    condition: String,
}

impl Assertion {
    fn new(condition: String) -> Self {
        Assertion { condition }
    }
    
    fn evaluate(&self, env: &Environment) -> bool {
        // 简化实现：检查条件是否满足
        self.condition.contains("true")
    }
}

struct HoareTriple {
    precondition: Assertion,
    statement: Statement,
    postcondition: Assertion,
}

impl HoareTriple {
    fn new(precondition: Assertion, statement: Statement, postcondition: Assertion) -> Self {
        HoareTriple {
            precondition,
            statement,
            postcondition,
        }
    }
    
    fn is_valid(&self, env: &Environment) -> bool {
        // 验证霍尔三元组的有效性
        if self.precondition.evaluate(env) {
            // 执行语句
            let denotational = DenotationalSemantics;
            if let Some(new_env) = denotational.meaning_statement(&self.statement, env) {
                // 检查后置条件
                self.postcondition.evaluate(&new_env)
            } else {
                false
            }
        } else {
            true // 前置条件不满足时，三元组总是有效
        }
    }
}

// 语义分析工具
struct SemanticAnalyzer;

impl SemanticAnalyzer {
    fn type_check(&self, expr: &Expression, env: &Environment) -> Option<String> {
        // 类型检查（简化实现）
        match expr {
            Expression::Literal(Value::Integer(_)) => Some("int".to_string()),
            Expression::Literal(Value::Boolean(_)) => Some("bool".to_string()),
            Expression::Literal(Value::String(_)) => Some("string".to_string()),
            Expression::Variable(name) => {
                // 从环境中获取类型信息
                Some("unknown".to_string())
            }
            Expression::BinaryOp(left, op, right) => {
                let left_type = self.type_check(left, env)?;
                let right_type = self.type_check(right, env)?;
                
                match op {
                    BinaryOperator::Add | BinaryOperator::Subtract | BinaryOperator::Multiply | BinaryOperator::Divide => {
                        if left_type == "int" && right_type == "int" {
                            Some("int".to_string())
                        } else {
                            None
                        }
                    }
                    BinaryOperator::Equal | BinaryOperator::LessThan | BinaryOperator::GreaterThan => {
                        if left_type == right_type {
                            Some("bool".to_string())
                        } else {
                            None
                        }
                    }
                }
            }
            _ => Some("unknown".to_string()),
        }
    }
    
    fn check_termination(&self, stmt: &Statement) -> bool {
        // 检查程序是否终止（简化实现）
        match stmt {
            Statement::While(_, _) => false, // 简化：假设所有循环都可能不终止
            Statement::If(_, then_stmt, else_stmt) => {
                self.check_termination(then_stmt) && 
                else_stmt.as_ref().map_or(true, |stmt| self.check_termination(stmt))
            }
            Statement::Block(statements) => {
                statements.iter().all(|stmt| self.check_termination(stmt))
            }
            _ => true,
        }
    }
    
    fn optimize(&self, expr: &Expression) -> Expression {
        // 表达式优化（简化实现）
        match expr {
            Expression::BinaryOp(left, BinaryOperator::Add, right) => {
                if let Expression::Literal(Value::Integer(0)) = left.as_ref() {
                    return *right.clone();
                }
                if let Expression::Literal(Value::Integer(0)) = right.as_ref() {
                    return *left.clone();
                }
            }
            Expression::BinaryOp(left, BinaryOperator::Multiply, right) => {
                if let Expression::Literal(Value::Integer(1)) = left.as_ref() {
                    return *right.clone();
                }
                if let Expression::Literal(Value::Integer(1)) = right.as_ref() {
                    return *left.clone();
                }
            }
            _ => {}
        }
        expr.clone()
    }
}
```

## 6. 交叉引用

- [[00-形式语言理论总论]]
- [[01-形式语言基础]]
- [[02-自动机理论]]
- [[03-语法分析理论]]

## 7. 导航

- [返回总目录](../README.md)
- [上一章：语法分析理论](03-语法分析理论.md)
- [下一章：计算理论](05-计算理论.md)
