# 形式语言基础

## 1. 概述

形式语言基础研究语言的基本数学结构，包括字母表、字符串、语言和基本运算。

## 2. 基本概念

### 2.1 字母表

- **字母表**：$\Sigma$ 是符号的有限集合
- **符号**：字母表中的元素
- **空字母表**：$\emptyset$

### 2.2 字符串

- **字符串**：字母表上符号的有限序列
- **空字符串**：$\epsilon$ 或 $\lambda$
- **字符串长度**：$|w|$ 表示字符串 $w$ 的长度

### 2.3 语言

- **语言**：$L \subseteq \Sigma^*$ 是字符串的集合
- **空语言**：$\emptyset$
- **通用语言**：$\Sigma^*$

## 3. 形式化表示

### 3.1 字符串运算

```latex
\text{连接: } w \cdot v = wv
```

```latex
\text{幂运算: } w^n = \underbrace{w \cdot w \cdots w}_{n \text{ 次}}
```

```latex
\text{克林闭包: } \Sigma^* = \bigcup_{n=0}^{\infty} \Sigma^n
```

### 3.2 语言运算

```latex
\text{并集: } L_1 \cup L_2 = \{w | w \in L_1 \lor w \in L_2\}
```

```latex
\text{连接: } L_1 \cdot L_2 = \{w_1 w_2 | w_1 \in L_1 \land w_2 \in L_2\}
```

```latex
\text{克林闭包: } L^* = \bigcup_{n=0}^{\infty} L^n
```

## 4. 软件架构应用

### 4.1 接口语言

- **API语言**：接口定义的语法
- **配置语言**：系统配置的语法
- **查询语言**：数据查询的语法

### 4.2 协议语言

- **通信协议**：网络通信的语法
- **序列化格式**：数据序列化的语法
- **元数据语言**：系统元数据的语法

## 5. 代码示例

```rust
use std::collections::HashSet;

// 字母表
#[derive(Clone, Debug, Eq, PartialEq, Hash)]
struct Alphabet {
    symbols: HashSet<char>,
}

impl Alphabet {
    fn new() -> Self {
        Alphabet {
            symbols: HashSet::new(),
        }
    }
    
    fn add_symbol(&mut self, symbol: char) {
        self.symbols.insert(symbol);
    }
    
    fn contains(&self, symbol: &char) -> bool {
        self.symbols.contains(symbol)
    }
    
    fn size(&self) -> usize {
        self.symbols.len()
    }
    
    fn is_empty(&self) -> bool {
        self.symbols.is_empty()
    }
}

// 字符串
#[derive(Clone, Debug, Eq, PartialEq, Hash)]
struct String {
    characters: Vec<char>,
    alphabet: Alphabet,
}

impl String {
    fn new(alphabet: Alphabet) -> Self {
        String {
            characters: Vec::new(),
            alphabet,
        }
    }
    
    fn from_str(s: &str, alphabet: Alphabet) -> Self {
        let characters: Vec<char> = s.chars().collect();
        String {
            characters,
            alphabet,
        }
    }
    
    fn length(&self) -> usize {
        self.characters.len()
    }
    
    fn is_empty(&self) -> bool {
        self.characters.is_empty()
    }
    
    fn concatenate(&self, other: &String) -> String {
        let mut result = self.clone();
        result.characters.extend(other.characters.clone());
        result
    }
    
    fn power(&self, n: usize) -> String {
        let mut result = String::new(self.alphabet.clone());
        for _ in 0..n {
            result = result.concatenate(self);
        }
        result
    }
    
    fn substring(&self, start: usize, end: usize) -> String {
        let characters = self.characters[start..end].to_vec();
        String {
            characters,
            alphabet: self.alphabet.clone(),
        }
    }
    
    fn reverse(&self) -> String {
        let characters = self.characters.iter().rev().cloned().collect();
        String {
            characters,
            alphabet: self.alphabet.clone(),
        }
    }
}

// 语言
#[derive(Clone, Debug)]
struct Language {
    strings: HashSet<String>,
    alphabet: Alphabet,
}

impl Language {
    fn new(alphabet: Alphabet) -> Self {
        Language {
            strings: HashSet::new(),
            alphabet,
        }
    }
    
    fn add_string(&mut self, string: String) {
        self.strings.insert(string);
    }
    
    fn contains(&self, string: &String) -> bool {
        self.strings.contains(string)
    }
    
    fn is_empty(&self) -> bool {
        self.strings.is_empty()
    }
    
    fn size(&self) -> usize {
        self.strings.len()
    }
    
    fn union(&self, other: &Language) -> Language {
        let mut result = Language::new(self.alphabet.clone());
        for string in &self.strings {
            result.add_string(string.clone());
        }
        for string in &other.strings {
            result.add_string(string.clone());
        }
        result
    }
    
    fn concatenation(&self, other: &Language) -> Language {
        let mut result = Language::new(self.alphabet.clone());
        for string1 in &self.strings {
            for string2 in &other.strings {
                result.add_string(string1.concatenate(string2));
            }
        }
        result
    }
    
    fn kleene_star(&self) -> Language {
        let mut result = Language::new(self.alphabet.clone());
        // 添加空字符串
        result.add_string(String::new(self.alphabet.clone()));
        
        // 递归生成所有幂次
        let mut current = self.clone();
        for _ in 0..10 { // 限制迭代次数避免无限循环
            let new_strings = current.concatenation(self);
            for string in &new_strings.strings {
                result.add_string(string.clone());
            }
            current = new_strings;
        }
        
        result
    }
    
    fn intersection(&self, other: &Language) -> Language {
        let mut result = Language::new(self.alphabet.clone());
        for string in &self.strings {
            if other.contains(string) {
                result.add_string(string.clone());
            }
        }
        result
    }
    
    fn complement(&self) -> Language {
        // 简化实现：假设有限字母表上的所有可能字符串
        let mut result = Language::new(self.alphabet.clone());
        // 这里需要生成所有可能的字符串，简化处理
        result
    }
}

// 语言操作工具
struct LanguageOperations;

impl LanguageOperations {
    fn is_regular(&self, language: &Language) -> bool {
        // 检查是否为正则语言（简化实现）
        language.size() < 1000 // 假设有限语言是正则的
    }
    
    fn is_context_free(&self, language: &Language) -> bool {
        // 检查是否为上下文无关语言（简化实现）
        true
    }
    
    fn is_decidable(&self, language: &Language) -> bool {
        // 检查是否为可判定语言（简化实现）
        true
    }
    
    fn generate_strings(&self, language: &Language, max_length: usize) -> Vec<String> {
        let mut result = Vec::new();
        for string in &language.strings {
            if string.length() <= max_length {
                result.push(string.clone());
            }
        }
        result
    }
}

// 正则表达式
#[derive(Clone, Debug)]
enum Regex {
    Empty,
    Epsilon,
    Symbol(char),
    Union(Box<Regex>, Box<Regex>),
    Concatenation(Box<Regex>, Box<Regex>),
    KleeneStar(Box<Regex>),
}

impl Regex {
    fn matches(&self, string: &String) -> bool {
        match self {
            Regex::Empty => false,
            Regex::Epsilon => string.is_empty(),
            Regex::Symbol(c) => string.length() == 1 && string.characters[0] == *c,
            Regex::Union(r1, r2) => r1.matches(string) || r2.matches(string),
            Regex::Concatenation(r1, r2) => {
                for i in 0..=string.length() {
                    let prefix = string.substring(0, i);
                    let suffix = string.substring(i, string.length());
                    if r1.matches(&prefix) && r2.matches(&suffix) {
                        return true;
                    }
                }
                false
            }
            Regex::KleeneStar(r) => {
                if string.is_empty() {
                    return true;
                }
                for i in 1..=string.length() {
                    let prefix = string.substring(0, i);
                    let suffix = string.substring(i, string.length());
                    if r.matches(&prefix) && self.matches(&suffix) {
                        return true;
                    }
                }
                false
            }
        }
    }
    
    fn to_language(&self, alphabet: Alphabet) -> Language {
        let mut language = Language::new(alphabet);
        // 简化实现：生成一些匹配的字符串
        match self {
            Regex::Empty => {}
            Regex::Epsilon => {
                language.add_string(String::new(alphabet));
            }
            Regex::Symbol(c) => {
                let mut string = String::new(alphabet);
                string.characters.push(*c);
                language.add_string(string);
            }
            _ => {
                // 其他情况需要更复杂的实现
            }
        }
        language
    }
}
```

## 6. 交叉引用

- [[00-形式语言理论总论]]
- [[02-自动机理论]]
- [[03-语法分析理论]]

## 7. 导航

- [返回总目录](../README.md)
- [上一章：形式语言理论总论](00-形式语言理论总论.md)
- [下一章：自动机理论](02-自动机理论.md)
