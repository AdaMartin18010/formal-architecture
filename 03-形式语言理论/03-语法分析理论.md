# 语法分析理论

## 1. 概述

语法分析理论研究如何根据语法规则分析输入字符串的结构，包括上下文无关文法、LL分析和LR分析等方法。

## 2. 基本概念

### 2.1 上下文无关文法

- **CFG**：$G = (V, \Sigma, P, S)$ 其中 $V$ 是变元集，$\Sigma$ 是终结符集
- **产生式**：$A \rightarrow \alpha$ 其中 $A \in V, \alpha \in (V \cup \Sigma)^*$
- **推导**：从开始符号到终结符串的变换序列

### 2.2 LL分析

- **自顶向下分析**：从开始符号开始推导
- **预测分析**：根据下一个输入符号选择产生式
- **递归下降**：为每个非终结符编写递归函数

### 2.3 LR分析

- **自底向上分析**：从输入开始归约
- **移进-归约**：在移进和归约之间选择
- **LR(0)、SLR、LALR**：不同的LR分析方法

## 3. 形式化表示

### 3.1 文法定义

```latex
G = (V, \Sigma, P, S) \quad \text{(上下文无关文法)}
```

### 3.2 推导关系

```latex
\alpha A \beta \Rightarrow \alpha \gamma \beta \quad \text{当 } A \rightarrow \gamma \in P
```

### 3.3 语言定义

```latex
L(G) = \{w \in \Sigma^* | S \Rightarrow^* w\}
```

## 4. 软件架构应用

### 4.1 配置解析

- **配置文件语法**：系统配置的语法定义
- **DSL解析**：领域特定语言的解析
- **API解析**：接口定义的语法分析

### 4.2 协议解析

- **网络协议**：通信协议的语法分析
- **数据格式**：序列化格式的解析
- **查询语言**：数据库查询的语法分析

## 5. 代码示例

```rust
use std::collections::{HashMap, HashSet};

// 上下文无关文法
#[derive(Clone, Debug, Eq, PartialEq, Hash)]
struct NonTerminal(String);

#[derive(Clone, Debug, Eq, PartialEq, Hash)]
struct Terminal(String);

#[derive(Clone, Debug, Eq, PartialEq, Hash)]
enum Symbol {
    NonTerminal(NonTerminal),
    Terminal(Terminal),
}

#[derive(Clone, Debug)]
struct Production {
    left: NonTerminal,
    right: Vec<Symbol>,
}

struct ContextFreeGrammar {
    variables: HashSet<NonTerminal>,
    terminals: HashSet<Terminal>,
    productions: Vec<Production>,
    start_symbol: NonTerminal,
}

impl ContextFreeGrammar {
    fn new(start_symbol: NonTerminal) -> Self {
        ContextFreeGrammar {
            variables: HashSet::new(),
            terminals: HashSet::new(),
            productions: Vec::new(),
            start_symbol,
        }
    }
    
    fn add_variable(&mut self, variable: NonTerminal) {
        self.variables.insert(variable);
    }
    
    fn add_terminal(&mut self, terminal: Terminal) {
        self.terminals.insert(terminal);
    }
    
    fn add_production(&mut self, production: Production) {
        self.productions.push(production);
    }
    
    fn derive(&self, input: &str) -> bool {
        // 检查输入是否可以从开始符号推导出
        let tokens: Vec<Terminal> = input
            .split_whitespace()
            .map(|s| Terminal(s.to_string()))
            .collect();
        
        self.derive_from(self.start_symbol.clone(), &tokens)
    }
    
    fn derive_from(&self, symbol: NonTerminal, input: &[Terminal]) -> bool {
        // 递归推导（简化实现）
        for production in &self.productions {
            if production.left == symbol {
                if self.derive_sequence(&production.right, input) {
                    return true;
                }
            }
        }
        false
    }
    
    fn derive_sequence(&self, symbols: &[Symbol], input: &[Terminal]) -> bool {
        // 推导符号序列（简化实现）
        if symbols.is_empty() && input.is_empty() {
            return true;
        }
        
        if symbols.is_empty() || input.is_empty() {
            return false;
        }
        
        match &symbols[0] {
            Symbol::Terminal(term) => {
                if input[0] == *term {
                    self.derive_sequence(&symbols[1..], &input[1..])
                } else {
                    false
                }
            }
            Symbol::NonTerminal(non_term) => {
                self.derive_from(non_term.clone(), input)
            }
        }
    }
    
    fn is_ll1(&self) -> bool {
        // 检查是否为LL(1)文法（简化实现）
        true
    }
    
    fn is_lr0(&self) -> bool {
        // 检查是否为LR(0)文法（简化实现）
        true
    }
}

// LL分析器
struct LLParser {
    grammar: ContextFreeGrammar,
    parse_table: HashMap<(NonTerminal, Terminal), Vec<Symbol>>,
}

impl LLParser {
    fn new(grammar: ContextFreeGrammar) -> Self {
        LLParser {
            parse_table: HashMap::new(),
            grammar,
        }
    }
    
    fn build_parse_table(&mut self) {
        // 构建LL(1)分析表（简化实现）
        for production in &self.grammar.productions {
            // 计算FIRST集和FOLLOW集
            let first_set = self.first(&production.right);
            for terminal in first_set {
                self.parse_table.insert(
                    (production.left.clone(), terminal),
                    production.right.clone()
                );
            }
        }
    }
    
    fn first(&self, symbols: &[Symbol]) -> HashSet<Terminal> {
        // 计算FIRST集（简化实现）
        let mut first = HashSet::new();
        if let Some(Symbol::Terminal(term)) = symbols.first() {
            first.insert(term.clone());
        }
        first
    }
    
    fn parse(&self, input: &str) -> Option<ParseTree> {
        let tokens: Vec<Terminal> = input
            .split_whitespace()
            .map(|s| Terminal(s.to_string()))
            .collect();
        
        let mut stack = vec![Symbol::NonTerminal(self.grammar.start_symbol.clone())];
        let mut input_pos = 0;
        
        while !stack.is_empty() && input_pos < tokens.len() {
            let top = stack.pop().unwrap();
            
            match top {
                Symbol::Terminal(term) => {
                    if term == tokens[input_pos] {
                        input_pos += 1;
                    } else {
                        return None; // 语法错误
                    }
                }
                Symbol::NonTerminal(non_term) => {
                    if let Some(production) = self.parse_table.get(&(non_term, tokens[input_pos].clone())) {
                        // 将产生式右部逆序压栈
                        for symbol in production.iter().rev() {
                            stack.push(symbol.clone());
                        }
                    } else {
                        return None; // 语法错误
                    }
                }
            }
        }
        
        if stack.is_empty() && input_pos == tokens.len() {
            Some(ParseTree::new(self.grammar.start_symbol.clone()))
        } else {
            None
        }
    }
}

// LR分析器
struct LRParser {
    grammar: ContextFreeGrammar,
    action_table: HashMap<(usize, Terminal), Action>,
    goto_table: HashMap<(usize, NonTerminal), usize>,
}

#[derive(Clone, Debug)]
enum Action {
    Shift(usize),
    Reduce(usize),
    Accept,
    Error,
}

impl LRParser {
    fn new(grammar: ContextFreeGrammar) -> Self {
        LRParser {
            action_table: HashMap::new(),
            goto_table: HashMap::new(),
            grammar,
        }
    }
    
    fn build_tables(&mut self) {
        // 构建LR分析表（简化实现）
        // 这里需要实现LR(0)项集族构造
    }
    
    fn parse(&self, input: &str) -> Option<ParseTree> {
        let tokens: Vec<Terminal> = input
            .split_whitespace()
            .map(|s| Terminal(s.to_string()))
            .collect();
        
        let mut stack = vec![0]; // 状态栈
        let mut symbol_stack = Vec::new(); // 符号栈
        let mut input_pos = 0;
        
        loop {
            let current_state = *stack.last().unwrap();
            let current_token = if input_pos < tokens.len() {
                tokens[input_pos].clone()
            } else {
                Terminal("$".to_string()) // 结束标记
            };
            
            if let Some(action) = self.action_table.get(&(current_state, current_token.clone())) {
                match action {
                    Action::Shift(next_state) => {
                        stack.push(*next_state);
                        symbol_stack.push(Symbol::Terminal(current_token));
                        input_pos += 1;
                    }
                    Action::Reduce(production_index) => {
                        let production = &self.grammar.productions[*production_index];
                        // 弹出产生式右部长度的状态和符号
                        for _ in 0..production.right.len() {
                            stack.pop();
                            symbol_stack.pop();
                        }
                        
                        let current_state = *stack.last().unwrap();
                        if let Some(next_state) = self.goto_table.get(&(current_state, production.left.clone())) {
                            stack.push(*next_state);
                            symbol_stack.push(Symbol::NonTerminal(production.left.clone()));
                        } else {
                            return None;
                        }
                    }
                    Action::Accept => {
                        return Some(ParseTree::new(self.grammar.start_symbol.clone()));
                    }
                    Action::Error => {
                        return None;
                    }
                }
            } else {
                return None;
            }
        }
    }
}

// 语法树
#[derive(Clone, Debug)]
struct ParseTree {
    root: NonTerminal,
    children: Vec<ParseTree>,
    value: Option<String>,
}

impl ParseTree {
    fn new(root: NonTerminal) -> Self {
        ParseTree {
            root,
            children: Vec::new(),
            value: None,
        }
    }
    
    fn add_child(&mut self, child: ParseTree) {
        self.children.push(child);
    }
    
    fn set_value(&mut self, value: String) {
        self.value = Some(value);
    }
    
    fn print(&self, depth: usize) {
        let indent = "  ".repeat(depth);
        if let Some(value) = &self.value {
            println!("{}{} = {}", indent, self.root.0, value);
        } else {
            println!("{}{}", indent, self.root.0);
        }
        for child in &self.children {
            child.print(depth + 1);
        }
    }
}

// 递归下降分析器
struct RecursiveDescentParser {
    grammar: ContextFreeGrammar,
    input: Vec<Terminal>,
    position: usize,
}

impl RecursiveDescentParser {
    fn new(grammar: ContextFreeGrammar) -> Self {
        RecursiveDescentParser {
            grammar,
            input: Vec::new(),
            position: 0,
        }
    }
    
    fn parse(&mut self, input: &str) -> bool {
        self.input = input
            .split_whitespace()
            .map(|s| Terminal(s.to_string()))
            .collect();
        self.position = 0;
        
        self.parse_non_terminal(&self.grammar.start_symbol)
    }
    
    fn parse_non_terminal(&mut self, non_terminal: &NonTerminal) -> bool {
        // 为每个非终结符实现递归函数
        for production in &self.grammar.productions {
            if production.left == *non_terminal {
                let start_pos = self.position;
                if self.parse_sequence(&production.right) {
                    return true;
                }
                self.position = start_pos; // 回溯
            }
        }
        false
    }
    
    fn parse_sequence(&mut self, symbols: &[Symbol]) -> bool {
        for symbol in symbols {
            match symbol {
                Symbol::Terminal(term) => {
                    if self.position < self.input.len() && self.input[self.position] == *term {
                        self.position += 1;
                    } else {
                        return false;
                    }
                }
                Symbol::NonTerminal(non_term) => {
                    if !self.parse_non_terminal(non_term) {
                        return false;
                    }
                }
            }
        }
        true
    }
}

// 语法分析工具
struct ParserTools;

impl ParserTools {
    fn eliminate_left_recursion(grammar: &ContextFreeGrammar) -> ContextFreeGrammar {
        // 消除左递归（简化实现）
        grammar.clone()
    }
    
    fn left_factor(grammar: &ContextFreeGrammar) -> ContextFreeGrammar {
        // 左因子分解（简化实现）
        grammar.clone()
    }
    
    fn compute_first_set(grammar: &ContextFreeGrammar) -> HashMap<NonTerminal, HashSet<Terminal>> {
        // 计算FIRST集
        HashMap::new()
    }
    
    fn compute_follow_set(grammar: &ContextFreeGrammar) -> HashMap<NonTerminal, HashSet<Terminal>> {
        // 计算FOLLOW集
        HashMap::new()
    }
    
    fn is_ambiguous(grammar: &ContextFreeGrammar) -> bool {
        // 检查文法是否歧义（简化实现）
        false
    }
}
```

## 6. 交叉引用

- [[00-形式语言理论总论]]
- [[01-形式语言基础]]
- [[02-自动机理论]]

## 7. 导航

- [返回总目录](../README.md)
- [上一章：自动机理论](02-自动机理论.md)
- [下一章：语义分析理论](04-语义分析理论.md)
