# 可证伪性测试

[返回总论](./00-理论验证框架总论.md) | [返回增强总论](../00-理论增强与完善总论.md)

> **重要声明**：
>
> - **项目定位**：本项目为"知识梳理与理论构建项目（非编程项目）"，专注于形式化架构理论体系的整理、构建和统一。
> - **文档目标**：本文档提供可证伪性测试的详细方法，包括假设细化、反例设计、证伪条件定义。

## 目录

- [可证伪性测试](#可证伪性测试)
  - [1. 可证伪性概述](#1-可证伪性概述)
  - [2. 假设细化](#2-假设细化)
  - [3. 反例设计](#3-反例设计)
  - [4. 证伪条件与测试流程](#4-证伪条件与测试流程)
  - [2025 对齐](#2025-对齐)

## 1. 可证伪性概述

### 1.1 波普尔可证伪性原则

科学理论的核心特征之一是**可证伪性**（Falsifiability）：一个理论必须能够被潜在的反例所否定。若理论预测过于宽泛、无法设计反例，则难以进行科学验证。

### 1.2 本理论体系面临的问题

批判性评价指出：

- ⚠️ 理论预测过于宽泛，难以设计反例
- ⚠️ 如"语义驱动架构提升5x效率"缺乏明确边界
- ⚠️ 如"MSMFIT可描述所有业务系统"过于绝对

### 1.3 可证伪性测试目标

1. **假设细化**：将宽泛声称细化为可测试的假设
2. **反例设计**：设计能够证伪假设的反例
3. **证伪条件**：为每个假设定义明确的证伪条件

## 2. 假设细化

### 2.1 假设细化步骤

**步骤1：识别宽泛声称**

从理论文档中提取宽泛声称，例如：

- "语义驱动架构提升5x效率"
- "MSMFIT可以描述所有业务系统"
- "可逆计算保证模型和代码一致性"

**步骤2：细化为可测试假设**

将宽泛声称拆解为具有明确条件、预测值和统计要求的假设。

**步骤3：定义证伪条件**

为每个假设定义"若出现何种结果，则假设被证伪"。

### 2.2 示例1：效率提升假设

**宽泛声称**："语义驱动架构提升5x效率"

**细化假设**：

| 假设 | 描述 | 条件 | 预测值 | 证伪条件 |
|------|------|------|--------|----------|
| $H_1$ | 开发时间减少 | CRUD类业务系统，5-10人团队，3-6个月项目 | 减少≥50%（p<0.05，n≥10） | 实际减少<30% |
| $H_2$ | 代码生成率 | 复杂业务系统，SMDD实施 | 生成率≥80%（p<0.05，n≥10） | 实际生成率<60% |
| $H_3$ | 重复代码减少 | 使用SMDD的任意业务系统 | 减少≥60%（p<0.05，n≥10） | 实际减少<40% |

### 2.3 示例2：MSMFIT普适性假设

**宽泛声称**："MSMFIT可以描述所有业务系统"

**细化假设**：

| 假设 | 描述 | 条件 | 预测值 | 证伪条件 |
|------|------|------|--------|----------|
| $H_1$ | 常见业务系统覆盖 | 电商、金融、制造等 | 可描述≥90% | 可描述<70% |
| $H_2$ | 纯计算型系统 | 图像渲染、科学计算 | 不适用 | 若可完整描述则证伪 |
| $H_3$ | 实时控制型系统 | PLC工控、嵌入式 | 不适用 | 若可完整描述则证伪 |

### 2.4 示例3：可逆计算一致性假设

**宽泛声称**："可逆计算保证模型和代码一致性"

**细化假设**：

| 假设 | 描述 | 条件 | 预测值 | 证伪条件 |
|------|------|------|--------|----------|
| $H_1$ | 双向同步成功率 | 标准DSL↔Code转换 | ≥95% | 成功率<80% |
| $H_2$ | 语义损失率 | 关键业务系统 | <5% | 损失率>10% |
| $H_3$ | 提取成功率 | 从现有代码提取DSL | ≥90% | 成功率<70% |

## 3. 反例设计

### 3.1 反例设计原则

1. **边界反例**：设计接近假设边界的反例
2. **极端反例**：设计极端情况的反例
3. **典型反例**：设计典型失败场景的反例

### 3.2 反例1：不适合SMDD的系统

| 项目 | 内容 |
|------|------|
| **系统类型** | 实时控制系统 |
| **特征** | 毫秒级响应、物理世界接口、硬实时约束 |
| **预期结果** | SMDD不适用，MSMFIT建模失败或语义损失>20% |
| **验证方法** | 尝试用MSMFIT建模，验证是否失败或损失超限 |

### 3.3 反例2：效率提升不明显的场景

| 项目 | 内容 |
|------|------|
| **系统类型** | 简单CRUD系统 |
| **特征** | 业务逻辑简单、变更频率低、团队已熟悉传统方法 |
| **预期结果** | 效率提升<30%，SMDD overhead可能超过收益 |
| **验证方法** | 对比SMDD和传统方法的开发时间、维护成本 |

### 3.4 反例3：高不确定性规则系统

| 项目 | 内容 |
|------|------|
| **系统类型** | AI推荐、动态定价等 |
| **特征** | 规则不确定性>70%，变更频率>1次/天 |
| **预期结果** | DSL描述成本超过收益，可逆性得分<60% |
| **验证方法** | 测量DSL维护成本 vs 代码直接修改成本 |

## 4. 证伪条件与测试流程

### 4.1 证伪条件汇总表

| 假设 | 证伪条件 | 统计要求 |
|------|----------|----------|
| $H_1$：开发时间减少50% | 实际减少<30% | n≥10, p<0.05 |
| $H_2$：代码生成率80% | 实际生成率<60% | n≥10, p<0.05 |
| $H_3$：重复代码减少60% | 实际减少<40% | n≥10, p<0.05 |
| $H_4$：MSMFIT覆盖90%业务系统 | 可描述<70% | 样本覆盖主要行业 |
| $H_5$：可逆性得分95% | 成功率<80% | n≥20次构建 |

### 4.2 证伪测试流程

1. **准备阶段**
   - 选择测试场景（对照实验或案例研究）
   - 准备测试数据（历史数据或新实验）
   - 设计测试方案（样本量、控制变量）

2. **执行阶段**
   - 执行测试
   - 收集数据
   - 记录结果

3. **分析阶段**
   - 统计分析（均值、标准差、置信区间）
   - 对比假设与证伪条件
   - 判断是否证伪

4. **报告阶段**
   - 编写测试报告
   - 记录证伪结果
   - 若证伪，触发[理论修正机制](./03-理论修正机制.md)

### 4.3 与实施指南的关联

详细实施步骤见 [00-验证实施指南](./00-验证实施指南.md) 第1节。

## 2025 对齐

- **国际 Wiki**：[Wikipedia: Falsifiability](https://en.wikipedia.org/wiki/Falsifiability)
- **代表性论文**：[Falsifiability in Software Architecture Theories](https://ieeexplore.ieee.org/document/10345681) (2024)
- **前沿技术**：[TLA+](https://lamport.azurewebsites.net/tla/tla.html)（形式化规范与模型检查）

---

**文档版本**：v1.0
**最后更新**：2025-02-03
**维护状态**：✅ 持续更新中
