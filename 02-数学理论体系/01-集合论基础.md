# 集合论基础

## 1. 概述

集合论是数学的基础语言，为形式化架构理论提供基本的数学工具和概念框架。

## 2. 基本概念

### 2.1 集合的基本运算

- **并集**：$A \cup B = \{x | x \in A \lor x \in B\}$
- **交集**：$A \cap B = \{x | x \in A \land x \in B\}$
- **差集**：$A \setminus B = \{x | x \in A \land x \notin B\}$
- **补集**：$A^c = \{x | x \notin A\}$

### 2.2 集合关系

- **包含关系**：$A \subseteq B \leftrightarrow \forall x (x \in A \rightarrow x \in B)$
- **相等关系**：$A = B \leftrightarrow A \subseteq B \land B \subseteq A$
- **真包含关系**：$A \subset B \leftrightarrow A \subseteq B \land A \neq B$

### 2.3 笛卡尔积

- **二元积**：$A \times B = \{(a,b) | a \in A \land b \in B\}$
- **n元积**：$A_1 \times A_2 \times \cdots \times A_n = \{(a_1,a_2,\ldots,a_n) | a_i \in A_i\}$

## 3. 形式化表示

### 3.1 集合论公理

```latex
\text{外延公理: } \forall x (x \in A \leftrightarrow x \in B) \rightarrow A = B
```

```latex
\text{空集公理: } \exists A \forall x (x \notin A)
```

```latex
\text{并集公理: } \forall F \exists A \forall x (x \in A \leftrightarrow \exists B (B \in F \land x \in B))
```

### 3.2 幂集

```latex
\mathcal{P}(A) = \{B | B \subseteq A\}
```

### 3.3 关系与函数

```latex
R \subseteq A \times B \quad \text{(关系定义)}
```

```latex
f: A \rightarrow B \leftrightarrow \forall x \in A \exists! y \in B ((x,y) \in f)
```

## 4. 软件架构应用

### 4.1 组件集合

- **组件集**：$C = \{c_1, c_2, \ldots, c_n\}$
- **接口集**：$I = \{i_1, i_2, \ldots, i_m\}$
- **连接集**：$L = \{l_1, l_2, \ldots, l_k\}$

### 4.2 架构关系

- **依赖关系**：$D \subseteq C \times C$
- **组合关系**：$P \subseteq C \times C$
- **接口关系**：$R \subseteq C \times I$

## 5. 代码示例

```rust
use std::collections::{HashMap, HashSet};

// 集合论基本操作
struct Set<T> {
    elements: HashSet<T>,
}

impl<T: Eq + std::hash::Hash + Clone> Set<T> {
    fn new() -> Self {
        Set {
            elements: HashSet::new(),
        }
    }
    
    fn insert(&mut self, element: T) {
        self.elements.insert(element);
    }
    
    fn contains(&self, element: &T) -> bool {
        self.elements.contains(element)
    }
    
    fn union(&self, other: &Set<T>) -> Set<T> {
        let mut result = Set::new();
        for element in &self.elements {
            result.insert(element.clone());
        }
        for element in &other.elements {
            result.insert(element.clone());
        }
        result
    }
    
    fn intersection(&self, other: &Set<T>) -> Set<T> {
        let mut result = Set::new();
        for element in &self.elements {
            if other.contains(element) {
                result.insert(element.clone());
            }
        }
        result
    }
    
    fn difference(&self, other: &Set<T>) -> Set<T> {
        let mut result = Set::new();
        for element in &self.elements {
            if !other.contains(element) {
                result.insert(element.clone());
            }
        }
        result
    }
    
    fn is_subset(&self, other: &Set<T>) -> bool {
        self.elements.is_subset(&other.elements)
    }
    
    fn is_equal(&self, other: &Set<T>) -> bool {
        self.elements == other.elements
    }
}

// 关系表示
struct Relation<A, B> {
    pairs: HashSet<(A, B)>,
}

impl<A: Eq + std::hash::Hash + Clone, B: Eq + std::hash::Hash + Clone> Relation<A, B> {
    fn new() -> Self {
        Relation {
            pairs: HashSet::new(),
        }
    }
    
    fn add_pair(&mut self, a: A, b: B) {
        self.pairs.insert((a, b));
    }
    
    fn domain(&self) -> Set<A> {
        let mut domain = Set::new();
        for (a, _) in &self.pairs {
            domain.insert(a.clone());
        }
        domain
    }
    
    fn range(&self) -> Set<B> {
        let mut range = Set::new();
        for (_, b) in &self.pairs {
            range.insert(b.clone());
        }
        range
    }
}

// 函数表示
struct Function<A, B> {
    mapping: HashMap<A, B>,
}

impl<A: Eq + std::hash::Hash + Clone, B: Clone> Function<A, B> {
    fn new() -> Self {
        Function {
            mapping: HashMap::new(),
        }
    }
    
    fn apply(&self, input: &A) -> Option<&B> {
        self.mapping.get(input)
    }
    
    fn define(&mut self, input: A, output: B) {
        self.mapping.insert(input, output);
    }
}
```

## 6. 交叉引用

- [[00-数学理论体系总论]]
- [[02-代数理论]]
- [[03-几何理论]]

## 7. 导航

- [返回总目录](../README.md)
- [上一章：数学理论体系总论](00-数学理论体系总论.md)
- [下一章：代数理论](02-代数理论.md)
