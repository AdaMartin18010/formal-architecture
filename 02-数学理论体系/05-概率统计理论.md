# 概率统计理论

## 1. 概述

概率统计理论研究随机性和数据分析，为软件架构提供概率建模、统计推断和随机过程分析工具。

## 2. 基本概念

### 2.1 概率论

- **概率空间**：$(\Omega, \mathcal{F}, P)$ 其中 $\Omega$ 是样本空间，$\mathcal{F}$ 是事件域，$P$ 是概率测度
- **随机变量**：$X: \Omega \rightarrow \mathbb{R}$ 是可测函数
- **期望**：$E[X] = \int_\Omega X(\omega) dP(\omega)$

### 2.2 统计学

- **样本**：从总体中抽取的观测值
- **统计量**：样本的函数
- **估计**：用样本推断总体参数

### 2.3 随机过程

- **马尔可夫链**：$P(X_{n+1} = j | X_n = i, X_{n-1} = k, \ldots) = P(X_{n+1} = j | X_n = i)$
- **泊松过程**：计数过程，满足独立增量和平稳增量
- **布朗运动**：连续时间的随机游走

## 3. 形式化表示

### 3.1 概率公理

```latex
P(\Omega) = 1 \quad \text{(归一化)}
```

```latex
P(A \cup B) = P(A) + P(B) - P(A \cap B) \quad \text{(加法公式)}
```

```latex
P(A|B) = \frac{P(A \cap B)}{P(B)} \quad \text{(条件概率)}
```

### 3.2 随机变量

```latex
F_X(x) = P(X \leq x) \quad \text{(分布函数)}
```

```latex
f_X(x) = \frac{d}{dx} F_X(x) \quad \text{(密度函数)}
```

### 3.3 期望和方差

```latex
E[X] = \int_{-\infty}^{\infty} x f_X(x) dx
```

```latex
\text{Var}(X) = E[(X - E[X])^2] = E[X^2] - (E[X])^2
```

## 4. 软件架构应用

### 4.1 性能建模

- **响应时间分布**：系统响应时间的概率分布
- **负载建模**：用户请求的随机过程
- **可靠性分析**：系统故障的概率模型

### 4.2 容量规划

- **队列理论**：服务队列的随机过程
- **资源分配**：基于统计的资源优化
- **预测模型**：基于历史数据的预测

## 5. 代码示例

```rust
use std::collections::HashMap;
use rand::Rng;

// 概率空间
struct ProbabilitySpace {
    sample_space: Vec<String>,
    probabilities: HashMap<String, f64>,
}

impl ProbabilitySpace {
    fn new() -> Self {
        ProbabilitySpace {
            sample_space: Vec::new(),
            probabilities: HashMap::new(),
        }
    }
    
    fn add_event(&mut self, event: String, probability: f64) {
        self.sample_space.push(event.clone());
        self.probabilities.insert(event, probability);
    }
    
    fn probability(&self, event: &str) -> f64 {
        *self.probabilities.get(event).unwrap_or(&0.0)
    }
    
    fn sample(&self) -> Option<&String> {
        let mut rng = rand::thread_rng();
        let random_value: f64 = rng.gen();
        let mut cumulative_prob = 0.0;
        
        for event in &self.sample_space {
            cumulative_prob += self.probability(event);
            if random_value <= cumulative_prob {
                return Some(event);
            }
        }
        
        None
    }
}

// 随机变量
trait RandomVariable {
    type Value;
    
    fn sample(&self) -> Self::Value;
    fn expectation(&self) -> f64;
    fn variance(&self) -> f64;
}

struct DiscreteRandomVariable {
    values: Vec<f64>,
    probabilities: Vec<f64>,
}

impl RandomVariable for DiscreteRandomVariable {
    type Value = f64;
    
    fn sample(&self) -> Self::Value {
        let mut rng = rand::thread_rng();
        let random_value: f64 = rng.gen();
        let mut cumulative_prob = 0.0;
        
        for (value, prob) in self.values.iter().zip(self.probabilities.iter()) {
            cumulative_prob += prob;
            if random_value <= cumulative_prob {
                return *value;
            }
        }
        
        self.values.last().unwrap_or(&0.0)
    }
    
    fn expectation(&self) -> f64 {
        self.values.iter()
            .zip(self.probabilities.iter())
            .map(|(value, prob)| value * prob)
            .sum()
    }
    
    fn variance(&self) -> f64 {
        let mean = self.expectation();
        self.values.iter()
            .zip(self.probabilities.iter())
            .map(|(value, prob)| prob * (value - mean).powi(2))
            .sum()
    }
}

// 连续随机变量
struct ContinuousRandomVariable {
    pdf: Box<dyn Fn(f64) -> f64>,
    cdf: Box<dyn Fn(f64) -> f64>,
}

impl RandomVariable for ContinuousRandomVariable {
    type Value = f64;
    
    fn sample(&self) -> Self::Value {
        // 使用逆变换采样
        let mut rng = rand::thread_rng();
        let u: f64 = rng.gen();
        self.inverse_cdf(u)
    }
    
    fn expectation(&self) -> f64 {
        // 数值积分计算期望
        let mut sum = 0.0;
        let dx = 0.01;
        let mut x = -10.0;
        
        while x <= 10.0 {
            sum += x * (self.pdf)(x) * dx;
            x += dx;
        }
        
        sum
    }
    
    fn variance(&self) -> f64 {
        let mean = self.expectation();
        let mut sum = 0.0;
        let dx = 0.01;
        let mut x = -10.0;
        
        while x <= 10.0 {
            sum += (x - mean).powi(2) * (self.pdf)(x) * dx;
            x += dx;
        }
        
        sum
    }
}

impl ContinuousRandomVariable {
    fn inverse_cdf(&self, u: f64) -> f64 {
        // 简单的二分查找实现
        let mut left = -10.0;
        let mut right = 10.0;
        let tolerance = 1e-6;
        
        while right - left > tolerance {
            let mid = (left + right) / 2.0;
            let cdf_value = (self.cdf)(mid);
            
            if cdf_value < u {
                left = mid;
            } else {
                right = mid;
            }
        }
        
        (left + right) / 2.0
    }
}

// 马尔可夫链
struct MarkovChain {
    states: Vec<String>,
    transition_matrix: Vec<Vec<f64>>,
    current_state: usize,
}

impl MarkovChain {
    fn new(states: Vec<String>, transition_matrix: Vec<Vec<f64>>) -> Self {
        MarkovChain {
            states,
            transition_matrix,
            current_state: 0,
        }
    }
    
    fn next_state(&mut self) -> &String {
        let mut rng = rand::thread_rng();
        let random_value: f64 = rng.gen();
        let mut cumulative_prob = 0.0;
        
        for (next_state, &prob) in self.transition_matrix[self.current_state].iter().enumerate() {
            cumulative_prob += prob;
            if random_value <= cumulative_prob {
                self.current_state = next_state;
                break;
            }
        }
        
        &self.states[self.current_state]
    }
    
    fn stationary_distribution(&self) -> Vec<f64> {
        // 计算平稳分布（简化实现）
        let n = self.states.len();
        let mut pi = vec![1.0 / n as f64; n];
        
        // 迭代计算
        for _ in 0..100 {
            let mut new_pi = vec![0.0; n];
            for i in 0..n {
                for j in 0..n {
                    new_pi[j] += pi[i] * self.transition_matrix[i][j];
                }
            }
            pi = new_pi;
        }
        
        pi
    }
}

// 统计推断
struct StatisticalInference;

impl StatisticalInference {
    fn mean(sample: &[f64]) -> f64 {
        sample.iter().sum::<f64>() / sample.len() as f64
    }
    
    fn variance(sample: &[f64]) -> f64 {
        let mean = Self::mean(sample);
        sample.iter()
            .map(|x| (x - mean).powi(2))
            .sum::<f64>() / (sample.len() - 1) as f64
    }
    
    fn confidence_interval(sample: &[f64], confidence_level: f64) -> (f64, f64) {
        let mean = Self::mean(sample);
        let std_error = (Self::variance(sample) / sample.len() as f64).sqrt();
        let z_score = 1.96; // 95% 置信区间
        
        (mean - z_score * std_error, mean + z_score * std_error)
    }
    
    fn hypothesis_test(sample: &[f64], null_hypothesis: f64, significance_level: f64) -> bool {
        let mean = Self::mean(sample);
        let std_error = (Self::variance(sample) / sample.len() as f64).sqrt();
        let t_statistic = (mean - null_hypothesis) / std_error;
        
        // 简单的双尾检验
        t_statistic.abs() > 1.96
    }
}

// 性能建模
struct PerformanceModel {
    response_time_dist: ContinuousRandomVariable,
    arrival_process: Box<dyn Fn(f64) -> usize>,
}

impl PerformanceModel {
    fn new(response_time_dist: ContinuousRandomVariable, arrival_process: Box<dyn Fn(f64) -> usize>) -> Self {
        PerformanceModel {
            response_time_dist,
            arrival_process,
        }
    }
    
    fn simulate(&self, duration: f64) -> PerformanceMetrics {
        let mut total_response_time = 0.0;
        let mut request_count = 0;
        let mut current_time = 0.0;
        
        while current_time < duration {
            let arrivals = (self.arrival_process)(current_time);
            for _ in 0..arrivals {
                let response_time = self.response_time_dist.sample();
                total_response_time += response_time;
                request_count += 1;
            }
            current_time += 0.1;
        }
        
        PerformanceMetrics {
            average_response_time: total_response_time / request_count as f64,
            throughput: request_count as f64 / duration,
            total_requests: request_count,
        }
    }
}

struct PerformanceMetrics {
    average_response_time: f64,
    throughput: f64,
    total_requests: usize,
}

// 队列理论
struct QueueSystem {
    arrival_rate: f64,
    service_rate: f64,
    queue_capacity: Option<usize>,
}

impl QueueSystem {
    fn new(arrival_rate: f64, service_rate: f64, queue_capacity: Option<usize>) -> Self {
        QueueSystem {
            arrival_rate,
            service_rate,
            queue_capacity,
        }
    }
    
    fn utilization(&self) -> f64 {
        self.arrival_rate / self.service_rate
    }
    
    fn average_queue_length(&self) -> f64 {
        let rho = self.utilization();
        if rho < 1.0 {
            rho.powi(2) / (1.0 - rho)
        } else {
            f64::INFINITY
        }
    }
    
    fn average_waiting_time(&self) -> f64 {
        let rho = self.utilization();
        if rho < 1.0 {
            rho / (self.service_rate * (1.0 - rho))
        } else {
            f64::INFINITY
        }
    }
}
```

## 6. 交叉引用

- [[00-数学理论体系总论]]
- [[01-集合论基础]]
- [[02-代数理论]]
- [[03-几何理论]]
- [[04-分析理论]]

## 7. 导航

- [返回总目录](../README.md)
- [上一章：分析理论](04-分析理论.md)
- [返回数学理论体系目录](../README.md#数学理论体系)
