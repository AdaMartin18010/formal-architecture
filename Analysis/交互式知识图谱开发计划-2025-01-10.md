# äº¤äº’å¼çŸ¥è¯†å›¾è°±ç†è®ºè®¾è®¡è¯´æ˜

**è®¾è®¡æ—¶é—´**: 2025-01-10
**è®¾è®¡èŒƒå›´**: äº¤äº’å¼çŸ¥è¯†å›¾è°±æœºåˆ¶çš„ç†è®ºè®¾è®¡è¯´æ˜
**è®¾è®¡çŠ¶æ€**: âœ… ç†è®ºè®¾è®¡å®Œæˆ

> **é‡è¦å£°æ˜**ï¼š
> - **é¡¹ç›®å®šä½**ï¼šæœ¬é¡¹ç›®ä¸º"çŸ¥è¯†æ¢³ç†ä¸ç†è®ºæ„å»ºé¡¹ç›®ï¼ˆéç¼–ç¨‹é¡¹ç›®ï¼‰"ï¼Œä¸“æ³¨äºå½¢å¼åŒ–æ¶æ„ç†è®ºä½“ç³»çš„æ•´ç†ã€æ„å»ºå’Œç»Ÿä¸€ã€‚
> - **è®¾è®¡ç›®æ ‡**ï¼šæœ¬æ–‡æ¡£æä¾›äº¤äº’å¼çŸ¥è¯†å›¾è°±æœºåˆ¶çš„ç†è®ºè®¾è®¡è¯´æ˜ï¼Œé˜è¿°å¦‚ä½•å°†çŸ¥è¯†å›¾è°±ç†è®ºè½¬åŒ–ä¸ºäº¤äº’å¼å¯è§†åŒ–æœºåˆ¶ã€‚
> - **å®æ–½æ–¹å¼**ï¼šé€šè¿‡æ–‡æ¡£å’Œç†è®ºè¯´æ˜ï¼Œè€Œéä»£ç å®ç°ï¼Œå®Œæˆäº¤äº’å¼çŸ¥è¯†å›¾è°±æœºåˆ¶çš„è®¾è®¡å’Œè¯´æ˜ã€‚

## ğŸ“‹ è®¾è®¡æ¦‚è¿°

åŸºäºçŸ¥è¯†æ¢³ç†é¡¹ç›®çš„éœ€æ±‚ï¼Œè®¾è®¡äº¤äº’å¼çŸ¥è¯†å›¾è°±æœºåˆ¶çš„ç†è®ºæ¡†æ¶ï¼Œæä¾›ç›´è§‚ã€äº¤äº’ã€æ™ºèƒ½çš„çŸ¥è¯†å›¾è°±æ¢ç´¢å’Œæ“ä½œæœºåˆ¶çš„ç†è®ºè¯´æ˜ã€‚

## ğŸ¯ æ ¸å¿ƒåŠŸèƒ½

### 1. äº¤äº’å¼å¯è§†åŒ–å¼•æ“

#### 1.1 åŠ¨æ€å›¾å½¢æ¸²æŸ“

```javascript
class InteractiveGraphRenderer {
    constructor(container, options = {}) {
        this.container = container;
        this.options = {
            width: options.width || 800,
            height: options.height || 600,
            nodeSize: options.nodeSize || 10,
            linkDistance: options.linkDistance || 100,
            ...options
        };

        this.svg = null;
        this.simulation = null;
        this.nodes = [];
        this.links = [];
        this.interactions = new InteractionManager(this);

        this.init();
    }

    init() {
        // åˆ›å»ºSVGå®¹å™¨
        this.svg = d3.select(this.container)
            .append('svg')
            .attr('width', this.options.width)
            .attr('height', this.options.height)
            .style('background-color', '#f8f9fa');

        // åˆ›å»ºç¼©æ”¾è¡Œä¸º
        this.zoom = d3.zoom()
            .scaleExtent([0.1, 10])
            .on('zoom', (event) => this.handleZoom(event));

        this.svg.call(this.zoom);

        // åˆ›å»ºä¸»å›¾å½¢ç»„
        this.g = this.svg.append('g');

        // åˆ›å»ºç®­å¤´æ ‡è®°
        this.createArrowMarkers();

        // åˆå§‹åŒ–åŠ›å¯¼å‘ä»¿çœŸ
        this.initSimulation();
    }

    initSimulation() {
        this.simulation = d3.forceSimulation(this.nodes)
            .force('link', d3.forceLink(this.links).id(d => d.id).distance(this.options.linkDistance))
            .force('charge', d3.forceManyBody().strength(-300))
            .force('center', d3.forceCenter(this.options.width / 2, this.options.height / 2))
            .force('collision', d3.forceCollide().radius(d => d.size || this.options.nodeSize + 5))
            .on('tick', () => this.updatePositions());
    }

    render(data) {
        this.nodes = data.nodes || [];
        this.links = data.links || [];

        // æ¸²æŸ“èŠ‚ç‚¹
        this.renderNodes();

        // æ¸²æŸ“é“¾æ¥
        this.renderLinks();

        // æ›´æ–°ä»¿çœŸ
        this.simulation.nodes(this.nodes);
        this.simulation.force('link').links(this.links);
        this.simulation.alpha(1).restart();

        // æ·»åŠ äº¤äº’
        this.addInteractions();
    }

    renderNodes() {
        this.nodeGroup = this.g.selectAll('.node')
            .data(this.nodes, d => d.id)
            .join('g')
            .attr('class', 'node')
            .attr('transform', d => `translate(${d.x},${d.y})`);

        // èŠ‚ç‚¹åœ†åœˆ
        this.nodeGroup.append('circle')
            .attr('r', d => d.size || this.options.nodeSize)
            .attr('fill', d => this.getNodeColor(d))
            .attr('stroke', d => this.getNodeStroke(d))
            .attr('stroke-width', 2);

        // èŠ‚ç‚¹æ ‡ç­¾
        this.nodeGroup.append('text')
            .attr('text-anchor', 'middle')
            .attr('dy', '.35em')
            .attr('font-size', '12px')
            .attr('font-family', 'Arial, sans-serif')
            .text(d => d.label || d.id)
            .style('pointer-events', 'none');

        // èŠ‚ç‚¹å›¾æ ‡
        this.nodeGroup.append('text')
            .attr('text-anchor', 'middle')
            .attr('dy', '-1.5em')
            .attr('font-size', '16px')
            .attr('font-family', 'FontAwesome')
            .text(d => this.getNodeIcon(d))
            .style('pointer-events', 'none');
    }

    renderLinks() {
        this.linkGroup = this.g.selectAll('.link')
            .data(this.links, d => `${d.source.id}-${d.target.id}`)
            .join('line')
            .attr('class', 'link')
            .attr('stroke', d => this.getLinkColor(d))
            .attr('stroke-width', d => this.getLinkWidth(d))
            .attr('stroke-opacity', 0.6)
            .attr('marker-end', d => this.getLinkMarker(d));

        // é“¾æ¥æ ‡ç­¾
        this.linkLabelGroup = this.g.selectAll('.link-label')
            .data(this.links, d => `${d.source.id}-${d.target.id}`)
            .join('text')
            .attr('class', 'link-label')
            .attr('text-anchor', 'middle')
            .attr('font-size', '10px')
            .attr('font-family', 'Arial, sans-serif')
            .text(d => d.label || d.type)
            .style('pointer-events', 'none');
    }

    updatePositions() {
        // æ›´æ–°èŠ‚ç‚¹ä½ç½®
        this.nodeGroup.attr('transform', d => `translate(${d.x},${d.y})`);

        // æ›´æ–°é“¾æ¥ä½ç½®
        this.linkGroup
            .attr('x1', d => d.source.x)
            .attr('y1', d => d.source.y)
            .attr('x2', d => d.target.x)
            .attr('y2', d => d.target.y);

        // æ›´æ–°é“¾æ¥æ ‡ç­¾ä½ç½®
        this.linkLabelGroup
            .attr('x', d => (d.source.x + d.target.x) / 2)
            .attr('y', d => (d.source.y + d.target.y) / 2);
    }

    addInteractions() {
        // èŠ‚ç‚¹æ‹–æ‹½
        this.nodeGroup.call(d3.drag()
            .on('start', (event, d) => this.handleDragStart(event, d))
            .on('drag', (event, d) => this.handleDrag(event, d))
            .on('end', (event, d) => this.handleDragEnd(event, d)));

        // èŠ‚ç‚¹ç‚¹å‡»
        this.nodeGroup.on('click', (event, d) => this.handleNodeClick(event, d));

        // èŠ‚ç‚¹æ‚¬åœ
        this.nodeGroup
            .on('mouseover', (event, d) => this.handleNodeHover(event, d))
            .on('mouseout', (event, d) => this.handleNodeUnhover(event, d));

        // é“¾æ¥ç‚¹å‡»
        this.linkGroup.on('click', (event, d) => this.handleLinkClick(event, d));
    }
}
```

#### 1.2 äº¤äº’ç®¡ç†å™¨

```javascript
class InteractionManager {
    constructor(renderer) {
        this.renderer = renderer;
        this.selectedNodes = new Set();
        this.hoveredNode = null;
        this.tooltip = this.createTooltip();
        this.contextMenu = this.createContextMenu();
    }

    handleNodeClick(event, node) {
        event.stopPropagation();

        if (event.ctrlKey || event.metaKey) {
            // å¤šé€‰æ¨¡å¼
            this.toggleNodeSelection(node);
        } else {
            // å•é€‰æ¨¡å¼
            this.selectNode(node);
        }

        this.updateNodeStyles();
        this.emit('nodeClick', { node, event });
    }

    handleNodeHover(event, node) {
        this.hoveredNode = node;
        this.highlightNode(node);
        this.showTooltip(event, node);
        this.emit('nodeHover', { node, event });
    }

    handleNodeUnhover(event, node) {
        this.hoveredNode = null;
        this.unhighlightNode(node);
        this.hideTooltip();
        this.emit('nodeUnhover', { node, event });
    }

    handleLinkClick(event, link) {
        event.stopPropagation();
        this.selectLink(link);
        this.updateLinkStyles();
        this.emit('linkClick', { link, event });
    }

    handleDragStart(event, node) {
        if (!event.active) this.renderer.simulation.alphaTarget(0.3).restart();
        node.fx = node.x;
        node.fy = node.y;
    }

    handleDrag(event, node) {
        node.fx = event.x;
        node.fy = event.y;
    }

    handleDragEnd(event, node) {
        if (!event.active) this.renderer.simulation.alphaTarget(0);
        node.fx = null;
        node.fy = null;
    }

    handleZoom(event) {
        this.renderer.g.attr('transform', event.transform);
    }

    selectNode(node) {
        this.selectedNodes.clear();
        this.selectedNodes.add(node);
    }

    toggleNodeSelection(node) {
        if (this.selectedNodes.has(node)) {
            this.selectedNodes.delete(node);
        } else {
            this.selectedNodes.add(node);
        }
    }

    highlightNode(node) {
        // é«˜äº®å½“å‰èŠ‚ç‚¹
        this.renderer.nodeGroup
            .filter(d => d.id === node.id)
            .select('circle')
            .attr('stroke', '#ff6b6b')
            .attr('stroke-width', 4);

        // é«˜äº®ç›¸é‚»èŠ‚ç‚¹å’Œé“¾æ¥
        this.highlightNeighbors(node);
    }

    highlightNeighbors(node) {
        const neighborIds = new Set();

        // æ‰¾åˆ°ç›¸é‚»èŠ‚ç‚¹
        this.renderer.links.forEach(link => {
            if (link.source.id === node.id) {
                neighborIds.add(link.target.id);
            } else if (link.target.id === node.id) {
                neighborIds.add(link.source.id);
            }
        });

        // é«˜äº®ç›¸é‚»èŠ‚ç‚¹
        this.renderer.nodeGroup
            .filter(d => neighborIds.has(d.id))
            .select('circle')
            .attr('stroke', '#4ecdc4')
            .attr('stroke-width', 3);

        // é«˜äº®ç›¸å…³é“¾æ¥
        this.renderer.linkGroup
            .filter(d => d.source.id === node.id || d.target.id === node.id)
            .attr('stroke', '#4ecdc4')
            .attr('stroke-width', 3);
    }

    unhighlightNode(node) {
        // æ¢å¤æ‰€æœ‰èŠ‚ç‚¹æ ·å¼
        this.renderer.nodeGroup
            .select('circle')
            .attr('stroke', d => this.renderer.getNodeStroke(d))
            .attr('stroke-width', 2);

        // æ¢å¤æ‰€æœ‰é“¾æ¥æ ·å¼
        this.renderer.linkGroup
            .attr('stroke', d => this.renderer.getLinkColor(d))
            .attr('stroke-width', d => this.renderer.getLinkWidth(d));
    }

    createTooltip() {
        return d3.select('body')
            .append('div')
            .attr('class', 'graph-tooltip')
            .style('position', 'absolute')
            .style('padding', '10px')
            .style('background', 'rgba(0, 0, 0, 0.8)')
            .style('color', 'white')
            .style('border-radius', '5px')
            .style('font-size', '12px')
            .style('pointer-events', 'none')
            .style('opacity', 0);
    }

    showTooltip(event, node) {
        const content = this.generateTooltipContent(node);
        this.tooltip
            .html(content)
            .style('left', (event.pageX + 10) + 'px')
            .style('top', (event.pageY - 10) + 'px')
            .style('opacity', 1);
    }

    hideTooltip() {
        this.tooltip.style('opacity', 0);
    }

    generateTooltipContent(node) {
        return `
            <div>
                <strong>${node.label || node.id}</strong>
                <br>
                <span>ç±»å‹: ${node.type || 'æœªçŸ¥'}</span>
                <br>
                <span>æè¿°: ${node.description || 'æ— æè¿°'}</span>
                <br>
                <span>è¿æ¥æ•°: ${this.getNodeDegree(node)}</span>
            </div>
        `;
    }
}
```

### 2. æ™ºèƒ½æ¢ç´¢åŠŸèƒ½

#### 2.1 è‡ªåŠ¨æ¢ç´¢å¼•æ“

```javascript
class AutoExplorationEngine {
    constructor(knowledgeGraph, renderer) {
        this.kg = knowledgeGraph;
        this.renderer = renderer;
        this.explorationState = {
            currentFocus: null,
            exploredNodes: new Set(),
            explorationPath: [],
            explorationMode: 'breadth_first'
        };
        this.explorationStrategies = {
            breadth_first: this.breadthFirstExploration.bind(this),
            depth_first: this.depthFirstExploration.bind(this),
            random_walk: this.randomWalkExploration.bind(this),
            guided: this.guidedExploration.bind(this)
        };
    }

    startExploration(startNode, options = {}) {
        this.explorationState.currentFocus = startNode;
        this.explorationState.explorationMode = options.mode || 'breadth_first';
        this.explorationState.maxDepth = options.maxDepth || 3;
        this.explorationState.maxNodes = options.maxNodes || 50;

        // å¼€å§‹æ¢ç´¢
        this.explore();
    }

    explore() {
        const strategy = this.explorationStrategies[this.explorationState.explorationMode];
        const nodesToExplore = strategy();

        // æ¸²æŸ“æ–°å‘ç°çš„èŠ‚ç‚¹
        this.renderNewNodes(nodesToExplore);

        // æ›´æ–°æ¢ç´¢çŠ¶æ€
        this.updateExplorationState(nodesToExplore);

        // è§¦å‘æ¢ç´¢äº‹ä»¶
        this.emit('explorationUpdate', {
            newNodes: nodesToExplore,
            explorationState: this.explorationState
        });
    }

    breadthFirstExploration() {
        const currentFocus = this.explorationState.currentFocus;
        const maxDepth = this.explorationState.maxDepth;
        const exploredNodes = this.explorationState.exploredNodes;

        const newNodes = [];
        const queue = [{ node: currentFocus, depth: 0 }];
        const visited = new Set();

        while (queue.length > 0 && newNodes.length < this.explorationState.maxNodes) {
            const { node, depth } = queue.shift();

            if (visited.has(node.id) || depth > maxDepth) {
                continue;
            }

            visited.add(node.id);

            if (!exploredNodes.has(node.id)) {
                newNodes.push(node);
                exploredNodes.add(node.id);
            }

            // æ·»åŠ ç›¸é‚»èŠ‚ç‚¹åˆ°é˜Ÿåˆ—
            const neighbors = this.kg.getNeighbors(node.id);
            neighbors.forEach(neighbor => {
                if (!visited.has(neighbor.id)) {
                    queue.push({ node: neighbor, depth: depth + 1 });
                }
            });
        }

        return newNodes;
    }

    depthFirstExploration() {
        const currentFocus = this.explorationState.currentFocus;
        const maxDepth = this.explorationState.maxDepth;
        const exploredNodes = this.explorationState.exploredNodes;

        const newNodes = [];
        const stack = [{ node: currentFocus, depth: 0 }];
        const visited = new Set();

        while (stack.length > 0 && newNodes.length < this.explorationState.maxNodes) {
            const { node, depth } = stack.pop();

            if (visited.has(node.id) || depth > maxDepth) {
                continue;
            }

            visited.add(node.id);

            if (!exploredNodes.has(node.id)) {
                newNodes.push(node);
                exploredNodes.add(node.id);
            }

            // æ·»åŠ ç›¸é‚»èŠ‚ç‚¹åˆ°æ ˆ
            const neighbors = this.kg.getNeighbors(node.id);
            neighbors.forEach(neighbor => {
                if (!visited.has(neighbor.id)) {
                    stack.push({ node: neighbor, depth: depth + 1 });
                }
            });
        }

        return newNodes;
    }

    randomWalkExploration() {
        const currentFocus = this.explorationState.currentFocus;
        const maxNodes = this.explorationState.maxNodes;
        const exploredNodes = this.explorationState.exploredNodes;

        const newNodes = [];
        let currentNode = currentFocus;
        const visited = new Set();

        while (newNodes.length < maxNodes) {
            if (visited.has(currentNode.id)) {
                break;
            }

            visited.add(currentNode.id);

            if (!exploredNodes.has(currentNode.id)) {
                newNodes.push(currentNode);
                exploredNodes.add(currentNode.id);
            }

            // éšæœºé€‰æ‹©ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
            const neighbors = this.kg.getNeighbors(currentNode.id);
            if (neighbors.length === 0) {
                break;
            }

            const randomIndex = Math.floor(Math.random() * neighbors.length);
            currentNode = neighbors[randomIndex];
        }

        return newNodes;
    }

    guidedExploration() {
        // åŸºäºç”¨æˆ·å…´è¶£å’ŒçŸ¥è¯†å›¾è°±ç»“æ„è¿›è¡Œå¼•å¯¼å¼æ¢ç´¢
        const currentFocus = this.explorationState.currentFocus;
        const userInterests = this.getUserInterests();
        const newNodes = [];

        // è®¡ç®—èŠ‚ç‚¹é‡è¦æ€§åˆ†æ•°
        const nodeScores = this.calculateNodeImportance(currentFocus, userInterests);

        // é€‰æ‹©é«˜åˆ†èŠ‚ç‚¹è¿›è¡Œæ¢ç´¢
        const sortedNodes = Object.entries(nodeScores)
            .sort(([,a], [,b]) => b - a)
            .slice(0, this.explorationState.maxNodes);

        sortedNodes.forEach(([nodeId, score]) => {
            const node = this.kg.getNode(nodeId);
            if (node && !this.explorationState.exploredNodes.has(nodeId)) {
                newNodes.push(node);
                this.explorationState.exploredNodes.add(nodeId);
            }
        });

        return newNodes;
    }

    calculateNodeImportance(node, userInterests) {
        const scores = {};
        const neighbors = this.kg.getNeighbors(node.id);

        neighbors.forEach(neighbor => {
            let score = 0;

            // åŸºäºç”¨æˆ·å…´è¶£çš„åˆ†æ•°
            score += this.calculateInterestScore(neighbor, userInterests);

            // åŸºäºèŠ‚ç‚¹ä¸­å¿ƒæ€§çš„åˆ†æ•°
            score += this.calculateCentralityScore(neighbor);

            // åŸºäºè¿æ¥å¼ºåº¦çš„åˆ†æ•°
            score += this.calculateConnectionScore(node, neighbor);

            scores[neighbor.id] = score;
        });

        return scores;
    }

    renderNewNodes(nodes) {
        // æ·»åŠ æ–°èŠ‚ç‚¹åˆ°æ¸²æŸ“å™¨
        const currentNodes = this.renderer.nodes;
        const newNodes = nodes.filter(node =>
            !currentNodes.some(n => n.id === node.id)
        );

        this.renderer.nodes = [...currentNodes, ...newNodes];
        this.renderer.render({
            nodes: this.renderer.nodes,
            links: this.renderer.links
        });
    }
}
```

#### 2.2 æ™ºèƒ½æ¨èç³»ç»Ÿ

```javascript
class IntelligentRecommendationSystem {
    constructor(knowledgeGraph, userProfile) {
        this.kg = knowledgeGraph;
        this.userProfile = userProfile;
        this.recommendationEngine = new RecommendationEngine();
        this.learningModel = new LearningModel();
    }

    getRecommendations(currentNode, options = {}) {
        const recommendations = {
            relatedConcepts: this.getRelatedConcepts(currentNode),
            learningPaths: this.getLearningPaths(currentNode),
            similarUsers: this.getSimilarUsers(currentNode),
            trendingTopics: this.getTrendingTopics(currentNode),
            personalizedSuggestions: this.getPersonalizedSuggestions(currentNode)
        };

        return this.rankRecommendations(recommendations, options);
    }

    getRelatedConcepts(node) {
        const relatedConcepts = [];
        const neighbors = this.kg.getNeighbors(node.id);

        neighbors.forEach(neighbor => {
            const relationship = this.kg.getRelationship(node.id, neighbor.id);
            const relevanceScore = this.calculateRelevanceScore(node, neighbor, relationship);

            relatedConcepts.push({
                concept: neighbor,
                relationship: relationship,
                relevanceScore: relevanceScore,
                recommendationType: 'related_concept'
            });
        });

        return relatedConcepts.sort((a, b) => b.relevanceScore - a.relevanceScore);
    }

    getLearningPaths(node) {
        const learningPaths = [];
        const userLevel = this.userProfile.knowledgeLevel;
        const userGoals = this.userProfile.learningGoals;

        // åŸºäºç”¨æˆ·ç›®æ ‡å’ŒçŸ¥è¯†æ°´å¹³ç”Ÿæˆå­¦ä¹ è·¯å¾„
        userGoals.forEach(goal => {
            const path = this.findOptimalPath(node, goal, userLevel);
            if (path) {
                learningPaths.push({
                    path: path,
                    goal: goal,
                    estimatedTime: this.estimateLearningTime(path),
                    difficulty: this.calculatePathDifficulty(path),
                    recommendationType: 'learning_path'
                });
            }
        });

        return learningPaths;
    }

    getSimilarUsers(node) {
        const similarUsers = [];
        const currentUserInterests = this.userProfile.interests;

        // æ‰¾åˆ°å¯¹å½“å‰èŠ‚ç‚¹æ„Ÿå…´è¶£çš„å…¶ä»–ç”¨æˆ·
        const interestedUsers = this.kg.getUsersInterestedIn(node.id);

        interestedUsers.forEach(user => {
            const similarity = this.calculateUserSimilarity(currentUserInterests, user.interests);
            if (similarity > 0.7) {
                similarUsers.push({
                    user: user,
                    similarity: similarity,
                    commonInterests: this.findCommonInterests(currentUserInterests, user.interests),
                    recommendationType: 'similar_user'
                });
            }
        });

        return similarUsers.sort((a, b) => b.similarity - a.similarity);
    }

    getTrendingTopics(node) {
        const trendingTopics = [];
        const relatedTopics = this.kg.getRelatedTopics(node.id);

        relatedTopics.forEach(topic => {
            const trendScore = this.calculateTrendScore(topic);
            if (trendScore > 0.5) {
                trendingTopics.push({
                    topic: topic,
                    trendScore: trendScore,
                    popularity: this.calculateTopicPopularity(topic),
                    recommendationType: 'trending_topic'
                });
            }
        });

        return trendingTopics.sort((a, b) => b.trendScore - a.trendScore);
    }

    getPersonalizedSuggestions(node) {
        const suggestions = [];
        const userHistory = this.userProfile.learningHistory;
        const userPreferences = this.userProfile.preferences;

        // åŸºäºç”¨æˆ·å†å²è¡Œä¸ºç”Ÿæˆä¸ªæ€§åŒ–å»ºè®®
        const similarNodes = this.findSimilarNodesInHistory(node, userHistory);

        similarNodes.forEach(similarNode => {
            const suggestion = this.generateSuggestion(node, similarNode, userPreferences);
            if (suggestion) {
                suggestions.push({
                    suggestion: suggestion,
                    confidence: this.calculateSuggestionConfidence(node, similarNode),
                    reasoning: this.generateSuggestionReasoning(node, similarNode),
                    recommendationType: 'personalized_suggestion'
                });
            }
        });

        return suggestions.sort((a, b) => b.confidence - a.confidence);
    }

    rankRecommendations(recommendations, options) {
        const weights = options.weights || {
            relatedConcepts: 0.3,
            learningPaths: 0.25,
            similarUsers: 0.15,
            trendingTopics: 0.15,
            personalizedSuggestions: 0.15
        };

        const allRecommendations = [];

        // åˆå¹¶æ‰€æœ‰æ¨è
        Object.entries(recommendations).forEach(([type, items]) => {
            items.forEach(item => {
                item.finalScore = item.relevanceScore * weights[type];
                allRecommendations.push(item);
            });
        });

        // æ’åºå¹¶è¿”å›
        return allRecommendations.sort((a, b) => b.finalScore - a.finalScore);
    }
}
```

### 3. åä½œæ¢ç´¢åŠŸèƒ½

#### 3.1 å¤šç”¨æˆ·åä½œç³»ç»Ÿ

```javascript
class CollaborativeExplorationSystem {
    constructor(knowledgeGraph) {
        this.kg = knowledgeGraph;
        this.activeUsers = new Map();
        this.collaborationSessions = new Map();
        this.realTimeSync = new RealTimeSync();
    }

    joinSession(userId, sessionId) {
        const user = {
            id: userId,
            sessionId: sessionId,
            currentFocus: null,
            explorationPath: [],
            lastActivity: Date.now()
        };

        this.activeUsers.set(userId, user);

        // åŠ å…¥åä½œä¼šè¯
        if (!this.collaborationSessions.has(sessionId)) {
            this.collaborationSessions.set(sessionId, {
                id: sessionId,
                participants: new Set(),
                sharedFocus: null,
                sharedAnnotations: new Map(),
                collaborationHistory: []
            });
        }

        const session = this.collaborationSessions.get(sessionId);
        session.participants.add(userId);

        // é€šçŸ¥å…¶ä»–ç”¨æˆ·
        this.notifyUserJoined(userId, sessionId);

        return session;
    }

    leaveSession(userId, sessionId) {
        const user = this.activeUsers.get(userId);
        if (user) {
            this.activeUsers.delete(userId);

            const session = this.collaborationSessions.get(sessionId);
            if (session) {
                session.participants.delete(userId);

                // å¦‚æœä¼šè¯ä¸ºç©ºï¼Œåˆ é™¤ä¼šè¯
                if (session.participants.size === 0) {
                    this.collaborationSessions.delete(sessionId);
                } else {
                    // é€šçŸ¥å…¶ä»–ç”¨æˆ·
                    this.notifyUserLeft(userId, sessionId);
                }
            }
        }
    }

    updateUserFocus(userId, focusNode) {
        const user = this.activeUsers.get(userId);
        if (user) {
            user.currentFocus = focusNode;
            user.lastActivity = Date.now();

            // é€šçŸ¥ä¼šè¯ä¸­çš„å…¶ä»–ç”¨æˆ·
            this.notifyFocusChange(userId, focusNode);

            // æ›´æ–°å…±äº«ç„¦ç‚¹
            this.updateSharedFocus(user.sessionId, focusNode);
        }
    }

    addSharedAnnotation(userId, nodeId, annotation) {
        const user = this.activeUsers.get(userId);
        if (user) {
            const session = this.collaborationSessions.get(user.sessionId);
            if (session) {
                if (!session.sharedAnnotations.has(nodeId)) {
                    session.sharedAnnotations.set(nodeId, []);
                }

                session.sharedAnnotations.get(nodeId).push({
                    id: this.generateAnnotationId(),
                    userId: userId,
                    content: annotation,
                    timestamp: Date.now(),
                    type: 'text'
                });

                // é€šçŸ¥å…¶ä»–ç”¨æˆ·
                this.notifyAnnotationAdded(userId, nodeId, annotation);
            }
        }
    }

    createSharedPath(userId, path) {
        const user = this.activeUsers.get(userId);
        if (user) {
            const session = this.collaborationSessions.get(user.sessionId);
            if (session) {
                const sharedPath = {
                    id: this.generatePathId(),
                    creatorId: userId,
                    path: path,
                    timestamp: Date.now(),
                    participants: new Set(session.participants)
                };

                session.collaborationHistory.push(sharedPath);

                // é€šçŸ¥å…¶ä»–ç”¨æˆ·
                this.notifySharedPathCreated(userId, sharedPath);
            }
        }
    }

    getCollaborationInsights(sessionId) {
        const session = this.collaborationSessions.get(sessionId);
        if (!session) return null;

        return {
            sessionId: sessionId,
            participantCount: session.participants.size,
            sharedFocus: session.sharedFocus,
            annotationCount: Array.from(session.sharedAnnotations.values())
                .reduce((total, annotations) => total + annotations.length, 0),
            collaborationHistory: session.collaborationHistory,
            insights: this.generateCollaborationInsights(session)
        };
    }

    generateCollaborationInsights(session) {
        const insights = {
            mostExploredNodes: this.findMostExploredNodes(session),
            collaborationPatterns: this.analyzeCollaborationPatterns(session),
            knowledgeGaps: this.identifyKnowledgeGaps(session),
            learningRecommendations: this.generateLearningRecommendations(session)
        };

        return insights;
    }
}
```

## ğŸ› ï¸ ç³»ç»Ÿé›†æˆ

### 1. äº¤äº’å¼çŸ¥è¯†å›¾è°±ç³»ç»Ÿæ¶æ„

```javascript
class InteractiveKnowledgeGraph {
    constructor(container, options = {}) {
        this.container = container;
        this.options = options;

        // åˆå§‹åŒ–ç»„ä»¶
        this.renderer = new InteractiveGraphRenderer(container, options.renderer);
        this.explorationEngine = new AutoExplorationEngine(this.kg, this.renderer);
        this.recommendationSystem = new IntelligentRecommendationSystem(this.kg, options.userProfile);
        this.collaborationSystem = new CollaborativeExplorationSystem(this.kg);

        // åˆå§‹åŒ–äº‹ä»¶ç³»ç»Ÿ
        this.eventBus = new EventBus();
        this.setupEventHandlers();

        // åˆå§‹åŒ–ç”¨æˆ·ç•Œé¢
        this.ui = new KnowledgeGraphUI(this);
        this.ui.render();
    }

    loadData(data) {
        this.kg = new KnowledgeGraph(data);
        this.renderer.render(data);
        this.emit('dataLoaded', data);
    }

    startExploration(nodeId, options) {
        const node = this.kg.getNode(nodeId);
        if (node) {
            this.explorationEngine.startExploration(node, options);
            this.emit('explorationStarted', { node, options });
        }
    }

    getRecommendations(nodeId, options) {
        const node = this.kg.getNode(nodeId);
        if (node) {
            return this.recommendationSystem.getRecommendations(node, options);
        }
        return [];
    }

    joinCollaboration(userId, sessionId) {
        return this.collaborationSystem.joinSession(userId, sessionId);
    }

    setupEventHandlers() {
        // æ¸²æŸ“å™¨äº‹ä»¶
        this.renderer.on('nodeClick', (data) => {
            this.emit('nodeClick', data);
            this.showNodeDetails(data.node);
        });

        this.renderer.on('nodeHover', (data) => {
            this.emit('nodeHover', data);
            this.showNodeTooltip(data.node);
        });

        // æ¢ç´¢å¼•æ“äº‹ä»¶
        this.explorationEngine.on('explorationUpdate', (data) => {
            this.emit('explorationUpdate', data);
            this.updateExplorationUI(data);
        });

        // æ¨èç³»ç»Ÿäº‹ä»¶
        this.recommendationSystem.on('recommendationsReady', (data) => {
            this.emit('recommendationsReady', data);
            this.showRecommendations(data.recommendations);
        });
    }
}
```

## ğŸ“Š å¼€å‘è¿›åº¦

### ç¬¬ä¸€é˜¶æ®µï¼šæ ¸å¿ƒæ¸²æŸ“ï¼ˆæœ¬å‘¨ï¼‰

#### 1.1 äº¤äº’å¼å¯è§†åŒ–

- [x] åŠ¨æ€å›¾å½¢æ¸²æŸ“å™¨è®¾è®¡
- [ ] äº¤äº’ç®¡ç†å™¨å®ç°
- [ ] ç¼©æ”¾å’Œå¹³ç§»åŠŸèƒ½
- [ ] èŠ‚ç‚¹å’Œé“¾æ¥äº¤äº’

#### 1.2 åŸºç¡€äº¤äº’

- [ ] èŠ‚ç‚¹é€‰æ‹©å’Œé«˜äº®
- [ ] æ‹–æ‹½å’Œç§»åŠ¨
- [ ] å·¥å…·æç¤ºæ˜¾ç¤º
- [ ] ä¸Šä¸‹æ–‡èœå•

### ç¬¬äºŒé˜¶æ®µï¼šæ™ºèƒ½æ¢ç´¢ï¼ˆä¸‹å‘¨ï¼‰

#### 2.1 è‡ªåŠ¨æ¢ç´¢

- [ ] è‡ªåŠ¨æ¢ç´¢å¼•æ“å®ç°
- [ ] å¤šç§æ¢ç´¢ç­–ç•¥
- [ ] æ¢ç´¢çŠ¶æ€ç®¡ç†
- [ ] æ¢ç´¢è·¯å¾„è®°å½•

#### 2.2 æ™ºèƒ½æ¨è

- [ ] æ¨èç³»ç»Ÿå®ç°
- [ ] ä¸ªæ€§åŒ–æ¨èç®—æ³•
- [ ] æ¨èç»“æœæ’åº
- [ ] æ¨èæ•ˆæœè¯„ä¼°

### ç¬¬ä¸‰é˜¶æ®µï¼šåä½œåŠŸèƒ½ï¼ˆç¬¬ä¸‰å‘¨ï¼‰

#### 3.1 å¤šç”¨æˆ·åä½œ

- [ ] åä½œç³»ç»Ÿå®ç°
- [ ] å®æ—¶åŒæ­¥æœºåˆ¶
- [ ] å…±äº«æ³¨é‡ŠåŠŸèƒ½
- [ ] åä½œä¼šè¯ç®¡ç†

#### 3.2 ç³»ç»Ÿé›†æˆ

- [ ] å®Œæ•´ç³»ç»Ÿé›†æˆ
- [ ] ç”¨æˆ·ç•Œé¢å®ç°
- [ ] æ€§èƒ½ä¼˜åŒ–
- [ ] æµ‹è¯•éªŒè¯

## ğŸ¯ é¢„æœŸæ•ˆæœ

### 1. å¯è§†åŒ–æ•ˆæœ

- **äº¤äº’æµç•…**: æµç•…çš„å›¾å½¢äº¤äº’ä½“éªŒ
- **è§†è§‰ç¾è§‚**: ç¾è§‚çš„å›¾å½¢å±•ç¤ºæ•ˆæœ
- **å“åº”è¿…é€Ÿ**: å¿«é€Ÿçš„ç”¨æˆ·äº¤äº’å“åº”

### 2. æ¢ç´¢æ•ˆæœ

- **æ™ºèƒ½æ¢ç´¢**: è‡ªåŠ¨åŒ–çš„çŸ¥è¯†æ¢ç´¢
- **ä¸ªæ€§åŒ–æ¨è**: åŸºäºç”¨æˆ·åå¥½çš„æ¨è
- **å­¦ä¹ è·¯å¾„**: ä¼˜åŒ–çš„å­¦ä¹ è·¯å¾„è§„åˆ’

### 3. åä½œæ•ˆæœ

- **å®æ—¶åä½œ**: å¤šç”¨æˆ·å®æ—¶åä½œæ¢ç´¢
- **å…±äº«çŸ¥è¯†**: çŸ¥è¯†å…±äº«å’Œåä½œå­¦ä¹ 
- **åä½œæ´å¯Ÿ**: åä½œæ¨¡å¼åˆ†æå’Œæ´å¯Ÿ

---

**å¼€å‘è®¡åˆ’ç”Ÿæˆæ—¶é—´**: 2025-01-10
**å¼€å‘çŠ¶æ€**: ğŸš€ ç«‹å³å¼€å§‹
**ä¸‹ä¸€æ­¥**: å¼€å§‹äº¤äº’å¼å¯è§†åŒ–å¼•æ“å®ç°
