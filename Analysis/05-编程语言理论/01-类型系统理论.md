# 01-类型系统理论

## 目录

1. [1.0 类型系统基础](#10-类型系统基础)
2. [2.0 类型理论](#20-类型理论)
3. [3.0 类型检查](#30-类型检查)
4. [4.0 类型推断](#40-类型推断)
5. [5.0 多态性](#50-多态性)
6. [6.0 依赖类型](#60-依赖类型)
7. [7.0 类型安全](#70-类型安全)
8. [8.0 实践应用](#80-实践应用)

## 1.0 类型系统基础

### 1.1 类型定义

**定义 1.1.1 (类型)**
类型是一个集合，表示值的集合。类型系统是一个三元组 $\mathcal{TS} = (T, R, C)$，其中：

- $T$ 是类型集合
- $R$ 是类型关系集合
- $C$ 是类型检查函数

**定义 1.1.2 (类型环境)**
类型环境是一个函数 $\Gamma: \text{Var} \to T$，将变量映射到类型。

**定义 1.1.3 (类型判断)**
类型判断是一个三元组 $\Gamma \vdash e : \tau$，表示在环境 $\Gamma$ 下，表达式 $e$ 具有类型 $\tau$。

### 1.2 基本类型

**定义 1.2.1 (基本类型)**
基本类型包括：
- $\text{Bool}$：布尔类型
- $\text{Int}$：整数类型
- $\text{Float}$：浮点数类型
- $\text{String}$：字符串类型
- $\text{Unit}$：单位类型

**定义 1.2.2 (函数类型)**
函数类型是一个二元组 $\tau_1 \to \tau_2$，表示从类型 $\tau_1$ 到类型 $\tau_2$ 的函数。

**定义 1.2.3 (积类型)**
积类型是一个二元组 $\tau_1 \times \tau_2$，表示类型 $\tau_1$ 和 $\tau_2$ 的笛卡尔积。

**定义 1.2.4 (和类型)**
和类型是一个二元组 $\tau_1 + \tau_2$，表示类型 $\tau_1$ 或 $\tau_2$。

```rust
// Rust实现：类型系统
#[derive(Debug, Clone, PartialEq)]
pub enum Type {
    Bool,
    Int,
    Float,
    String,
    Unit,
    Function(Box<Type>, Box<Type>),
    Product(Box<Type>, Box<Type>),
    Sum(Box<Type>, Box<Type>),
    Variable(String),
    ForAll(String, Box<Type>),
}

#[derive(Debug, Clone)]
pub struct TypeEnvironment {
    pub bindings: HashMap<String, Type>,
}

impl TypeEnvironment {
    pub fn new() -> Self {
        TypeEnvironment {
            bindings: HashMap::new(),
        }
    }
    
    pub fn extend(&self, var: String, ty: Type) -> TypeEnvironment {
        let mut new_env = self.clone();
        new_env.bindings.insert(var, ty);
        new_env
    }
    
    pub fn lookup(&self, var: &str) -> Option<&Type> {
        self.bindings.get(var)
    }
}

#[derive(Debug, Clone)]
pub struct TypeChecker {
    pub environment: TypeEnvironment,
}

impl TypeChecker {
    pub fn new() -> Self {
        TypeChecker {
            environment: TypeEnvironment::new(),
        }
    }
    
    pub fn type_check(&mut self, expr: &Expression) -> Result<Type, TypeError> {
        match expr {
            Expression::Bool(_) => Ok(Type::Bool),
            Expression::Int(_) => Ok(Type::Int),
            Expression::Float(_) => Ok(Type::Float),
            Expression::String(_) => Ok(Type::String),
            Expression::Variable(name) => {
                self.environment.lookup(name)
                    .cloned()
                    .ok_or(TypeError::UnboundVariable(name.clone()))
            }
            Expression::Application(fun, arg) => {
                let fun_type = self.type_check(fun)?;
                let arg_type = self.type_check(arg)?;
                
                match fun_type {
                    Type::Function(input_type, output_type) => {
                        if *input_type == arg_type {
                            Ok(*output_type)
                        } else {
                            Err(TypeError::TypeMismatch(*input_type, arg_type))
                        }
                    }
                    _ => Err(TypeError::NotAFunction(fun_type)),
                }
            }
            Expression::Lambda(param, body) => {
                // 简化实现，假设参数类型为Int
                let param_type = Type::Int;
                let new_env = self.environment.extend(param.clone(), param_type.clone());
                let mut new_checker = TypeChecker { environment: new_env };
                let body_type = new_checker.type_check(body)?;
                Ok(Type::Function(Box::new(param_type), Box::new(body_type)))
            }
        }
    }
}

#[derive(Debug)]
pub enum TypeError {
    UnboundVariable(String),
    TypeMismatch(Type, Type),
    NotAFunction(Type),
}
```

## 2.0 类型理论

### 2.1 简单类型λ演算

**定义 2.1.1 (简单类型λ演算)**
简单类型λ演算的语法定义为：

$$\begin{align*}
\tau &::= \text{Bool} \mid \text{Int} \mid \tau_1 \to \tau_2 \\
e &::= x \mid \lambda x:\tau.e \mid e_1 e_2 \mid \text{true} \mid \text{false} \mid 0 \mid 1 \mid \ldots
\end{align*}$$

**类型规则**：

1. **变量规则**：
   $$\frac{x:\tau \in \Gamma}{\Gamma \vdash x : \tau}$$

2. **抽象规则**：
   $$\frac{\Gamma, x:\tau_1 \vdash e : \tau_2}{\Gamma \vdash \lambda x:\tau_1.e : \tau_1 \to \tau_2}$$

3. **应用规则**：
   $$\frac{\Gamma \vdash e_1 : \tau_1 \to \tau_2 \quad \Gamma \vdash e_2 : \tau_1}{\Gamma \vdash e_1 e_2 : \tau_2}$$

### 2.2 类型等价性

**定义 2.2.1 (类型等价)**
类型 $\tau_1$ 和 $\tau_2$ 等价，记为 $\tau_1 \equiv \tau_2$，如果它们表示相同的类型。

**等价规则**：
1. **反射性**：$\tau \equiv \tau$
2. **对称性**：$\tau_1 \equiv \tau_2 \Rightarrow \tau_2 \equiv \tau_1$
3. **传递性**：$\tau_1 \equiv \tau_2 \land \tau_2 \equiv \tau_3 \Rightarrow \tau_1 \equiv \tau_3$
4. **函数等价**：$\tau_1 \equiv \tau_1' \land \tau_2 \equiv \tau_2' \Rightarrow \tau_1 \to \tau_2 \equiv \tau_1' \to \tau_2'$

### 2.3 类型替换

**定义 2.3.1 (类型替换)**
类型替换是一个函数 $\sigma: \text{TypeVar} \to \text{Type}$，将类型变量映射到类型。

**定义 2.3.2 (替换应用)**
替换 $\sigma$ 应用到类型 $\tau$，记为 $\tau[\sigma]$，递归定义如下：

- $X[\sigma] = \sigma(X)$
- $\text{Bool}[\sigma] = \text{Bool}$
- $\text{Int}[\sigma] = \text{Int}$
- $(\tau_1 \to \tau_2)[\sigma] = \tau_1[\sigma] \to \tau_2[\sigma]$

```go
// Go实现：类型理论
type Type interface {
    String() string
    Equals(other Type) bool
    Substitute(subst map[string]Type) Type
}

type BasicType struct {
    name string
}

type FunctionType struct {
    domain   Type
    codomain Type
}

type TypeVariable struct {
    name string
}

func (bt *BasicType) Equals(other Type) bool {
    if otherBT, ok := other.(*BasicType); ok {
        return bt.name == otherBT.name
    }
    return false
}

func (bt *BasicType) Substitute(subst map[string]Type) Type {
    return bt
}

func (ft *FunctionType) Equals(other Type) bool {
    if otherFT, ok := other.(*FunctionType); ok {
        return ft.domain.Equals(otherFT.domain) && ft.codomain.Equals(otherFT.codomain)
    }
    return false
}

func (ft *FunctionType) Substitute(subst map[string]Type) Type {
    return &FunctionType{
        domain:   ft.domain.Substitute(subst),
        codomain: ft.codomain.Substitute(subst),
    }
}

func (tv *TypeVariable) Equals(other Type) bool {
    if otherTV, ok := other.(*TypeVariable); ok {
        return tv.name == otherTV.name
    }
    return false
}

func (tv *TypeVariable) Substitute(subst map[string]Type) Type {
    if replacement, exists := subst[tv.name]; exists {
        return replacement
    }
    return tv
}
```

## 3.0 类型检查

### 3.1 类型检查算法

**算法 3.1.1 (类型检查算法)**
```
function TypeCheck(Γ, e):
    case e of
        x: return Γ(x)
        λx:τ.e: 
            τ' = TypeCheck(Γ[x↦τ], e)
            return τ → τ'
        e₁ e₂:
            τ₁ = TypeCheck(Γ, e₁)
            τ₂ = TypeCheck(Γ, e₂)
            if τ₁ = τ₂' → τ then
                if τ₂ = τ₂' then return τ
                else error
            else error
```

### 3.2 类型错误

**定义 3.2.1 (类型错误)**
类型错误包括：
1. **未绑定变量**：变量在环境中未定义
2. **类型不匹配**：期望类型与实际类型不符
3. **非函数应用**：对非函数类型进行函数应用

**定义 3.2.2 (类型错误恢复)**
类型错误恢复是尝试修复类型错误的策略：
1. **类型转换**：自动类型转换
2. **默认值**：提供默认类型
3. **错误提示**：提供详细的错误信息

### 3.3 类型检查优化

**定义 3.3.1 (类型检查优化)**
类型检查优化策略：
1. **缓存**：缓存类型检查结果
2. **增量检查**：只检查修改的部分
3. **并行检查**：并行进行类型检查

```rust
// Rust实现：类型检查优化
#[derive(Debug, Clone)]
pub struct OptimizedTypeChecker {
    pub cache: HashMap<Expression, Type>,
    pub environment: TypeEnvironment,
}

impl OptimizedTypeChecker {
    pub fn new() -> Self {
        OptimizedTypeChecker {
            cache: HashMap::new(),
            environment: TypeEnvironment::new(),
        }
    }
    
    pub fn type_check_cached(&mut self, expr: &Expression) -> Result<Type, TypeError> {
        // 检查缓存
        if let Some(cached_type) = self.cache.get(expr) {
            return Ok(cached_type.clone());
        }
        
        // 执行类型检查
        let result = self.type_check(expr);
        
        // 缓存结果
        if let Ok(ref ty) = result {
            self.cache.insert(expr.clone(), ty.clone());
        }
        
        result
    }
    
    pub fn type_check(&mut self, expr: &Expression) -> Result<Type, TypeError> {
        // 基本类型检查逻辑
        match expr {
            Expression::Bool(_) => Ok(Type::Bool),
            Expression::Int(_) => Ok(Type::Int),
            Expression::Float(_) => Ok(Type::Float),
            Expression::String(_) => Ok(Type::String),
            Expression::Variable(name) => {
                self.environment.lookup(name)
                    .cloned()
                    .ok_or(TypeError::UnboundVariable(name.clone()))
            }
            Expression::Application(fun, arg) => {
                let fun_type = self.type_check(fun)?;
                let arg_type = self.type_check(arg)?;
                
                match fun_type {
                    Type::Function(input_type, output_type) => {
                        if self.unify(&input_type, &arg_type) {
                            Ok(*output_type)
                        } else {
                            Err(TypeError::TypeMismatch(*input_type, arg_type))
                        }
                    }
                    _ => Err(TypeError::NotAFunction(fun_type)),
                }
            }
            Expression::Lambda(param, body) => {
                let param_type = Type::Variable(format!("T_{}", param));
                let new_env = self.environment.extend(param.clone(), param_type.clone());
                let mut new_checker = OptimizedTypeChecker {
                    cache: HashMap::new(),
                    environment: new_env,
                };
                let body_type = new_checker.type_check(body)?;
                Ok(Type::Function(Box::new(param_type), Box::new(body_type)))
            }
        }
    }
    
    pub fn unify(&self, t1: &Type, t2: &Type) -> bool {
        match (t1, t2) {
            (Type::Bool, Type::Bool) => true,
            (Type::Int, Type::Int) => true,
            (Type::Float, Type::Float) => true,
            (Type::String, Type::String) => true,
            (Type::Function(in1, out1), Type::Function(in2, out2)) => {
                self.unify(in1, in2) && self.unify(out1, out2)
            }
            (Type::Variable(_), _) => true, // 变量可以匹配任何类型
            (_, Type::Variable(_)) => true,
            _ => false,
        }
    }
}
```

## 4.0 类型推断

### 4.1 Hindley-Milner类型系统

**定义 4.1.1 (Hindley-Milner类型系统)**
Hindley-Milner类型系统扩展了简单类型λ演算，支持多态类型。

**类型语法**：
$$\begin{align*}
\tau &::= \alpha \mid \text{Bool} \mid \text{Int} \mid \tau_1 \to \tau_2 \\
\sigma &::= \tau \mid \forall \alpha.\sigma
\end{align*}$$

**定义 4.1.2 (类型模式)**
类型模式是一个三元组 $(\Gamma, e, \tau)$，表示在环境 $\Gamma$ 下，表达式 $e$ 具有类型 $\tau$。

### 4.2 统一算法

**算法 4.2.1 (Robinson统一算法)**
```
function Unify(τ₁, τ₂):
    if τ₁ = τ₂ then return {}
    if τ₁ is a variable then return {τ₁ ↦ τ₂}
    if τ₂ is a variable then return {τ₂ ↦ τ₁}
    if τ₁ = τ₁' → τ₁'' and τ₂ = τ₂' → τ₂'' then
        σ₁ = Unify(τ₁', τ₂')
        σ₂ = Unify(τ₁''[σ₁], τ₂''[σ₁])
        return σ₁ ∘ σ₂
    else fail
```

### 4.3 类型推断算法

**算法 4.3.1 (W算法)**
```
function W(Γ, e):
    case e of
        x: return (Γ(x), {})
        λx.e:
            β = fresh variable
            (τ, S) = W(Γ[x ↦ β], e)
            return (S(β) → τ, S)
        e₁ e₂:
            (τ₁, S₁) = W(Γ, e₁)
            (τ₂, S₂) = W(S₁(Γ), e₂)
            β = fresh variable
            S₃ = Unify(S₂(τ₁), τ₂ → β)
            return (S₃(β), S₃ ∘ S₂ ∘ S₁)
```

```go
// Go实现：类型推断
type TypeInferrer struct {
    freshCounter int
    constraints  []Constraint
}

type Constraint struct {
    left  Type
    right Type
}

type Substitution map[string]Type

func (ti *TypeInferrer) freshVariable() Type {
    ti.freshCounter++
    return &TypeVariable{name: fmt.Sprintf("α%d", ti.freshCounter)}
}

func (ti *TypeInferrer) infer(env map[string]Type, expr Expression) (Type, Substitution, error) {
    switch e := expr.(type) {
    case *Variable:
        if typ, exists := env[e.name]; exists {
            return typ, Substitution{}, nil
        }
        return nil, nil, fmt.Errorf("unbound variable: %s", e.name)
        
    case *Lambda:
        paramType := ti.freshVariable()
        newEnv := make(map[string]Type)
        for k, v := range env {
            newEnv[k] = v
        }
        newEnv[e.param] = paramType
        
        bodyType, subst, err := ti.infer(newEnv, e.body)
        if err != nil {
            return nil, nil, err
        }
        
        return &FunctionType{
            domain:   subst.apply(paramType),
            codomain: bodyType,
        }, subst, nil
        
    case *Application:
        funType, subst1, err := ti.infer(env, e.function)
        if err != nil {
            return nil, nil, err
        }
        
        argType, subst2, err := ti.infer(subst1.applyEnv(env), e.argument)
        if err != nil {
            return nil, nil, err
        }
        
        resultType := ti.freshVariable()
        constraint := Constraint{
            left:  subst2.apply(funType),
            right: &FunctionType{domain: argType, codomain: resultType},
        }
        
        ti.constraints = append(ti.constraints, constraint)
        
        return resultType, subst2.compose(subst1), nil
    }
    
    return nil, nil, fmt.Errorf("unsupported expression type")
}

func (ti *TypeInferrer) solve() (Substitution, error) {
    subst := make(Substitution)
    
    for _, constraint := range ti.constraints {
        newSubst, err := ti.unify(constraint.left, constraint.right)
        if err != nil {
            return nil, err
        }
        
        // 应用新替换到所有约束
        for i := range ti.constraints {
            ti.constraints[i].left = newSubst.apply(ti.constraints[i].left)
            ti.constraints[i].right = newSubst.apply(ti.constraints[i].right)
        }
        
        // 合并替换
        subst = subst.compose(newSubst)
    }
    
    return subst, nil
}

func (ti *TypeInferrer) unify(t1, t2 Type) (Substitution, error) {
    if t1.Equals(t2) {
        return Substitution{}, nil
    }
    
    if tv, ok := t1.(*TypeVariable); ok {
        return Substitution{tv.name: t2}, nil
    }
    
    if tv, ok := t2.(*TypeVariable); ok {
        return Substitution{tv.name: t1}, nil
    }
    
    if ft1, ok1 := t1.(*FunctionType); ok1 {
        if ft2, ok2 := t2.(*FunctionType); ok2 {
            subst1, err := ti.unify(ft1.domain, ft2.domain)
            if err != nil {
                return nil, err
            }
            
            subst2, err := ti.unify(subst1.apply(ft1.codomain), subst1.apply(ft2.codomain))
            if err != nil {
                return nil, err
            }
            
            return subst2.compose(subst1), nil
        }
    }
    
    return nil, fmt.Errorf("cannot unify %v and %v", t1, t2)
}
```

## 5.0 多态性

### 5.1 参数多态

**定义 5.1.1 (参数多态)**
参数多态允许函数和数据类型使用类型变量，使其可以处理多种类型。

**定义 5.1.2 (多态类型)**
多态类型是一个全称类型 $\forall \alpha.\tau$，表示对于所有类型 $\alpha$，类型 $\tau$ 都成立。

**类型规则**：
1. **泛化规则**：
   $$\frac{\Gamma \vdash e : \tau \quad \alpha \notin \text{free}(\Gamma)}{\Gamma \vdash e : \forall \alpha.\tau}$$

2. **实例化规则**：
   $$\frac{\Gamma \vdash e : \forall \alpha.\tau}{\Gamma \vdash e : \tau[\alpha \mapsto \tau']}$$

### 5.2 特设多态

**定义 5.2.1 (特设多态)**
特设多态允许同一操作符或函数名用于不同类型的操作。

**实现方式**：
1. **函数重载**：同一函数名，不同参数类型
2. **操作符重载**：同一操作符，不同操作数类型
3. **类型类**：通过接口定义行为

### 5.3 子类型多态

**定义 5.3.1 (子类型关系)**
类型 $\tau_1$ 是类型 $\tau_2$ 的子类型，记为 $\tau_1 <: \tau_2$，如果 $\tau_1$ 的值可以在需要 $\tau_2$ 的地方使用。

**子类型规则**：
1. **自反性**：$\tau <: \tau$
2. **传递性**：$\tau_1 <: \tau_2 \land \tau_2 <: \tau_3 \Rightarrow \tau_1 <: \tau_3$
3. **协变性**：$\tau_1 <: \tau_1' \land \tau_2 <: \tau_2' \Rightarrow \tau_1 \to \tau_2 <: \tau_1' \to \tau_2'$

```rust
// Rust实现：多态性
// 参数多态
pub fn identity<T>(x: T) -> T {
    x
}

pub fn map<T, U, F>(list: Vec<T>, f: F) -> Vec<U>
where
    F: Fn(T) -> U,
{
    list.into_iter().map(f).collect()
}

// 特设多态（通过trait）
pub trait Add<T> {
    type Output;
    fn add(self, other: T) -> Self::Output;
}

impl Add<i32> for i32 {
    type Output = i32;
    fn add(self, other: i32) -> i32 {
        self + other
    }
}

impl Add<f64> for f64 {
    type Output = f64;
    fn add(self, other: f64) -> f64 {
        self + other
    }
}

// 子类型多态
pub trait Animal {
    fn make_sound(&self) -> String;
}

pub struct Dog {
    pub name: String,
}

pub struct Cat {
    pub name: String,
}

impl Animal for Dog {
    fn make_sound(&self) -> String {
        format!("{} says woof", self.name)
    }
}

impl Animal for Cat {
    fn make_sound(&self) -> String {
        format!("{} says meow", self.name)
    }
}

pub fn animal_sounds(animals: Vec<Box<dyn Animal>>) -> Vec<String> {
    animals.iter().map(|animal| animal.make_sound()).collect()
}
```

## 6.0 依赖类型

### 6.1 依赖类型基础

**定义 6.1.1 (依赖类型)**
依赖类型允许类型依赖于值，类型可以包含值表达式。

**定义 6.1.2 (依赖函数类型)**
依赖函数类型是一个三元组 $\Pi x:A.B(x)$，表示对于所有 $x:A$，类型 $B(x)$。

**定义 6.1.3 (依赖积类型)**
依赖积类型是一个三元组 $\Sigma x:A.B(x)$，表示存在 $x:A$，使得类型 $B(x)$。

### 6.2 类型族

**定义 6.2.1 (类型族)**
类型族是一个函数 $F: A \to \text{Type}$，将值映射到类型。

**定义 6.2.2 (类型族实例)**
类型族实例是类型族的具体实现，为特定值提供类型。

### 6.3 证明相关编程

**定义 6.3.1 (证明相关编程)**
证明相关编程将类型系统用作逻辑系统，类型对应命题，程序对应证明。

**Curry-Howard对应**：
- 类型 $\leftrightarrow$ 命题
- 程序 $\leftrightarrow$ 证明
- 函数类型 $\leftrightarrow$ 蕴含
- 积类型 $\leftrightarrow$ 合取
- 和类型 $\leftrightarrow$ 析取

```rust
// Rust实现：依赖类型（简化版本）
// 使用const generics模拟依赖类型
pub struct Vector<T, const N: usize> {
    elements: [T; N],
}

impl<T, const N: usize> Vector<T, N> {
    pub fn new(elements: [T; N]) -> Self {
        Vector { elements }
    }
    
    pub fn length(&self) -> usize {
        N
    }
    
    pub fn get(&self, index: usize) -> Option<&T> {
        if index < N {
            Some(&self.elements[index])
        } else {
            None
        }
    }
}

// 类型安全的矩阵乘法
pub struct Matrix<T, const M: usize, const N: usize> {
    elements: [[T; N]; M],
}

impl<T, const M: usize, const N: usize, const P: usize> 
    std::ops::Mul<Matrix<T, N, P>> for Matrix<T, M, N>
where
    T: Copy + std::ops::Add<Output = T> + std::ops::Mul<Output = T> + Default,
{
    type Output = Matrix<T, M, P>;
    
    fn mul(self, other: Matrix<T, N, P>) -> Matrix<T, M, P> {
        let mut result = Matrix {
            elements: [[T::default(); P]; M],
        };
        
        for i in 0..M {
            for j in 0..P {
                for k in 0..N {
                    result.elements[i][j] = result.elements[i][j] + 
                        self.elements[i][k] * other.elements[k][j];
                }
            }
        }
        
        result
    }
}

// 证明相关编程示例
pub trait Even {
    fn is_even(&self) -> bool;
}

impl Even for u32 {
    fn is_even(&self) -> bool {
        self % 2 == 0
    }
}

// 类型安全的除法，确保除数不为零
pub fn safe_divide<T>(dividend: T, divisor: NonZero<T>) -> T
where
    T: std::ops::Div<NonZero<T>, Output = T>,
{
    dividend / divisor
}
```

## 7.0 类型安全

### 7.1 类型安全定义

**定义 7.1.1 (类型安全)**
类型安全是指程序在运行时不会出现类型错误。

**定义 7.1.2 (类型安全定理)**
如果程序通过类型检查，则程序是类型安全的。

**定理 7.1.1 (进展定理)**
如果 $\vdash e : \tau$ 且 $e$ 不是值，则存在 $e'$ 使得 $e \to e'$。

**定理 7.1.2 (保持定理)**
如果 $\vdash e : \tau$ 且 $e \to e'$，则 $\vdash e' : \tau$。

### 7.2 类型安全保证

**定义 7.2.1 (类型安全保证)**
类型安全保证包括：
1. **内存安全**：不会访问无效内存
2. **类型一致性**：操作数类型与操作符匹配
3. **边界检查**：数组访问在有效范围内

### 7.3 类型安全验证

**定义 7.3.1 (类型安全验证)**
类型安全验证方法：
1. **静态类型检查**：编译时检查
2. **动态类型检查**：运行时检查
3. **形式化验证**：数学证明

```go
// Go实现：类型安全验证
type TypeSafeChecker struct {
    rules []TypeRule
}

type TypeRule struct {
    name     string
    check    func(expr Expression, env TypeEnvironment) (Type, error)
}

func (tsc *TypeSafeChecker) AddRule(rule TypeRule) {
    tsc.rules = append(tsc.rules, rule)
}

func (tsc *TypeSafeChecker) Check(expr Expression, env TypeEnvironment) (Type, error) {
    for _, rule := range tsc.rules {
        if typ, err := rule.check(expr, env); err == nil {
            return typ, nil
        }
    }
    return nil, fmt.Errorf("no matching type rule for expression")
}

// 类型安全的内存管理
type SafeArray<T> struct {
    data []T
    size int
}

func NewSafeArray<T>(size int) *SafeArray<T> {
    return &SafeArray<T>{
        data: make([]T, size),
        size: size,
    }
}

func (sa *SafeArray[T]) Get(index int) (T, error) {
    if index < 0 || index >= sa.size {
        var zero T
        return zero, fmt.Errorf("index out of bounds: %d", index)
    }
    return sa.data[index], nil
}

func (sa *SafeArray[T]) Set(index int, value T) error {
    if index < 0 || index >= sa.size {
        return fmt.Errorf("index out of bounds: %d", index)
    }
    sa.data[index] = value
    return nil
}

// 类型安全的字符串操作
type SafeString struct {
    data []rune
}

func NewSafeString(s string) *SafeString {
    return &SafeString{
        data: []rune(s),
    }
}

func (ss *SafeString) Substring(start, end int) (*SafeString, error) {
    if start < 0 || end > len(ss.data) || start > end {
        return nil, fmt.Errorf("invalid substring range: %d to %d", start, end)
    }
    
    return &SafeString{
        data: ss.data[start:end],
    }, nil
}

func (ss *SafeString) String() string {
    return string(ss.data)
}
```

## 8.0 实践应用

### 8.1 编译器类型系统

**定义 8.1.1 (编译器类型系统)**
编译器类型系统负责：
1. **类型检查**：验证程序类型正确性
2. **类型推断**：推导表达式类型
3. **类型转换**：自动类型转换
4. **错误报告**：提供类型错误信息

### 8.2 静态分析工具

**定义 8.2.1 (静态分析)**
静态分析工具使用类型系统进行：
1. **代码质量检查**：发现潜在问题
2. **性能分析**：分析程序性能
3. **安全分析**：发现安全漏洞
4. **重构支持**：支持代码重构

### 8.3 总结

类型系统理论为编程语言提供了重要的理论基础，确保程序的正确性和安全性。

**关键要点**：
1. **类型基础**：类型定义和类型环境
2. **类型检查**：静态类型检查算法
3. **类型推断**：自动类型推导
4. **多态性**：参数多态、特设多态、子类型多态
5. **依赖类型**：类型依赖于值
6. **类型安全**：运行时类型安全保证

**下一步工作**：
1. 完善更多类型系统
2. 增加类型优化算法
3. 开发更多实践工具
4. 建立完整的测试体系 