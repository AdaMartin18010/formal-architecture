# 03-类型系统理论：类型安全与类型推导

## 目录

1. [1.0 类型系统基础](#10-类型系统基础)
2. [2.0 类型检查](#20-类型检查)
3. [3.0 类型推导](#30-类型推导)
4. [4.0 多态性](#40-多态性)
5. [5.0 高级类型系统](#50-高级类型系统)

## 1.0 类型系统基础

### 1.1 类型定义

**定义 1.1.1 (类型)**
类型是对值的分类，规定了值的可能操作。

**定义 1.1.2 (类型系统)**
用于定义、检查和推导类型的规则集合。

```rust
#[derive(Debug, Clone, PartialEq)]
pub enum Type {
    Int,
    Bool,
    String,
    Function(Box<Type>, Box<Type>), // 参数类型 -> 返回类型
    Tuple(Vec<Type>),
    List(Box<Type>),
    Unit,
    Variable(String), // 类型变量
}

#[derive(Debug, Clone)]
pub enum TypedExpression {
    Literal(Literal),
    Variable(String),
    BinaryOp(Box<TypedExpression>, Operator, Box<TypedExpression>),
    FunctionCall(Box<TypedExpression>, Vec<TypedExpression>),
    Lambda(String, Box<Type>, Box<TypedExpression>),
    Let(String, Box<TypedExpression>, Box<TypedExpression>),
}

#[derive(Debug, Clone)]
pub enum Literal {
    Int(i32),
    Bool(bool),
    String(String),
}

#[derive(Debug, Clone)]
pub enum Operator {
    Add,
    Subtract,
    Multiply,
    Divide,
    Equal,
    LessThan,
    GreaterThan,
}
```

### 1.2 类型环境

**定义 1.2.1 (类型环境)**
变量名到类型的映射。

```rust
use std::collections::HashMap;

pub struct TypeEnvironment {
    bindings: HashMap<String, Type>,
    parent: Option<Box<TypeEnvironment>>,
}

impl TypeEnvironment {
    pub fn new() -> Self {
        Self {
            bindings: HashMap::new(),
            parent: None,
        }
    }

    pub fn extend(&self, var: String, ty: Type) -> Self {
        let mut new_env = TypeEnvironment::new();
        new_env.bindings = self.bindings.clone();
        new_env.bindings.insert(var, ty);
        new_env.parent = Some(Box::new(self.clone()));
        new_env
    }

    pub fn lookup(&self, var: &str) -> Option<Type> {
        if let Some(ty) = self.bindings.get(var) {
            Some(ty.clone())
        } else if let Some(ref parent) = self.parent {
            parent.lookup(var)
        } else {
            None
        }
    }

    pub fn insert(&mut self, var: String, ty: Type) {
        self.bindings.insert(var, ty);
    }
}

impl Clone for TypeEnvironment {
    fn clone(&self) -> Self {
        Self {
            bindings: self.bindings.clone(),
            parent: self.parent.clone(),
        }
    }
}
```

## 2.0 类型检查

### 2.1 类型检查算法

**定义 2.1.1 (类型检查)**
验证表达式类型正确性的过程。

**定理 2.1.1 (类型安全)**
类型检查通过的表达式在运行时不会产生类型错误。

```rust
pub struct TypeChecker {
    environment: TypeEnvironment,
}

impl TypeChecker {
    pub fn new() -> Self {
        Self {
            environment: TypeEnvironment::new(),
        }
    }

    pub fn check_type(&mut self, expr: &TypedExpression) -> Result<Type, String> {
        match expr {
            TypedExpression::Literal(lit) => match lit {
                Literal::Int(_) => Ok(Type::Int),
                Literal::Bool(_) => Ok(Type::Bool),
                Literal::String(_) => Ok(Type::String),
            },
            TypedExpression::Variable(name) => {
                self.environment.lookup(name)
                    .ok_or_else(|| format!("Undefined variable: {}", name))
            }
            TypedExpression::BinaryOp(left, op, right) => {
                let left_type = self.check_type(left)?;
                let right_type = self.check_type(right)?;
                
                match op {
                    Operator::Add | Operator::Subtract | Operator::Multiply | Operator::Divide => {
                        if left_type == Type::Int && right_type == Type::Int {
                            Ok(Type::Int)
                        } else {
                            Err("Arithmetic operations require integer operands".to_string())
                        }
                    }
                    Operator::Equal | Operator::LessThan | Operator::GreaterThan => {
                        if left_type == right_type {
                            Ok(Type::Bool)
                        } else {
                            Err("Comparison operations require operands of the same type".to_string())
                        }
                    }
                }
            }
            TypedExpression::FunctionCall(func, args) => {
                let func_type = self.check_type(func)?;
                
                if let Type::Function(param_type, return_type) = func_type {
                    if args.len() == 1 {
                        let arg_type = self.check_type(&args[0])?;
                        if arg_type == *param_type {
                            Ok(*return_type)
                        } else {
                            Err("Type mismatch in function call".to_string())
                        }
                    } else {
                        Err("Wrong number of arguments".to_string())
                    }
                } else {
                    Err("Not a function".to_string())
                }
            }
            TypedExpression::Lambda(param, param_type, body) => {
                let new_env = self.environment.extend(param.clone(), *param_type.clone());
                let mut body_checker = TypeChecker { environment: new_env };
                let body_type = body_checker.check_type(body)?;
                
                Ok(Type::Function(param_type.clone(), Box::new(body_type)))
            }
            TypedExpression::Let(var, value, body) => {
                let value_type = self.check_type(value)?;
                let new_env = self.environment.extend(var.clone(), value_type);
                let mut body_checker = TypeChecker { environment: new_env };
                body_checker.check_type(body)
            }
        }
    }
}
```

### 2.2 类型错误处理

**定义 2.2.1 (类型错误)**
违反类型系统规则的错误。

```rust
#[derive(Debug)]
pub enum TypeError {
    UndefinedVariable(String),
    TypeMismatch(Type, Type),
    WrongNumberOfArguments(usize, usize),
    NotAFunction(Type),
    DivisionByZero,
    InvalidOperation(String),
}

impl std::fmt::Display for TypeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TypeError::UndefinedVariable(var) => write!(f, "Undefined variable: {}", var),
            TypeError::TypeMismatch(expected, actual) => {
                write!(f, "Type mismatch: expected {:?}, got {:?}", expected, actual)
            }
            TypeError::WrongNumberOfArguments(expected, actual) => {
                write!(f, "Wrong number of arguments: expected {}, got {}", expected, actual)
            }
            TypeError::NotAFunction(ty) => write!(f, "Not a function: {:?}", ty),
            TypeError::DivisionByZero => write!(f, "Division by zero"),
            TypeError::InvalidOperation(op) => write!(f, "Invalid operation: {}", op),
        }
    }
}

pub struct RobustTypeChecker {
    environment: TypeEnvironment,
    errors: Vec<TypeError>,
}

impl RobustTypeChecker {
    pub fn new() -> Self {
        Self {
            environment: TypeEnvironment::new(),
            errors: Vec::new(),
        }
    }

    pub fn check_type_with_errors(&mut self, expr: &TypedExpression) -> Result<Type, Vec<TypeError>> {
        self.errors.clear();
        match self.check_type_internal(expr) {
            Ok(ty) => Ok(ty),
            Err(_) => Err(self.errors.clone()),
        }
    }

    fn check_type_internal(&mut self, expr: &TypedExpression) -> Result<Type, ()> {
        match expr {
            TypedExpression::Literal(lit) => match lit {
                Literal::Int(_) => Ok(Type::Int),
                Literal::Bool(_) => Ok(Type::Bool),
                Literal::String(_) => Ok(Type::String),
            },
            TypedExpression::Variable(name) => {
                self.environment.lookup(name)
                    .ok_or_else(|| {
                        self.errors.push(TypeError::UndefinedVariable(name.clone()));
                        ()
                    })
            }
            TypedExpression::BinaryOp(left, op, right) => {
                let left_type = self.check_type_internal(left)?;
                let right_type = self.check_type_internal(right)?;
                
                match op {
                    Operator::Add | Operator::Subtract | Operator::Multiply | Operator::Divide => {
                        if left_type == Type::Int && right_type == Type::Int {
                            Ok(Type::Int)
                        } else {
                            self.errors.push(TypeError::TypeMismatch(Type::Int, left_type));
                            self.errors.push(TypeError::TypeMismatch(Type::Int, right_type));
                            Err(())
                        }
                    }
                    _ => {
                        if left_type == right_type {
                            Ok(Type::Bool)
                        } else {
                            self.errors.push(TypeError::TypeMismatch(left_type.clone(), right_type));
                            Err(())
                        }
                    }
                }
            }
            _ => Ok(Type::Unit), // 简化实现
        }
    }
}
```

## 3.0 类型推导

### 3.1 Hindley-Milner算法

**定义 3.1.1 (类型推导)**
自动推断表达式类型的过程。

**定义 3.1.2 (类型变量)**
表示未知类型的占位符。

```rust
use std::collections::HashMap;

#[derive(Debug, Clone, PartialEq)]
pub enum TypeVar {
    Named(String),
    Anonymous(usize),
}

#[derive(Debug, Clone, PartialEq)]
pub enum TypeScheme {
    Mono(Type),
    Poly(String, Box<TypeScheme>),
}

pub struct TypeInferrer {
    next_var: usize,
    substitutions: HashMap<TypeVar, Type>,
}

impl TypeInferrer {
    pub fn new() -> Self {
        Self {
            next_var: 0,
            substitutions: HashMap::new(),
        }
    }

    pub fn fresh_var(&mut self) -> TypeVar {
        let var = TypeVar::Anonymous(self.next_var);
        self.next_var += 1;
        var
    }

    pub fn infer_type(&mut self, expr: &TypedExpression, env: &TypeEnvironment) -> Result<Type, String> {
        match expr {
            TypedExpression::Literal(lit) => match lit {
                Literal::Int(_) => Ok(Type::Int),
                Literal::Bool(_) => Ok(Type::Bool),
                Literal::String(_) => Ok(Type::String),
            },
            TypedExpression::Variable(name) => {
                if let Some(scheme) = env.lookup(name) {
                    self.instantiate(&scheme)
                } else {
                    Err(format!("Undefined variable: {}", name))
                }
            }
            TypedExpression::Lambda(param, param_type, body) => {
                let param_var = self.fresh_var();
                let new_env = env.extend(param.clone(), Type::Variable(param_var.clone()));
                let body_type = self.infer_type(body, &new_env)?;
                
                Ok(Type::Function(
                    Box::new(Type::Variable(param_var)),
                    Box::new(body_type)
                ))
            }
            TypedExpression::FunctionCall(func, args) => {
                let func_type = self.infer_type(func, env)?;
                let arg_type = if args.len() == 1 {
                    self.infer_type(&args[0], env)?
                } else {
                    return Err("Multi-argument functions not supported".to_string());
                };
                
                let result_var = self.fresh_var();
                let expected_func_type = Type::Function(
                    Box::new(arg_type.clone()),
                    Box::new(Type::Variable(result_var.clone()))
                );
                
                self.unify(&func_type, &expected_func_type)?;
                Ok(Type::Variable(result_var))
            }
            _ => Ok(Type::Unit), // 简化实现
        }
    }

    fn instantiate(&mut self, scheme: &Type) -> Result<Type, String> {
        // 简化实现：直接返回类型
        Ok(scheme.clone())
    }

    pub fn unify(&mut self, t1: &Type, t2: &Type) -> Result<(), String> {
        match (t1, t2) {
            (Type::Int, Type::Int) | (Type::Bool, Type::Bool) | (Type::String, Type::String) => {
                Ok(())
            }
            (Type::Function(p1, r1), Type::Function(p2, r2)) => {
                self.unify(p1, p2)?;
                self.unify(r1, r2)
            }
            (Type::Variable(var), ty) | (ty, Type::Variable(var)) => {
                self.substitutions.insert(var.clone(), ty.clone());
                Ok(())
            }
            _ => Err("Cannot unify types".to_string()),
        }
    }
}
```

### 3.2 约束求解

**定义 3.2.1 (类型约束)**
类型变量之间的等式关系。

```rust
#[derive(Debug, Clone)]
pub struct TypeConstraint {
    left: Type,
    right: Type,
}

pub struct ConstraintSolver {
    constraints: Vec<TypeConstraint>,
    substitutions: HashMap<TypeVar, Type>,
}

impl ConstraintSolver {
    pub fn new() -> Self {
        Self {
            constraints: Vec::new(),
            substitutions: HashMap::new(),
        }
    }

    pub fn add_constraint(&mut self, constraint: TypeConstraint) {
        self.constraints.push(constraint);
    }

    pub fn solve(&mut self) -> Result<HashMap<TypeVar, Type>, String> {
        while !self.constraints.is_empty() {
            let constraint = self.constraints.remove(0);
            self.solve_constraint(constraint)?;
        }
        Ok(self.substitutions.clone())
    }

    fn solve_constraint(&mut self, constraint: TypeConstraint) -> Result<(), String> {
        match (constraint.left, constraint.right) {
            (Type::Int, Type::Int) | (Type::Bool, Type::Bool) | (Type::String, Type::String) => {
                Ok(())
            }
            (Type::Function(p1, r1), Type::Function(p2, r2)) => {
                self.constraints.push(TypeConstraint { left: *p1, right: *p2 });
                self.constraints.push(TypeConstraint { left: *r1, right: *r2 });
                Ok(())
            }
            (Type::Variable(var), ty) | (ty, Type::Variable(var)) => {
                self.substitutions.insert(var, ty);
                Ok(())
            }
            _ => Err("Cannot solve constraint".to_string()),
        }
    }
}
```

## 4.0 多态性

### 4.1 参数多态

**定义 4.1.1 (参数多态)**
类型参数化的多态性。

**定义 4.1.2 (泛型)**
参数多态的实现机制。

```rust
// 参数多态实现
pub trait Polymorphic {
    type Output;
    fn apply<T>(&self, input: T) -> Self::Output;
}

pub struct IdentityFunction;

impl Polymorphic for IdentityFunction {
    type Output = String;
    
    fn apply<T>(&self, _input: T) -> Self::Output {
        "Identity applied".to_string()
    }
}

// 泛型数据结构
#[derive(Debug, Clone)]
pub struct GenericList<T> {
    head: Option<T>,
    tail: Option<Box<GenericList<T>>>,
}

impl<T> GenericList<T> {
    pub fn new() -> Self {
        Self {
            head: None,
            tail: None,
        }
    }

    pub fn cons(head: T, tail: GenericList<T>) -> Self {
        Self {
            head: Some(head),
            tail: Some(Box::new(tail)),
        }
    }

    pub fn head(&self) -> Option<&T> {
        self.head.as_ref()
    }

    pub fn tail(&self) -> Option<&GenericList<T>> {
        self.tail.as_ref().map(|t| t.as_ref())
    }
}

// 泛型函数
pub fn generic_map<T, U, F>(list: &GenericList<T>, f: F) -> GenericList<U>
where
    F: Fn(&T) -> U,
{
    match list.head() {
        Some(head) => {
            let new_head = f(head);
            let new_tail = list.tail().map(|tail| generic_map(tail, f));
            GenericList {
                head: Some(new_head),
                tail: new_tail.map(|t| Box::new(t)),
            }
        }
        None => GenericList::new(),
    }
}

// 类型类（Trait）
pub trait Show {
    fn show(&self) -> String;
}

impl Show for i32 {
    fn show(&self) -> String {
        self.to_string()
    }
}

impl Show for String {
    fn show(&self) -> String {
        self.clone()
    }
}

impl<T: Show> Show for GenericList<T> {
    fn show(&self) -> String {
        match self.head() {
            Some(head) => {
                let head_str = head.show();
                let tail_str = self.tail().map(|t| t.show()).unwrap_or_default();
                format!("[{}:{}]", head_str, tail_str)
            }
            None => "[]".to_string(),
        }
    }
}
```

### 4.2 子类型多态

**定义 4.2.1 (子类型)**
类型间的包含关系。

**定义 4.2.2 (协变/逆变)**
类型参数的变化方向。

```rust
// 子类型关系
pub trait Animal {
    fn make_sound(&self) -> String;
    fn get_name(&self) -> &str;
}

pub struct Dog {
    name: String,
}

impl Animal for Dog {
    fn make_sound(&self) -> String {
        "Woof!".to_string()
    }

    fn get_name(&self) -> &str {
        &self.name
    }
}

pub struct Cat {
    name: String,
}

impl Animal for Cat {
    fn make_sound(&self) -> String {
        "Meow!".to_string()
    }

    fn get_name(&self) -> &str {
        &self.name
    }
}

// 协变容器
pub struct CovariantContainer<T> {
    data: T,
}

impl<T> CovariantContainer<T> {
    pub fn new(data: T) -> Self {
        Self { data }
    }

    pub fn get(&self) -> &T {
        &self.data
    }
}

// 逆变函数参数
pub struct ContravariantFunction<Arg, Ret> {
    func: Box<dyn Fn(Arg) -> Ret>,
}

impl<Arg, Ret> ContravariantFunction<Arg, Ret> {
    pub fn new<F>(func: F) -> Self
    where
        F: Fn(Arg) -> Ret + 'static,
    {
        Self {
            func: Box::new(func),
        }
    }

    pub fn call(&self, arg: Arg) -> Ret {
        (self.func)(arg)
    }
}

// 子类型多态使用
pub fn demonstrate_subtyping() {
    let animals: Vec<Box<dyn Animal>> = vec![
        Box::new(Dog { name: "Rex".to_string() }),
        Box::new(Cat { name: "Whiskers".to_string() }),
    ];

    for animal in animals {
        println!("{} says: {}", animal.get_name(), animal.make_sound());
    }
}
```

## 5.0 高级类型系统

### 5.1 依赖类型

**定义 5.1.1 (依赖类型)**
类型依赖于值的类型系统。

```rust
// 依赖类型模拟
pub struct DependentPair<A, B> {
    first: A,
    second: B,
}

impl<A, B> DependentPair<A, B> {
    pub fn new(first: A, second: B) -> Self {
        Self { first, second }
    }

    pub fn first(&self) -> &A {
        &self.first
    }

    pub fn second(&self) -> &B {
        &self.second
    }
}

// 长度索引向量
pub struct Vector<T, const N: usize> {
    data: [T; N],
}

impl<T, const N: usize> Vector<T, N> {
    pub fn new(data: [T; N]) -> Self {
        Self { data }
    }

    pub fn get(&self, index: usize) -> Option<&T> {
        if index < N {
            Some(&self.data[index])
        } else {
            None
        }
    }

    pub fn len(&self) -> usize {
        N
    }
}

// 类型级自然数
pub trait Nat {
    const VALUE: usize;
}

pub struct Zero;
impl Nat for Zero {
    const VALUE: usize = 0;
}

pub struct Succ<N: Nat>;
impl<N: Nat> Nat for Succ<N> {
    const VALUE: usize = N::VALUE + 1;
}

// 类型级加法
pub trait Add<Rhs: Nat> {
    type Output: Nat;
}

impl<Rhs: Nat> Add<Rhs> for Zero {
    type Output = Rhs;
}

impl<N: Nat, Rhs: Nat> Add<Rhs> for Succ<N>
where
    N: Add<Rhs>,
{
    type Output = Succ<<N as Add<Rhs>>::Output>;
}
```

### 5.2 高阶类型

**定义 5.2.1 (高阶类型)**
类型构造子的类型。

```rust
// 高阶类型构造子
pub trait HigherKindedType<A> {
    type Output;
}

// 函子
pub trait Functor<A, B> {
    type Output;
    fn fmap<F>(&self, f: F) -> Self::Output
    where
        F: Fn(&A) -> B;
}

impl<A, B> Functor<A, B> for Option<A> {
    type Output = Option<B>;

    fn fmap<F>(&self, f: F) -> Self::Output
    where
        F: Fn(&A) -> B,
    {
        match self {
            Some(a) => Some(f(a)),
            None => None,
        }
    }
}

impl<A, B> Functor<A, B> for Vec<A> {
    type Output = Vec<B>;

    fn fmap<F>(&self, f: F) -> Self::Output
    where
        F: Fn(&A) -> B,
    {
        self.iter().map(f).collect()
    }
}

// 单子
pub trait Monad<A, B> {
    type Output;
    fn bind<F>(&self, f: F) -> Self::Output
    where
        F: Fn(&A) -> Self::Output;
}

impl<A, B> Monad<A, B> for Option<A> {
    type Output = Option<B>;

    fn bind<F>(&self, f: F) -> Self::Output
    where
        F: Fn(&A) -> Self::Output,
    {
        match self {
            Some(a) => f(a),
            None => None,
        }
    }
}

// 应用函子
pub trait Applicative<A, B> {
    type Output;
    fn apply<F>(&self, f: &dyn Fn(&A) -> B) -> Self::Output;
}

impl<A, B> Applicative<A, B> for Option<A> {
    type Output = Option<B>;

    fn apply<F>(&self, f: &dyn Fn(&A) -> B) -> Self::Output {
        match self {
            Some(a) => Some(f(a)),
            None => None,
        }
    }
}
```

---

## 总结

类型系统理论为编程语言提供了类型安全和类型推导的理论基础，通过类型检查、类型推导、多态性等核心概念，构建了完整的类型系统体系。 