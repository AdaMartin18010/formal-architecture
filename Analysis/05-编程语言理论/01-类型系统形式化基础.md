# 类型系统形式化基础：理论与实践

## 目录

1. [类型系统基本定义](#类型系统基本定义)
2. [简单类型λ演算](#简单类型λ演算)
3. [多态类型系统](#多态类型系统)
4. [依赖类型系统](#依赖类型系统)
5. [线性类型系统](#线性类型系统)
6. [类型推导算法](#类型推导算法)
7. [类型安全与进展](#类型安全与进展)
8. [形式化证明](#形式化证明)

## 1. 类型系统基本定义

### 1.1 基础概念

**定义 1.1.1 (类型)**：
类型 $\tau$ 是值的集合，满足：
$$\tau \subseteq \text{Value}$$

**定义 1.1.2 (类型环境)**：
类型环境 $\Gamma$ 是变量到类型的映射：
$$\Gamma : \text{Var} \rightarrow \text{Type}$$

**定义 1.1.3 (类型判断)**：
类型判断 $\Gamma \vdash e : \tau$ 表示在环境 $\Gamma$ 下，表达式 $e$ 具有类型 $\tau$。

### 1.2 基本类型

**定义 1.2.1 (基本类型)**：
基本类型集合 $\mathcal{B}$ 包含：
- $\text{Bool}$：布尔类型
- $\text{Int}$：整数类型
- $\text{String}$：字符串类型
- $\text{Unit}$：单位类型

**定义 1.2.2 (函数类型)**：
函数类型 $\tau_1 \rightarrow \tau_2$ 表示从类型 $\tau_1$ 到类型 $\tau_2$ 的函数。

**定义 1.2.3 (积类型)**：
积类型 $\tau_1 \times \tau_2$ 表示类型 $\tau_1$ 和 $\tau_2$ 的笛卡尔积。

**定义 1.2.4 (和类型)**：
和类型 $\tau_1 + \tau_2$ 表示类型 $\tau_1$ 或 $\tau_2$ 的联合。

## 2. 简单类型λ演算

### 2.1 语法定义

**定义 2.1.1 (STLC语法)**：
简单类型λ演算的语法：
$$e ::= x \mid \lambda x : \tau. e \mid e_1 e_2 \mid \text{let } x = e_1 \text{ in } e_2$$

**定义 2.1.2 (类型语法)**：
类型语法：
$$\tau ::= \alpha \mid \tau_1 \rightarrow \tau_2 \mid \text{Bool} \mid \text{Int}$$

### 2.2 类型规则

**规则 2.2.1 (变量规则)**：
$$\frac{x : \tau \in \Gamma}{\Gamma \vdash x : \tau}$$

**规则 2.2.2 (抽象规则)**：
$$\frac{\Gamma, x : \tau_1 \vdash e : \tau_2}{\Gamma \vdash \lambda x : \tau_1. e : \tau_1 \rightarrow \tau_2}$$

**规则 2.2.3 (应用规则)**：
$$\frac{\Gamma \vdash e_1 : \tau_1 \rightarrow \tau_2 \quad \Gamma \vdash e_2 : \tau_1}{\Gamma \vdash e_1 e_2 : \tau_2}$$

**规则 2.2.4 (Let规则)**：
$$\frac{\Gamma \vdash e_1 : \tau_1 \quad \Gamma, x : \tau_1 \vdash e_2 : \tau_2}{\Gamma \vdash \text{let } x = e_1 \text{ in } e_2 : \tau_2}$$

### 2.3 语义定义

**定义 2.3.1 (操作语义)**：
操作语义定义程序执行步骤：
$$\frac{e_1 \rightarrow e_1'}{e_1 e_2 \rightarrow e_1' e_2}$$
$$\frac{e_2 \rightarrow e_2'}{v_1 e_2 \rightarrow v_1 e_2'}$$
$$(\lambda x : \tau. e) v \rightarrow e[v/x]$$

## 3. 多态类型系统

### 3.1 Hindley-Milner类型系统

**定义 3.1.1 (多态类型)**：
多态类型 $\forall \alpha. \tau$ 表示对所有类型 $\alpha$，$\tau$ 都成立。

**定义 3.1.2 (类型实例化)**：
类型实例化 $\tau[\sigma/\alpha]$ 表示将类型 $\tau$ 中的 $\alpha$ 替换为 $\sigma$。

**规则 3.1.1 (通用实例化)**：
$$\frac{\Gamma \vdash e : \forall \alpha. \tau}{\Gamma \vdash e : \tau[\sigma/\alpha]}$$

**规则 3.1.2 (通用抽象)**：
$$\frac{\Gamma \vdash e : \tau \quad \alpha \notin \text{FTV}(\Gamma)}{\Gamma \vdash e : \forall \alpha. \tau}$$

### 3.2 类型推导

**定义 3.2.1 (类型推导算法W)**：
算法W计算最一般类型：
$$W(\Gamma, e) = (\tau, S)$$
其中 $\tau$ 是推导出的类型，$S$ 是替换。

**算法 3.2.1 (算法W)**：
```
W(Γ, x) = (Γ(x), ∅)
W(Γ, λx.e) = let (τ, S) = W(Γ ∪ {x:α}, e) in (S(α) → τ, S)
W(Γ, e₁ e₂) = let (τ₁, S₁) = W(Γ, e₁) in
              let (τ₂, S₂) = W(S₁(Γ), e₂) in
              let S₃ = unify(S₂(τ₁), τ₂ → β) in
              (S₃(β), S₃ ∘ S₂ ∘ S₁)
```

## 4. 依赖类型系统

### 4.1 依赖类型基础

**定义 4.1.1 (依赖函数类型)**：
依赖函数类型 $\Pi x : A. B(x)$ 表示对每个 $x : A$，$B(x)$ 是一个类型。

**定义 4.1.2 (依赖积类型)**：
依赖积类型 $\Sigma x : A. B(x)$ 表示存在 $x : A$ 使得 $B(x)$ 成立。

**规则 4.1.1 (依赖抽象)**：
$$\frac{\Gamma, x : A \vdash e : B(x)}{\Gamma \vdash \lambda x. e : \Pi x : A. B(x)}$$

**规则 4.1.2 (依赖应用)**：
$$\frac{\Gamma \vdash e_1 : \Pi x : A. B(x) \quad \Gamma \vdash e_2 : A}{\Gamma \vdash e_1 e_2 : B(e_2)}$$

### 4.2 构造演算

**定义 4.2.1 (构造演算语法)**：
构造演算的语法：
$$e ::= x \mid \lambda x : A. e \mid e_1 e_2 \mid \text{let } x = e_1 \text{ in } e_2 \mid \text{case } e \text{ of } \text{inl}(x) \Rightarrow e_1 \mid \text{inr}(x) \Rightarrow e_2$$

**定义 4.2.2 (类型层次)**：
类型层次：
$$\text{Prop} : \text{Type}_0 : \text{Type}_1 : \cdots$$

## 5. 线性类型系统

### 5.1 线性逻辑

**定义 5.1.1 (线性类型)**：
线性类型 $\tau \multimap \sigma$ 表示线性函数，使用一次后就不能再使用。

**定义 5.1.2 (张量积)**：
张量积 $\tau \otimes \sigma$ 表示同时拥有类型 $\tau$ 和 $\sigma$ 的资源。

**定义 5.1.3 (线性和)**：
线性和 $\tau \oplus \sigma$ 表示拥有类型 $\tau$ 或 $\sigma$ 的资源。

### 5.2 仿射类型系统

**定义 5.2.1 (仿射类型)**：
仿射类型允许最多使用一次，但可以不使用。

**规则 5.2.1 (仿射抽象)**：
$$\frac{\Gamma, x : \tau \vdash e : \sigma}{\Gamma \vdash \lambda x. e : \tau \multimap \sigma}$$

**规则 5.2.2 (仿射应用)**：
$$\frac{\Gamma \vdash e_1 : \tau \multimap \sigma \quad \Gamma \vdash e_2 : \tau}{\Gamma \vdash e_1 e_2 : \sigma}$$

## 6. 类型推导算法

### 6.1 统一算法

**定义 6.1.1 (类型统一)**：
类型统一算法计算最一般替换：
$$\text{unify}(\tau_1, \tau_2) = S$$
其中 $S$ 是最一般替换使得 $S(\tau_1) = S(\tau_2)$。

**算法 6.1.1 (Robinson统一算法)**：
```
unify(α, τ) = if α ∈ FTV(τ) then fail else [τ/α]
unify(τ, α) = unify(α, τ)
unify(τ₁ → τ₂, σ₁ → σ₂) = let S₁ = unify(τ₁, σ₁) in
                           let S₂ = unify(S₁(τ₂), S₁(σ₂)) in
                           S₂ ∘ S₁
unify(τ, τ) = ∅
unify(τ, σ) = fail
```

### 6.2 类型推导

**定义 6.2.1 (类型推导)**：
类型推导算法计算表达式的类型：
$$\text{infer}(\Gamma, e) = \tau$$

**算法 6.2.1 (类型推导)**：
```
infer(Γ, x) = Γ(x)
infer(Γ, λx.e) = let τ = infer(Γ ∪ {x:α}, e) in α → τ
infer(Γ, e₁ e₂) = let τ₁ = infer(Γ, e₁) in
                  let τ₂ = infer(Γ, e₂) in
                  let τ₃ = fresh() in
                  unify(τ₁, τ₂ → τ₃);
                  τ₃
```

## 7. 类型安全与进展

### 7.1 类型安全

**定义 7.1.1 (类型安全)**：
类型系统是类型安全的，如果：
$$\forall e : \text{如果 } \vdash e : \tau \text{ 且 } e \rightarrow e' \text{，则 } \vdash e' : \tau$$

**定理 7.1.1 (类型保持)**：
如果 $\Gamma \vdash e : \tau$ 且 $e \rightarrow e'$，则 $\Gamma \vdash e' : \tau$。

**证明**：
1. 对操作语义规则进行归纳
2. 验证每个规则保持类型
3. 证毕

### 7.2 进展

**定义 7.2.1 (进展)**：
类型系统满足进展，如果：
$$\forall e : \text{如果 } \vdash e : \tau \text{，则 } e \text{ 是值或存在 } e' \text{ 使得 } e \rightarrow e'$$

**定理 7.2.1 (进展定理)**：
如果 $\vdash e : \tau$，则 $e$ 是值或存在 $e'$ 使得 $e \rightarrow e'$。

**证明**：
1. 对类型推导规则进行归纳
2. 对每种情况证明进展
3. 证毕

## 8. 形式化证明

### 8.1 基本定理

**定理 8.1.1 (类型唯一性)**：
在STLC中，如果 $\Gamma \vdash e : \tau_1$ 且 $\Gamma \vdash e : \tau_2$，则 $\tau_1 = \tau_2$。

**证明**：
1. 对表达式结构进行归纳
2. 验证每种情况下的类型唯一性
3. 证毕

**定理 8.1.2 (类型推导完备性)**：
如果 $\Gamma \vdash e : \tau$，则算法W能够推导出类型 $\tau'$ 使得 $\tau'$ 是 $\tau$ 的实例。

**证明**：
1. 对类型推导规则进行归纳
2. 验证算法W的正确性
3. 证毕

### 8.2 高级定理

**定理 8.2.1 (强标准化)**：
在STLC中，所有良类型项都是强标准化的。

**定理 8.2.2 (Church-Rosser)**：
在STLC中，如果 $e \rightarrow^* e_1$ 且 $e \rightarrow^* e_2$，则存在 $e'$ 使得 $e_1 \rightarrow^* e'$ 且 $e_2 \rightarrow^* e'$。

### 8.3 实现验证

```rust
// 类型系统的Rust实现
#[derive(Debug, Clone, PartialEq)]
pub enum Type {
    Bool,
    Int,
    String,
    Unit,
    Var(String),
    Arrow(Box<Type>, Box<Type>),
    Product(Box<Type>, Box<Type>),
    Sum(Box<Type>, Box<Type>),
    ForAll(String, Box<Type>),
    Dependent(Box<Type>, Box<Type>),
}

#[derive(Debug, Clone)]
pub enum Term {
    Var(String),
    Abs(String, Type, Box<Term>),
    App(Box<Term>, Box<Term>),
    Let(String, Box<Term>, Box<Term>),
    True,
    False,
    Zero,
    Succ(Box<Term>),
    Pred(Box<Term>),
    IsZero(Box<Term>),
}

pub struct TypeContext {
    bindings: HashMap<String, Type>,
}

impl TypeContext {
    pub fn new() -> Self {
        Self {
            bindings: HashMap::new(),
        }
    }
    
    pub fn extend(&self, var: String, ty: Type) -> Self {
        let mut new_bindings = self.bindings.clone();
        new_bindings.insert(var, ty);
        Self { bindings: new_bindings }
    }
    
    pub fn lookup(&self, var: &str) -> Option<&Type> {
        self.bindings.get(var)
    }
}

pub trait TypeChecker {
    fn type_check(&self, ctx: &TypeContext, term: &Term) -> Result<Type, String>;
}

pub struct STLCTypeChecker;

impl TypeChecker for STLCTypeChecker {
    fn type_check(&self, ctx: &TypeContext, term: &Term) -> Result<Type, String> {
        match term {
            Term::Var(x) => {
                ctx.lookup(x)
                    .cloned()
                    .ok_or_else(|| format!("Unbound variable: {}", x))
            }
            
            Term::Abs(x, ty, body) => {
                let new_ctx = ctx.extend(x.clone(), ty.clone());
                let body_ty = self.type_check(&new_ctx, body)?;
                Ok(Type::Arrow(Box::new(ty.clone()), Box::new(body_ty)))
            }
            
            Term::App(fun, arg) => {
                let fun_ty = self.type_check(ctx, fun)?;
                let arg_ty = self.type_check(ctx, arg)?;
                
                match fun_ty {
                    Type::Arrow(param_ty, return_ty) => {
                        if *param_ty == arg_ty {
                            Ok(*return_ty)
                        } else {
                            Err(format!("Type mismatch: expected {:?}, got {:?}", param_ty, arg_ty))
                        }
                    }
                    _ => Err("Expected function type".to_string()),
                }
            }
            
            Term::Let(x, value, body) => {
                let value_ty = self.type_check(ctx, value)?;
                let new_ctx = ctx.extend(x.clone(), value_ty);
                self.type_check(&new_ctx, body)
            }
            
            Term::True | Term::False => Ok(Type::Bool),
            
            Term::Zero => Ok(Type::Int),
            
            Term::Succ(t) | Term::Pred(t) => {
                let t_ty = self.type_check(ctx, t)?;
                if t_ty == Type::Int {
                    Ok(Type::Int)
                } else {
                    Err("Expected Int type".to_string())
                }
            }
            
            Term::IsZero(t) => {
                let t_ty = self.type_check(ctx, t)?;
                if t_ty == Type::Int {
                    Ok(Type::Bool)
                } else {
                    Err("Expected Int type".to_string())
                }
            }
        }
    }
}

// 类型推导算法
pub struct TypeInference;

impl TypeInference {
    pub fn infer(ctx: &TypeContext, term: &Term) -> Result<Type, String> {
        let mut constraints = Vec::new();
        let ty = Self::infer_with_constraints(ctx, term, &mut constraints)?;
        
        // 解约束
        let substitution = Self::solve_constraints(&constraints)?;
        Ok(Self::apply_substitution(&substitution, &ty))
    }
    
    fn infer_with_constraints(
        ctx: &TypeContext,
        term: &Term,
        constraints: &mut Vec<(Type, Type)>,
    ) -> Result<Type, String> {
        match term {
            Term::Var(x) => {
                ctx.lookup(x)
                    .cloned()
                    .ok_or_else(|| format!("Unbound variable: {}", x))
            }
            
            Term::Abs(x, ty, body) => {
                let new_ctx = ctx.extend(x.clone(), ty.clone());
                let body_ty = Self::infer_with_constraints(&new_ctx, body, constraints)?;
                Ok(Type::Arrow(Box::new(ty.clone()), Box::new(body_ty)))
            }
            
            Term::App(fun, arg) => {
                let fun_ty = Self::infer_with_constraints(ctx, fun, constraints)?;
                let arg_ty = Self::infer_with_constraints(ctx, arg, constraints)?;
                let result_ty = Self::fresh_type_var();
                
                constraints.push((fun_ty, Type::Arrow(Box::new(arg_ty), Box::new(result_ty.clone()))));
                Ok(result_ty)
            }
            
            _ => Err("Not implemented".to_string()),
        }
    }
    
    fn fresh_type_var() -> Type {
        static mut COUNTER: u32 = 0;
        unsafe {
            COUNTER += 1;
            Type::Var(format!("α{}", COUNTER))
        }
    }
    
    fn solve_constraints(constraints: &[(Type, Type)]) -> Result<HashMap<String, Type>, String> {
        let mut substitution = HashMap::new();
        
        for (ty1, ty2) in constraints {
            Self::unify(ty1, ty2, &mut substitution)?;
        }
        
        Ok(substitution)
    }
    
    fn unify(ty1: &Type, ty2: &Type, substitution: &mut HashMap<String, Type>) -> Result<(), String> {
        match (ty1, ty2) {
            (Type::Var(x), ty) | (ty, Type::Var(x)) => {
                if Self::occurs_in(x, ty) {
                    return Err("Occurs check failed".to_string());
                }
                substitution.insert(x.clone(), ty.clone());
                Ok(())
            }
            
            (Type::Arrow(a1, b1), Type::Arrow(a2, b2)) => {
                Self::unify(a1, a2, substitution)?;
                Self::unify(b1, b2, substitution)?;
                Ok(())
            }
            
            (ty1, ty2) if ty1 == ty2 => Ok(()),
            
            _ => Err(format!("Cannot unify {:?} and {:?}", ty1, ty2)),
        }
    }
    
    fn occurs_in(var: &str, ty: &Type) -> bool {
        match ty {
            Type::Var(x) => x == var,
            Type::Arrow(a, b) => Self::occurs_in(var, a) || Self::occurs_in(var, b),
            Type::Product(a, b) => Self::occurs_in(var, a) || Self::occurs_in(var, b),
            Type::Sum(a, b) => Self::occurs_in(var, a) || Self::occurs_in(var, b),
            _ => false,
        }
    }
    
    fn apply_substitution(substitution: &HashMap<String, Type>, ty: &Type) -> Type {
        match ty {
            Type::Var(x) => substitution.get(x).cloned().unwrap_or(ty.clone()),
            Type::Arrow(a, b) => Type::Arrow(
                Box::new(Self::apply_substitution(substitution, a)),
                Box::new(Self::apply_substitution(substitution, b)),
            ),
            Type::Product(a, b) => Type::Product(
                Box::new(Self::apply_substitution(substitution, a)),
                Box::new(Self::apply_substitution(substitution, b)),
            ),
            Type::Sum(a, b) => Type::Sum(
                Box::new(Self::apply_substitution(substitution, a)),
                Box::new(Self::apply_substitution(substitution, b)),
            ),
            _ => ty.clone(),
        }
    }
}
```

这种类型系统形式化框架为编程语言设计、类型检查器实现、程序验证等领域提供了严格的理论基础。 