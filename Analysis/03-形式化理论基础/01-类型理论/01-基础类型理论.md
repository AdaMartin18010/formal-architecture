# 01-基础类型理论

## 1. 概述

基础类型理论是形式化架构的核心理论之一，为程序正确性提供形式化保证。本文档介绍基础类型理论的核心概念、公理系统和应用。

## 2. 基本概念

### 2.1 类型系统基础

**定义 2.1 (类型上下文)**
类型上下文 $\Gamma$ 是变量到类型的映射：
$$\Gamma : \text{Var} \rightarrow \text{Type}$$

**定义 2.2 (类型判断)**
类型判断形如 $\Gamma \vdash e : \tau$，表示在上下文 $\Gamma$ 中，表达式 $e$ 具有类型 $\tau$。

**公理 2.1 (变量规则)**
$$\frac{x : \tau \in \Gamma}{\Gamma \vdash x : \tau}$$

**公理 2.2 (函数类型)**
$$\frac{\Gamma, x : \tau_1 \vdash e : \tau_2}{\Gamma \vdash \lambda x.e : \tau_1 \rightarrow \tau_2}$$

**公理 2.3 (函数应用)**
$$\frac{\Gamma \vdash e_1 : \tau_1 \rightarrow \tau_2 \quad \Gamma \vdash e_2 : \tau_1}{\Gamma \vdash e_1 e_2 : \tau_2}$$

### 2.2 类型安全性

**定理 2.1 (类型保持性 - Type Preservation)**
如果 $\Gamma \vdash e : \tau$ 且 $e \rightarrow e'$，则 $\Gamma \vdash e' : \tau$。

**证明：** 通过结构归纳法证明。对于每个归约规则，需要证明类型在归约后保持不变。

**定理 2.2 (进展性 - Progress)**
如果 $\emptyset \vdash e : \tau$，则要么 $e$ 是值，要么存在 $e'$ 使得 $e \rightarrow e'$。

**证明：** 通过结构归纳法证明。对于每个语法构造，证明要么是值，要么可以继续归约。

## 3. 高级类型系统

### 3.1 参数多态性

**定义 3.1 (全称类型)**
$$\frac{\Gamma, \alpha \vdash e : \tau}{\Gamma \vdash \Lambda \alpha.e : \forall \alpha.\tau}$$

**定义 3.2 (类型实例化)**
$$\frac{\Gamma \vdash e : \forall \alpha.\tau}{\Gamma \vdash e[\tau'] : \tau[\alpha \mapsto \tau']}$$

### 3.2 存在类型

**定义 3.3 (存在类型引入)**
$$\frac{\Gamma \vdash e : \tau[\alpha \mapsto \tau']}{\Gamma \vdash \text{pack } \tau', e \text{ as } \exists \alpha.\tau : \exists \alpha.\tau}$$

**定义 3.4 (存在类型消除)**
$$\frac{\Gamma \vdash e_1 : \exists \alpha.\tau \quad \Gamma, \alpha, x : \tau \vdash e_2 : \tau'}{\Gamma \vdash \text{unpack } \alpha, x = e_1 \text{ in } e_2 : \tau'}$$

## 4. 类型推断算法

### 4.1 Hindley-Milner 类型系统

**算法 4.1 (Robinson's Unification)**

```haskell
unify :: Type -> Type -> Substitution
unify (TVar a) t = if a `elem` ftv t then fail else [(a, t)]
unify t (TVar a) = unify (TVar a) t
unify (TArrow t1 t2) (TArrow t1' t2') = 
  let s1 = unify t1 t1'
      s2 = unify (apply s1 t2) (apply s1 t2')
  in compose s2 s1
unify (TCon a) (TCon b) = if a == b then [] else fail
```

**定理 4.1 (算法 W 的正确性)**
如果算法 W 成功，则返回的替换是最一般的一致替换。

## 5. 类型系统的语义

### 5.1 指称语义

**定义 5.1 (类型解释)**
$$\llbracket \tau \rrbracket_\rho = \text{语义域}$$

**定义 5.2 (表达式解释)**
$$\llbracket e \rrbracket_{\rho,\sigma} : \llbracket \tau \rrbracket_\rho$$

### 5.2 操作语义

**定义 5.3 (小步语义)**
$$e \rightarrow e'$$

**定义 5.4 (大步语义)**
$$e \Downarrow v$$

## 6. 类型系统的扩展

### 6.1 依赖类型

**定义 6.1 (Π类型)**
$$\frac{\Gamma, x : A \vdash B : \text{Type}}{\Gamma \vdash \Pi x : A.B : \text{Type}}$$

**定义 6.2 (Σ类型)**
$$\frac{\Gamma \vdash A : \text{Type} \quad \Gamma, x : A \vdash B : \text{Type}}{\Gamma \vdash \Sigma x : A.B : \text{Type}}$$

### 6.2 高阶类型

**定义 6.3 (类型构造子)**
$$\frac{\Gamma \vdash F : \text{Type} \rightarrow \text{Type} \quad \Gamma \vdash A : \text{Type}}{\Gamma \vdash F A : \text{Type}}$$

## 7. 类型系统的元理论

### 7.1 强正规化

**定理 7.1 (强正规化)**
在强类型系统中，所有良类型的项都是强正规化的。

### 7.2 一致性

**定理 7.2 (类型系统一致性)**
如果 $\Gamma \vdash e : \tau$，则 $e$ 不会产生类型错误。

## 8. 实际应用

### 8.1 编译器中的类型检查

**算法 8.1 (类型检查器)**

```haskell
typeCheck :: Context -> Expr -> Either TypeError Type
typeCheck ctx (Var x) = case lookup x ctx of
  Just t -> Right t
  Nothing -> Left (UnboundVariable x)
typeCheck ctx (App e1 e2) = do
  t1 <- typeCheck ctx e1
  t2 <- typeCheck ctx e2
  case t1 of
    TArrow t1' t2' | t1' == t2 -> Right t2'
    _ -> Left TypeMismatch
```

### 8.2 类型安全的编程实践

- 利用类型系统捕获运行时错误
- 通过类型抽象实现模块化
- 使用类型类实现多态性

## 9. 实现示例

### 9.1 Rust实现

```rust
// 类型系统的基本结构
#[derive(Debug, Clone, PartialEq)]
enum Type {
    Int,
    Bool,
    Function(Box<Type>, Box<Type>),
    Variable(String),
    ForAll(String, Box<Type>),
    Exists(String, Box<Type>),
}

#[derive(Debug, Clone)]
enum Expr {
    Var(String),
    Int(i32),
    Bool(bool),
    Lambda(String, Box<Expr>),
    App(Box<Expr>, Box<Expr>),
    TypeLambda(String, Box<Expr>),
    TypeApp(Box<Expr>, Type),
}

struct TypeChecker {
    context: HashMap<String, Type>,
    type_context: HashSet<String>,
}

impl TypeChecker {
    fn new() -> Self {
        Self {
            context: HashMap::new(),
            type_context: HashSet::new(),
        }
    }
    
    fn type_check(&mut self, expr: &Expr) -> Result<Type, String> {
        match expr {
            Expr::Var(name) => {
                self.context.get(name)
                    .cloned()
                    .ok_or_else(|| format!("Unbound variable: {}", name))
            }
            Expr::Int(_) => Ok(Type::Int),
            Expr::Bool(_) => Ok(Type::Bool),
            Expr::Lambda(param, body) => {
                // 简化的实现，假设参数类型为Int
                let param_type = Type::Int;
                self.context.insert(param.clone(), param_type.clone());
                let body_type = self.type_check(body)?;
                self.context.remove(param);
                Ok(Type::Function(Box::new(param_type), Box::new(body_type)))
            }
            Expr::App(func, arg) => {
                let func_type = self.type_check(func)?;
                let arg_type = self.type_check(arg)?;
                match func_type {
                    Type::Function(input, output) => {
                        if *input == arg_type {
                            Ok(*output)
                        } else {
                            Err("Type mismatch".to_string())
                        }
                    }
                    _ => Err("Not a function".to_string()),
                }
            }
            Expr::TypeLambda(param, body) => {
                self.type_context.insert(param.clone());
                let body_type = self.type_check(body)?;
                self.type_context.remove(param);
                Ok(Type::ForAll(param.clone(), Box::new(body_type)))
            }
            Expr::TypeApp(expr, type_arg) => {
                let expr_type = self.type_check(expr)?;
                match expr_type {
                    Type::ForAll(param, body) => {
                        // 简化的类型替换
                        Ok(*body)
                    }
                    _ => Err("Not a polymorphic type".to_string()),
                }
            }
        }
    }
}
```

### 9.2 Go实现

```go
// 类型系统的基本结构
type Type interface {
    String() string
    IsSubtypeOf(other Type) bool
}

type BasicType struct {
    Name string
}

func (bt BasicType) String() string {
    return bt.Name
}

func (bt BasicType) IsSubtypeOf(other Type) bool {
    return bt.String() == other.String()
}

type FunctionType struct {
    Domain   Type
    Codomain Type
}

func (ft FunctionType) String() string {
    return fmt.Sprintf("(%s -> %s)", ft.Domain.String(), ft.Codomain.String())
}

func (ft FunctionType) IsSubtypeOf(other Type) bool {
    if otherFunc, ok := other.(FunctionType); ok {
        return ft.Domain.IsSubtypeOf(otherFunc.Domain) &&
               otherFunc.Codomain.IsSubtypeOf(ft.Codomain)
    }
    return false
}

type ForAllType struct {
    TypeVar  string
    Body     Type
}

func (ft ForAllType) String() string {
    return fmt.Sprintf("∀%s.%s", ft.TypeVar, ft.Body.String())
}

func (ft ForAllType) IsSubtypeOf(other Type) bool {
    if otherForAll, ok := other.(ForAllType); ok {
        return ft.TypeVar == otherForAll.TypeVar &&
               ft.Body.IsSubtypeOf(otherForAll.Body)
    }
    return false
}

// 类型检查器
type TypeChecker struct {
    context      map[string]Type
    typeContext  map[string]bool
}

func NewTypeChecker() *TypeChecker {
    return &TypeChecker{
        context:     make(map[string]Type),
        typeContext: make(map[string]bool),
    }
}

func (tc *TypeChecker) AddVariable(name string, typ Type) {
    tc.context[name] = typ
}

func (tc *TypeChecker) AddTypeVariable(name string) {
    tc.typeContext[name] = true
}

func (tc *TypeChecker) GetType(name string) (Type, bool) {
    typ, exists := tc.context[name]
    return typ, exists
}

func (tc *TypeChecker) IsTypeVariable(name string) bool {
    return tc.typeContext[name]
}
```

## 10. 结论

基础类型理论为软件架构提供了重要的理论基础：

1. **类型安全**: 在编译时捕获大量运行时错误
2. **抽象能力**: 通过类型系统实现抽象
3. **模块化**: 支持模块化设计和开发
4. **形式化**: 提供严格的形式化保证

通过基础类型理论，我们可以：
- 设计更安全的编程语言
- 实现更可靠的编译器
- 开发更健壮的软件系统
- 建立更严格的程序验证方法

## 参考文献

1. Pierce, B. C. (2002). Types and Programming Languages.
2. Reynolds, J. C. (1983). Types, abstraction and parametric polymorphism.
3. Martin-Löf, P. (1984). Intuitionistic type theory.
4. Girard, J. Y. (1987). Linear logic.
5. Milner, R. (1978). A theory of type polymorphism in programming.
6. Hindley, J. R. (1969). The principal type-scheme of an object in combinatory logic.
7. Damas, L., & Milner, R. (1982). Principal type-schemes for functional programs.
8. Cardelli, L., & Wegner, P. (1985). On understanding types, data abstraction, and polymorphism.
9. Harper, R. (2016). Practical foundations for programming languages.
10. Pierce, B. C. (2004). Advanced topics in types and programming languages. 