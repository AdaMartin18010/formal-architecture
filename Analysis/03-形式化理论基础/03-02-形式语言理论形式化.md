# 03-02 形式语言理论形式化

## 目录

1. [概述](#1-概述)
2. [形式语言基础](#2-形式语言基础)
3. [自动机理论](#3-自动机理论)
4. [文法理论](#4-文法理论)
5. [计算复杂性](#5-计算复杂性)
6. [语言层次结构](#6-语言层次结构)
7. [形式语言与类型理论](#7-形式语言与类型理论)
8. [应用实例](#8-应用实例)

## 1. 概述

本文档建立形式语言理论的严格形式化体系，通过数学方法将形式语言概念进行公理化处理。我们建立语言、自动机、文法的形式化模型，为计算机科学、语言学、人工智能等领域提供理论基础。

### 1.1 形式语言空间定义

**定义 1.1.1 (形式语言空间)**
形式语言空间 $\mathcal{L} = (A_L, \Sigma_L, \Phi_L, \vdash_L, \models_L, \mathcal{I}_L)$，其中：

- $A_L = \{\text{语言}, \text{自动机}, \text{文法}, \text{计算}, \text{复杂性}\}$
- $\Sigma_L$ 包含形式语言概念的形成规则
- $\Phi_L$ 包含形式语言基础公理
- $\vdash_L$ 是形式语言推导关系
- $\models_L$ 是形式语言语义关系
- $\mathcal{I}_L$ 是形式语言解释函数

### 1.2 形式化原则

1. **公理化原则**：所有概念都基于明确的公理系统
2. **形式化原则**：使用严格的数学符号和逻辑表达
3. **层次性原则**：建立语言的层次结构
4. **计算性原则**：强调计算模型和算法
5. **应用性原则**：注重实际应用和实现

## 2. 形式语言基础

### 2.1 基本定义

**定义 2.1.1 (字母表)**
字母表 $\Sigma$ 是有限符号集合：
$$\Sigma = \{a_1, a_2, \ldots, a_n\}$$

**定义 2.1.2 (字符串)**
字符串 $w$ 是字母表 $\Sigma$ 上符号的有限序列：
$$w = a_1 a_2 \cdots a_n \in \Sigma^*$$

**定义 2.1.3 (字符串长度)**
字符串 $w$ 的长度 $|w|$ 定义为：
$$|w| = \begin{cases}
0 & \text{if } w = \epsilon \\
n & \text{if } w = a_1 a_2 \cdots a_n
\end{cases}$$

**定义 2.1.4 (字符串连接)**
字符串 $w_1$ 和 $w_2$ 的连接 $w_1 \cdot w_2$ 定义为：
$$w_1 \cdot w_2 = a_1 a_2 \cdots a_n b_1 b_2 \cdots b_m$$

**公理 2.1.1 (连接结合律)**
$$\forall w_1, w_2, w_3: (w_1 \cdot w_2) \cdot w_3 = w_1 \cdot (w_2 \cdot w_3)$$

**公理 2.1.2 (空字符串单位元)**
$$\forall w: \epsilon \cdot w = w \cdot \epsilon = w$$

### 2.2 语言定义

**定义 2.2.1 (形式语言)**
形式语言 $L$ 是字母表 $\Sigma$ 上字符串的集合：
$$L \subseteq \Sigma^*$$

**定义 2.2.2 (语言运算)**
基本语言运算定义为：

1. **并集**：$L_1 \cup L_2 = \{w: w \in L_1 \lor w \in L_2\}$
2. **交集**：$L_1 \cap L_2 = \{w: w \in L_1 \land w \in L_2\}$
3. **补集**：$\overline{L} = \Sigma^* \setminus L$
4. **连接**：$L_1 \cdot L_2 = \{w_1 \cdot w_2: w_1 \in L_1 \land w_2 \in L_2\}$
5. **克林闭包**：$L^* = \bigcup_{i=0}^{\infty} L^i$

**公理 2.2.1 (语言运算性质)**
$$\forall L_1, L_2, L_3: (L_1 \cdot L_2) \cdot L_3 = L_1 \cdot (L_2 \cdot L_3)$$

**公理 2.2.2 (克林闭包性质)**
$$L^* = \{\epsilon\} \cup L \cdot L^*$$

### 2.3 语言关系

**定义 2.3.1 (语言包含)**
语言 $L_1$ 包含于语言 $L_2$，如果：
$$L_1 \subseteq L_2 \Leftrightarrow \forall w: w \in L_1 \Rightarrow w \in L_2$$

**定义 2.3.2 (语言相等)**
语言 $L_1$ 等于语言 $L_2$，如果：
$$L_1 = L_2 \Leftrightarrow L_1 \subseteq L_2 \land L_2 \subseteq L_1$$

**定义 2.3.3 (语言同构)**
语言 $L_1$ 和 $L_2$ 是同构的，如果存在双射 $f: \Sigma_1^* \rightarrow \Sigma_2^*$ 使得：
$$f(L_1) = L_2$$

## 3. 自动机理论

### 3.1 有限自动机

**定义 3.1.1 (有限自动机)**
有限自动机 $M$ 是一个五元组：
$$M = (Q, \Sigma, \delta, q_0, F)$$

其中：
- $Q$ 是有限状态集合
- $\Sigma$ 是输入字母表
- $\delta: Q \times \Sigma \rightarrow Q$ 是转移函数
- $q_0 \in Q$ 是初始状态
- $F \subseteq Q$ 是接受状态集合

**定义 3.1.2 (扩展转移函数)**
扩展转移函数 $\delta^*: Q \times \Sigma^* \rightarrow Q$ 定义为：
$$\delta^*(q, \epsilon) = q$$
$$\delta^*(q, wa) = \delta(\delta^*(q, w), a)$$

**定义 3.1.3 (语言接受)**
自动机 $M$ 接受语言 $L(M)$：
$$L(M) = \{w \in \Sigma^*: \delta^*(q_0, w) \in F\}$$

**定理 3.1.1 (有限自动机确定性)**
有限自动机是确定性的，如果：
$$\forall q \in Q, a \in \Sigma: |\delta(q, a)| = 1$$

### 3.2 非确定性自动机

**定义 3.2.1 (非确定性有限自动机)**
非确定性有限自动机 $N$ 是一个五元组：
$$N = (Q, \Sigma, \delta, q_0, F)$$

其中转移函数 $\delta: Q \times \Sigma \rightarrow 2^Q$ 返回状态集合。

**定义 3.2.2 (扩展转移函数)**
扩展转移函数 $\delta^*: Q \times \Sigma^* \rightarrow 2^Q$ 定义为：
$$\delta^*(q, \epsilon) = \{q\}$$
$$\delta^*(q, wa) = \bigcup_{p \in \delta^*(q, w)} \delta(p, a)$$

**定义 3.2.3 (语言接受)**
非确定性自动机 $N$ 接受语言 $L(N)$：
$$L(N) = \{w \in \Sigma^*: \delta^*(q_0, w) \cap F \neq \emptyset\}$$

**定理 3.2.1 (NFA与DFA等价性)**
对于任意非确定性有限自动机 $N$，存在确定性有限自动机 $M$ 使得 $L(N) = L(M)$。

**证明：** 通过子集构造法：
1. 构造状态集合 $Q' = 2^Q$
2. 构造转移函数 $\delta'(S, a) = \bigcup_{q \in S} \delta(q, a)$
3. 构造初始状态 $q_0' = \{q_0\}$
4. 构造接受状态 $F' = \{S: S \cap F \neq \emptyset\}$

### 3.3 下推自动机

**定义 3.3.1 (下推自动机)**
下推自动机 $P$ 是一个七元组：
$$P = (Q, \Sigma, \Gamma, \delta, q_0, Z_0, F)$$

其中：
- $Q$ 是有限状态集合
- $\Sigma$ 是输入字母表
- $\Gamma$ 是栈字母表
- $\delta: Q \times \Sigma \times \Gamma \rightarrow 2^{Q \times \Gamma^*}$ 是转移函数
- $q_0 \in Q$ 是初始状态
- $Z_0 \in \Gamma$ 是初始栈符号
- $F \subseteq Q$ 是接受状态集合

**定义 3.3.2 (配置)**
配置 $(q, w, \gamma)$ 表示：
- $q$ 是当前状态
- $w$ 是剩余输入字符串
- $\gamma$ 是栈内容

**定义 3.3.3 (转移关系)**
转移关系 $\vdash$ 定义为：
$$(q, aw, A\gamma) \vdash (p, w, \beta\gamma) \text{ if } (p, \beta) \in \delta(q, a, A)$$

**定义 3.3.4 (语言接受)**
下推自动机 $P$ 接受语言 $L(P)$：
$$L(P) = \{w \in \Sigma^*: (q_0, w, Z_0) \vdash^* (q, \epsilon, \gamma) \text{ for some } q \in F\}$$

### 3.4 图灵机

**定义 3.4.1 (图灵机)**
图灵机 $T$ 是一个七元组：
$$T = (Q, \Sigma, \Gamma, \delta, q_0, B, F)$$

其中：
- $Q$ 是有限状态集合
- $\Sigma$ 是输入字母表
- $\Gamma$ 是磁带字母表
- $\delta: Q \times \Gamma \rightarrow Q \times \Gamma \times \{L, R\}$ 是转移函数
- $q_0 \in Q$ 是初始状态
- $B \in \Gamma$ 是空白符号
- $F \subseteq Q$ 是接受状态集合

**定义 3.4.2 (配置)**
配置 $(q, \alpha, i)$ 表示：
- $q$ 是当前状态
- $\alpha$ 是磁带内容
- $i$ 是读写头位置

**定义 3.4.3 (转移关系)**
转移关系 $\vdash$ 定义为：
$$(q, \alpha, i) \vdash (p, \beta, j) \text{ if } \delta(q, \alpha_i) = (p, b, D)$$

**定义 3.4.4 (语言接受)**
图灵机 $T$ 接受语言 $L(T)$：
$$L(T) = \{w \in \Sigma^*: (q_0, w, 0) \vdash^* (q, \alpha, i) \text{ for some } q \in F\}$$

## 4. 文法理论

### 4.1 上下文无关文法

**定义 4.1.1 (上下文无关文法)**
上下文无关文法 $G$ 是一个四元组：
$$G = (V, \Sigma, P, S)$$

其中：
- $V$ 是非终结符集合
- $\Sigma$ 是终结符集合
- $P$ 是产生式集合
- $S \in V$ 是开始符号

**定义 4.1.2 (产生式)**
产生式 $A \rightarrow \alpha$ 表示：
- $A \in V$ 是非终结符
- $\alpha \in (V \cup \Sigma)^*$ 是字符串

**定义 4.1.3 (推导)**
推导关系 $\Rightarrow$ 定义为：
$$\beta A \gamma \Rightarrow \beta \alpha \gamma \text{ if } A \rightarrow \alpha \in P$$

**定义 4.1.4 (语言生成)**
文法 $G$ 生成语言 $L(G)$：
$$L(G) = \{w \in \Sigma^*: S \Rightarrow^* w\}$$

**定理 4.1.1 (CFG与PDA等价性)**
对于任意上下文无关文法 $G$，存在下推自动机 $P$ 使得 $L(G) = L(P)$。

### 4.2 正则文法

**定义 4.2.1 (正则文法)**
正则文法 $G$ 是特殊的上下文无关文法，其中所有产生式都是右线性或左线性：

**右线性文法**：
$$A \rightarrow aB \text{ or } A \rightarrow a$$

**左线性文法**：
$$A \rightarrow Ba \text{ or } A \rightarrow a$$

**定理 4.2.1 (正则文法与FA等价性)**
对于任意正则文法 $G$，存在有限自动机 $M$ 使得 $L(G) = L(M)$。

### 4.3 上下文有关文法

**定义 4.3.1 (上下文有关文法)**
上下文有关文法 $G$ 是一个四元组：
$$G = (V, \Sigma, P, S)$$

其中产生式形式为：
$$\alpha A \beta \rightarrow \alpha \gamma \beta$$

其中：
- $A \in V$ 是非终结符
- $\alpha, \beta, \gamma \in (V \cup \Sigma)^*$
- $|\gamma| \geq 1$

**定理 4.3.1 (CSG与线性有界自动机等价性)**
对于任意上下文有关文法 $G$，存在线性有界自动机 $M$ 使得 $L(G) = L(M)$。

## 5. 计算复杂性

### 5.1 时间复杂性

**定义 5.1.1 (时间复杂性)**
图灵机 $M$ 的时间复杂性 $T_M(n)$ 定义为：
$$T_M(n) = \max\{t: M \text{ accepts } w \text{ in } t \text{ steps}, |w| = n\}$$

**定义 5.1.2 (时间复杂性类)**
时间复杂性类定义为：
$$\text{TIME}(f(n)) = \{L: \exists M: L(M) = L \land T_M(n) = O(f(n))\}$$

**定义 5.1.3 (P类)**
$$\text{P} = \bigcup_{k \geq 0} \text{TIME}(n^k)$$

**定义 5.1.4 (NP类)**
$$\text{NP} = \{L: \exists M: L(M) = L \land T_M(n) = O(n^k) \text{ for some } k\}$$

### 5.2 空间复杂性

**定义 5.2.1 (空间复杂性)**
图灵机 $M$ 的空间复杂性 $S_M(n)$ 定义为：
$$S_M(n) = \max\{s: M \text{ accepts } w \text{ using } s \text{ cells}, |w| = n\}$$

**定义 5.2.2 (空间复杂性类)**
空间复杂性类定义为：
$$\text{SPACE}(f(n)) = \{L: \exists M: L(M) = L \land S_M(n) = O(f(n))\}$$

**定义 5.2.3 (PSPACE类)**
$$\text{PSPACE} = \bigcup_{k \geq 0} \text{SPACE}(n^k)$$

### 5.3 复杂性关系

**定理 5.3.1 (时间空间关系)**
$$\text{TIME}(f(n)) \subseteq \text{SPACE}(f(n))$$

**定理 5.3.2 (P与NP关系)**
$$\text{P} \subseteq \text{NP}$$

**定理 5.3.3 (NP与PSPACE关系)**
$$\text{NP} \subseteq \text{PSPACE}$$

## 6. 语言层次结构

### 6.1 乔姆斯基层次

**定义 6.1.1 (乔姆斯基层次)**
乔姆斯基层次定义了语言的四个层次：

1. **类型0（递归可枚举语言）**：由图灵机接受
2. **类型1（上下文有关语言）**：由上下文有关文法生成
3. **类型2（上下文无关语言）**：由上下文无关文法生成
4. **类型3（正则语言）**：由正则文法生成

**定理 6.1.1 (层次包含关系)**
$$\text{Type 3} \subset \text{Type 2} \subset \text{Type 1} \subset \text{Type 0}$$

### 6.2 语言类性质

**定义 6.2.1 (语言类封闭性)**
语言类 $\mathcal{C}$ 在运算 $\circ$ 下是封闭的，如果：
$$\forall L_1, L_2 \in \mathcal{C}: L_1 \circ L_2 \in \mathcal{C}$$

**定理 6.2.1 (正则语言封闭性)**
正则语言在并集、交集、补集、连接、克林闭包下是封闭的。

**定理 6.2.2 (上下文无关语言封闭性)**
上下文无关语言在并集、连接、克林闭包下是封闭的，但在交集、补集下不封闭。

### 6.3 判定问题

**定义 6.3.1 (成员问题)**
给定语言 $L$ 和字符串 $w$，判定 $w \in L$ 是否成立。

**定义 6.3.2 (空性问题)**
给定语言 $L$，判定 $L = \emptyset$ 是否成立。

**定义 6.3.3 (等价性问题)**
给定语言 $L_1$ 和 $L_2$，判定 $L_1 = L_2$ 是否成立。

**定理 6.3.1 (正则语言判定)**
正则语言的成员问题、空性问题、等价性问题都是可判定的。

**定理 6.3.2 (上下文无关语言判定)**
上下文无关语言的成员问题、空性问题是可判定的，但等价性问题不可判定。

## 7. 形式语言与类型理论

### 7.1 语言类型映射

**定义 7.1.1 (语言类型映射)**
语言类型映射 $\phi: \mathcal{L} \rightarrow \mathcal{T}$ 定义为：

1. **正则语言映射**：$\text{REG} \mapsto \text{Finite Types}$
2. **上下文无关语言映射**：$\text{CFL} \mapsto \text{Algebraic Types}$
3. **上下文有关语言映射**：$\text{CSL} \mapsto \text{Dependent Types}$
4. **递归可枚举语言映射**：$\text{REL} \mapsto \text{Universal Types}$

**定理 7.1.1 (语言类型对应)**
对于任意形式语言 $L$，存在对应的类型 $\tau$ 使得：
$$L \leftrightarrow \tau$$

### 7.2 自动机类型映射

**定义 7.2.1 (自动机类型映射)**
自动机类型映射 $\psi: \mathcal{A} \rightarrow \mathcal{T}$ 定义为：

1. **有限自动机映射**：$\text{FA} \mapsto \text{State Types}$
2. **下推自动机映射**：$\text{PDA} \mapsto \text{Stack Types}$
3. **图灵机映射**：$\text{TM} \mapsto \text{Universal Types}$

**定理 7.2.1 (自动机类型对应)**
对于任意自动机 $M$，存在对应的类型 $\tau$ 使得：
$$M \leftrightarrow \tau$$

### 7.3 文法类型映射

**定义 7.3.1 (文法类型映射)**
文法类型映射 $\chi: \mathcal{G} \rightarrow \mathcal{T}$ 定义为：

1. **正则文法映射**：$\text{RG} \mapsto \text{Regular Types}$
2. **上下文无关文法映射**：$\text{CFG} \mapsto \text{Algebraic Types}$
3. **上下文有关文法映射**：$\text{CSG} \mapsto \text{Dependent Types}$

**定理 7.3.1 (文法类型对应)**
对于任意文法 $G$，存在对应的类型 $\tau$ 使得：
$$G \leftrightarrow \tau$$

## 8. 应用实例

### 8.1 编译器设计

**实例 8.1.1 (词法分析器)**
使用有限自动机实现词法分析器：

```haskell
-- 词法分析器
data Token = Token
  { tokenType :: TokenType
  , tokenValue :: String
  , tokenPosition :: Position
  }

data TokenType = 
    Identifier
  | Number
  | String
  | Operator
  | Keyword
  | Delimiter

-- 有限自动机实现
data Lexer = Lexer
  { states :: [State]
  , transitions :: [Transition]
  , initialState :: State
  , acceptingStates :: [State]
  }

data State = State
  { stateId :: Int
  , stateName :: String
  , isAccepting :: Bool
  , tokenType :: Maybe TokenType
  }

data Transition = Transition
  { fromState :: State
  , input :: Char
  , toState :: State
  }

-- 词法分析
lex :: String -> [Token]
lex input = 
  let tokens = scanTokens input initialState
  in filter isValidToken tokens

-- 扫描标记
scanTokens :: String -> State -> [Token]
scanTokens [] _ = []
scanTokens (c:cs) currentState = 
  let nextState = transition currentState c
      token = if isAccepting nextState 
              then createToken nextState
              else Nothing
      remainingTokens = scanTokens cs nextState
  in case token of
       Just t -> t : remainingTokens
       Nothing -> remainingTokens

-- 状态转移
transition :: State -> Char -> State
transition state c = 
  case find (\t -> fromState t == state && input t == c) transitions of
    Just t -> toState t
    Nothing -> errorState

-- 创建标记
createToken :: State -> Maybe Token
createToken state = 
  case tokenType state of
    Just t -> Just (Token t "" (Position 0 0))
    Nothing -> Nothing
```

### 8.2 语法分析器

**实例 8.2.1 (递归下降解析器)**
使用上下文无关文法实现递归下降解析器：

```haskell
-- 语法分析器
data Parser = Parser
  { grammar :: Grammar
  , tokens :: [Token]
  , currentPosition :: Int
  }

data Grammar = Grammar
  { nonterminals :: [String]
  , terminals :: [String]
  , productions :: [Production]
  , startSymbol :: String
  }

data Production = Production
  { leftSide :: String
  , rightSide :: [String]
  }

-- 递归下降解析
parse :: Grammar -> [Token] -> ParseTree
parse grammar tokens = 
  let parser = Parser grammar tokens 0
  in parseNonterminal parser (startSymbol grammar)

-- 解析非终结符
parseNonterminal :: Parser -> String -> ParseTree
parseNonterminal parser nonterminal = 
  let productions = getProductions parser nonterminal
      tree = tryProductions parser productions
  in tree

-- 尝试产生式
tryProductions :: Parser -> [Production] -> ParseTree
tryProductions parser [] = error "No valid production"
tryProductions parser (p:ps) = 
  case tryProduction parser p of
    Just tree -> tree
    Nothing -> tryProductions parser ps

-- 尝试单个产生式
tryProduction :: Parser -> Production -> Maybe ParseTree
tryProduction parser production = 
  let savedPosition = currentPosition parser
      children = mapM (parseSymbol parser) (rightSide production)
  in case children of
       Just cs -> Just (ParseTree (leftSide production) cs)
       Nothing -> do
         restorePosition parser savedPosition
         Nothing

-- 解析符号
parseSymbol :: Parser -> String -> Maybe ParseTree
parseSymbol parser symbol = 
  if isTerminal symbol
  then parseTerminal parser symbol
  else Just (parseNonterminal parser symbol)

-- 解析终结符
parseTerminal :: Parser -> String -> Maybe ParseTree
parseTerminal parser expected = 
  let currentToken = getCurrentToken parser
  in if tokenType currentToken == expected
     then do
       advance parser
       Just (ParseTree expected [])
     else Nothing
```

### 8.3 正则表达式引擎

**实例 8.3.1 (正则表达式匹配)**
使用有限自动机实现正则表达式引擎：

```rust
// 正则表达式引擎
trait RegexEngine {
    type State;
    type Transition;
    
    fn compile(&self, pattern: &str) -> Result<Automaton, CompileError>;
    fn match_string(&self, automaton: &Automaton, input: &str) -> bool;
}

// 有限自动机
struct Automaton {
    states: Vec<State>,
    transitions: Vec<Transition>,
    initial_state: StateId,
    accepting_states: HashSet<StateId>,
}

struct State {
    id: StateId,
    is_accepting: bool,
    transitions: Vec<Transition>,
}

struct Transition {
    from_state: StateId,
    to_state: StateId,
    condition: TransitionCondition,
}

enum TransitionCondition {
    Character(char),
    Any,
    CharacterClass(Vec<char>),
    Epsilon,
}

// 编译正则表达式
impl RegexEngine for NFAEngine {
    type State = State;
    type Transition = Transition;
    
    fn compile(&self, pattern: &str) -> Result<Automaton, CompileError> {
        let tokens = tokenize(pattern)?;
        let ast = parse_tokens(&tokens)?;
        let nfa = build_nfa(&ast)?;
        let dfa = convert_to_dfa(&nfa)?;
        Ok(dfa)
    }
    
    fn match_string(&self, automaton: &Automaton, input: &str) -> bool {
        let mut current_states = HashSet::new();
        current_states.insert(automaton.initial_state);
        
        for c in input.chars() {
            let mut next_states = HashSet::new();
            for &state_id in &current_states {
                let transitions = get_transitions(automaton, state_id, c);
                next_states.extend(transitions);
            }
            current_states = next_states;
        }
        
        current_states.iter().any(|&id| automaton.accepting_states.contains(&id))
    }
}

// 标记化
fn tokenize(pattern: &str) -> Result<Vec<Token>, CompileError> {
    let mut tokens = Vec::new();
    let mut chars = pattern.chars().peekable();
    
    while let Some(c) = chars.next() {
        match c {
            '(' => tokens.push(Token::LeftParen),
            ')' => tokens.push(Token::RightParen),
            '*' => tokens.push(Token::KleeneStar),
            '+' => tokens.push(Token::Plus),
            '?' => tokens.push(Token::Question),
            '|' => tokens.push(Token::Alternation),
            '.' => tokens.push(Token::Any),
            '[' => {
                let mut chars_in_class = Vec::new();
                while let Some(c) = chars.next() {
                    if c == ']' { break; }
                    chars_in_class.push(c);
                }
                tokens.push(Token::CharacterClass(chars_in_class));
            }
            '\\' => {
                if let Some(escaped) = chars.next() {
                    tokens.push(Token::Character(escaped));
                }
            }
            _ => tokens.push(Token::Character(c)),
        }
    }
    
    Ok(tokens)
}

// 构建NFA
fn build_nfa(ast: &AST) -> Result<Automaton, CompileError> {
    match ast {
        AST::Character(c) => build_character_nfa(*c),
        AST::Concatenation(left, right) => {
            let left_nfa = build_nfa(left)?;
            let right_nfa = build_nfa(right)?;
            concatenate_nfas(left_nfa, right_nfa)
        }
        AST::Alternation(left, right) => {
            let left_nfa = build_nfa(left)?;
            let right_nfa = build_nfa(right)?;
            alternate_nfas(left_nfa, right_nfa)
        }
        AST::KleeneStar(inner) => {
            let inner_nfa = build_nfa(inner)?;
            kleene_star_nfa(inner_nfa)
        }
        AST::Plus(inner) => {
            let inner_nfa = build_nfa(inner)?;
            plus_nfa(inner_nfa)
        }
        AST::Question(inner) => {
            let inner_nfa = build_nfa(inner)?;
            question_nfa(inner_nfa)
        }
    }
}

// 转换为DFA
fn convert_to_dfa(nfa: &Automaton) -> Result<Automaton, CompileError> {
    let mut dfa_states = Vec::new();
    let mut dfa_transitions = Vec::new();
    let mut state_map = HashMap::new();
    
    // 子集构造
    let initial_closure = epsilon_closure(nfa, &[nfa.initial_state]);
    let mut unprocessed_states = vec![initial_closure.clone()];
    let mut processed_states = HashSet::new();
    
    while let Some(current_states) = unprocessed_states.pop() {
        if processed_states.contains(&current_states) {
            continue;
        }
        
        processed_states.insert(current_states.clone());
        let dfa_state_id = dfa_states.len();
        state_map.insert(current_states.clone(), dfa_state_id);
        
        // 为每个输入字符计算转移
        for c in get_alphabet(nfa) {
            let next_states = move_states(nfa, &current_states, c);
            let next_closure = epsilon_closure(nfa, &next_states);
            
            if !next_closure.is_empty() {
                let next_dfa_state_id = if let Some(&id) = state_map.get(&next_closure) {
                    id
                } else {
                    let new_id = dfa_states.len();
                    unprocessed_states.push(next_closure.clone());
                    new_id
                };
                
                dfa_transitions.push(Transition {
                    from_state: dfa_state_id,
                    to_state: next_dfa_state_id,
                    condition: TransitionCondition::Character(c),
                });
            }
        }
    }
    
    // 确定接受状态
    let accepting_states = dfa_states.iter()
        .enumerate()
        .filter_map(|(id, states)| {
            if states.iter().any(|&s| nfa.accepting_states.contains(&s)) {
                Some(id)
            } else {
                None
            }
        })
        .collect();
    
    Ok(Automaton {
        states: dfa_states,
        transitions: dfa_transitions,
        initial_state: 0,
        accepting_states,
    })
}
```

## 总结

本文档建立了形式语言理论的严格形式化体系，主要成果包括：

1. **形式语言基础**：建立了字母表、字符串、语言的基本定义
2. **自动机理论**：建立了有限自动机、下推自动机、图灵机的形式化模型
3. **文法理论**：建立了正则文法、上下文无关文法、上下文有关文法的公理化系统
4. **计算复杂性**：建立了时间复杂性、空间复杂性的形式化理论
5. **语言层次结构**：建立了乔姆斯基层次和语言类性质
6. **形式语言与类型理论**：建立了语言类型映射关系
7. **应用实例**：提供了编译器设计、语法分析器、正则表达式引擎的具体应用

该形式化框架为形式语言理论提供了严格的数学基础，确保了理论体系的严谨性和可扩展性，为计算机科学、语言学、人工智能等领域提供了坚实的理论基础。 