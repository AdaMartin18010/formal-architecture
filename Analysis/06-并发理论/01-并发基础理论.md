# 01-并发理论：并发基础理论

## 目录

1. [1.1 并发理论公理化框架](#11-并发理论公理化框架)
2. [1.2 进程与线程](#12-进程与线程)
3. [1.3 同步原语](#13-同步原语)
4. [1.4 死锁理论](#14-死锁理论)
5. [1.5 竞态条件](#15-竞态条件)
6. [1.6 内存模型](#16-内存模型)
7. [1.7 并发控制](#17-并发控制)
8. [1.8 形式化证明](#18-形式化证明)

## 1.1 并发理论公理化框架

### 1.1.1 基础定义

**定义 1.1.1 (并发系统)**
并发系统是一个五元组 $\mathcal{CS} = (\mathcal{P}, \mathcal{R}, \mathcal{S}, \mathcal{M}, \mathcal{T})$，其中：

- $\mathcal{P}$ 是进程集合 (Processes)
- $\mathcal{R}$ 是资源集合 (Resources)
- $\mathcal{S}$ 是同步原语集合 (Synchronization Primitives)
- $\mathcal{M}$ 是内存模型 (Memory Model)
- $\mathcal{T}$ 是时间模型 (Time Model)

**公理 1.1.1 (并发系统公理)**
对于任意并发系统 $\mathcal{CS}$：
1. $\forall p \in \mathcal{P} \cdot \text{Independent}(p)$
2. $\forall r \in \mathcal{R} \cdot \text{Shared}(r)$
3. $\forall s \in \mathcal{S} \cdot \text{Atomic}(s)$

### 1.1.2 形式化语言

**定义 1.1.2 (并发系统语言)**
并发系统语言 $\mathcal{L}_{CS}$ 由以下语法规则定义：

$$\phi ::= p \in \mathcal{P} \mid \text{Run}(p) \mid \text{Wait}(p) \mid \text{Block}(p) \mid \text{Acquire}(p, r) \mid \text{Release}(p, r) \mid \text{Sync}(p_1, p_2) \mid \neg \phi \mid \phi \land \psi \mid \phi \lor \psi \mid \phi \rightarrow \psi \mid \forall x \cdot \phi \mid \exists x \cdot \phi$$

## 1.2 进程与线程

### 1.2.1 进程定义

**定义 1.2.1 (进程)**
进程是一个四元组 $p = (S, C, R, L)$，其中：

- $S$ 是状态空间 (State Space)
- $C$ 是控制流 (Control Flow)
- $R$ 是资源集合 (Resources)
- $L$ 是生命周期 (Lifecycle)

**公理 1.2.1 (进程公理)**
对于任意进程 $p$：
1. $S$ 是有限的
2. $C$ 是确定性的
3. $R$ 是隔离的
4. $L$ 管理进程的创建、运行、销毁

### 1.2.2 线程定义

**定义 1.2.2 (线程)**
线程是一个四元组 $t = (S, C, R, P)$，其中：

- $S$ 是状态空间 (State Space)
- $C$ 是控制流 (Control Flow)
- $R$ 是资源集合 (Resources)
- $P$ 是所属进程 (Parent Process)

**公理 1.2.2 (线程公理)**
对于任意线程 $t$：
1. $S$ 是进程状态空间的子集
2. $C$ 是进程控制流的子流
3. $R$ 与进程共享
4. $P$ 是确定的

### 1.2.3 进程与线程关系

**定义 1.2.3 (进程线程关系)**
进程 $p$ 包含线程集合 $T_p$，满足：
$$\forall t \in T_p \cdot \text{Parent}(t) = p$$

**定理 1.2.1 (进程线程关系定理)**
进程是资源分配的基本单位，线程是调度的基本单位。

## 1.3 同步原语

### 1.3.1 互斥锁

**定义 1.3.1 (互斥锁)**
互斥锁是一个三元组 $m = (S, A, R)$，其中：

- $S$ 是状态集合 $\{\text{Locked}, \text{Unlocked}\}$
- $A$ 是获取操作 (Acquire)
- $R$ 是释放操作 (Release)

**公理 1.3.1 (互斥锁公理)**
对于任意互斥锁 $m$：
1. 初始状态为Unlocked
2. 只能被一个线程持有
3. 只有持有者能释放

### 1.3.2 信号量

**定义 1.3.2 (信号量)**
信号量是一个四元组 $s = (V, P, V, I)$，其中：

- $V$ 是计数值 (Value)
- $P$ 是P操作 (Wait)
- $V$ 是V操作 (Signal)
- $I$ 是初始值 (Initial Value)

**公理 1.3.2 (信号量公理)**
对于任意信号量 $s$：
1. $V \geq 0$
2. $P$ 操作减少计数值
3. $V$ 操作增加计数值
4. 计数值为0时P操作阻塞

### 1.3.3 条件变量

**定义 1.3.3 (条件变量)**
条件变量是一个三元组 $cv = (Q, W, S)$，其中：

- $Q$ 是等待队列 (Wait Queue)
- $W$ 是等待操作 (Wait)
- $S$ 是信号操作 (Signal)

**公理 1.3.3 (条件变量公理)**
对于任意条件变量 $cv$：
1. $W$ 操作将线程加入等待队列
2. $S$ 操作唤醒等待队列中的线程
3. 必须与互斥锁配合使用

## 1.4 死锁理论

### 1.4.1 死锁定义

**定义 1.4.1 (死锁)**
死锁是并发系统中的一种状态，其中一组进程互相等待对方持有的资源，导致所有进程都无法继续执行。

**公理 1.4.1 (死锁公理)**
对于任意死锁状态：
1. 存在循环等待
2. 资源不可抢占
3. 进程持有资源不释放
4. 资源分配不可分割

### 1.4.2 死锁条件

**定义 1.4.2 (死锁必要条件)**
死锁的四个必要条件是：

1. **互斥条件**：资源不能被多个进程同时使用
2. **占有和等待**：进程持有资源并等待其他资源
3. **不可抢占**：资源不能被强制从进程手中夺取
4. **循环等待**：存在进程等待链形成环

**定理 1.4.1 (死锁条件定理)**
四个必要条件同时满足是死锁的充分必要条件。

### 1.4.3 死锁检测

**定义 1.4.3 (资源分配图)**
资源分配图是一个有向图 $G = (V, E)$，其中：

- $V = P \cup R$ (进程和资源节点)
- $E$ 包含请求边和分配边

**算法 1.4.1 (死锁检测算法)**
```rust
// 死锁检测算法
fn detect_deadlock(resource_allocation_graph: &Graph) -> bool {
    // 构造资源分配图
    let graph = construct_allocation_graph(resource_allocation_graph);
    
    // 使用深度优先搜索检测环
    let mut visited = HashSet::new();
    let mut recursion_stack = HashSet::new();
    
    for node in graph.nodes() {
        if !visited.contains(&node) {
            if has_cycle_dfs(&graph, node, &mut visited, &mut recursion_stack) {
                return true; // 发现死锁
            }
        }
    }
    
    false // 无死锁
}

fn has_cycle_dfs(
    graph: &Graph,
    node: Node,
    visited: &mut HashSet<Node>,
    recursion_stack: &mut HashSet<Node>,
) -> bool {
    visited.insert(node);
    recursion_stack.insert(node);
    
    for neighbor in graph.neighbors(node) {
        if !visited.contains(&neighbor) {
            if has_cycle_dfs(graph, neighbor, visited, recursion_stack) {
                return true;
            }
        } else if recursion_stack.contains(&neighbor) {
            return true; // 发现环
        }
    }
    
    recursion_stack.remove(&node);
    false
}
```

## 1.5 竞态条件

### 1.5.1 竞态条件定义

**定义 1.5.1 (竞态条件)**
竞态条件是指程序的正确性依赖于多个线程的执行时序。

**公理 1.5.1 (竞态条件公理)**
对于任意竞态条件：
1. 存在共享资源
2. 存在并发访问
3. 访问不是原子的
4. 结果依赖于时序

### 1.5.2 竞态条件类型

**定义 1.5.2 (竞态条件类型)**
常见的竞态条件类型包括：

1. **数据竞争**：多个线程同时读写共享数据
2. **检查时使用**：检查和使用之间状态可能改变
3. **原子性违反**：复合操作不是原子的
4. **顺序违反**：操作顺序不正确

**定理 1.5.1 (竞态条件避免定理)**
通过适当的同步机制可以避免竞态条件。

### 1.5.3 竞态条件检测

**定义 1.5.3 (竞态条件检测)**
竞态条件检测是识别程序中潜在竞态条件的过程。

**算法 1.5.1 (竞态条件检测算法)**
```rust
// 竞态条件检测算法
fn detect_race_condition(program: &ConcurrentProgram) -> Vec<RaceCondition> {
    let mut race_conditions = Vec::new();
    
    // 分析共享变量
    let shared_variables = find_shared_variables(program);
    
    // 分析访问模式
    for variable in shared_variables {
        let accesses = find_variable_accesses(program, &variable);
        
        // 检查是否存在并发访问
        if has_concurrent_access(&accesses) {
            // 检查是否缺乏同步
            if !has_proper_synchronization(&accesses) {
                race_conditions.push(RaceCondition {
                    variable,
                    accesses,
                    severity: calculate_severity(&accesses),
                });
            }
        }
    }
    
    race_conditions
}

fn has_concurrent_access(accesses: &[VariableAccess]) -> bool {
    // 检查是否存在时间重叠的访问
    for i in 0..accesses.len() {
        for j in i + 1..accesses.len() {
            if accesses[i].thread != accesses[j].thread {
                if accesses_overlap(&accesses[i], &accesses[j]) {
                    return true;
                }
            }
        }
    }
    false
}
```

## 1.6 内存模型

### 1.6.1 内存模型定义

**定义 1.6.1 (内存模型)**
内存模型定义了多线程程序中内存操作的可见性和顺序。

**公理 1.6.1 (内存模型公理)**
对于任意内存模型：
1. 定义内存操作的语义
2. 规定可见性规则
3. 指定重排序限制
4. 保证一致性

### 1.6.2 顺序一致性

**定义 1.6.2 (顺序一致性)**
顺序一致性要求所有线程看到相同的操作顺序。

**公理 1.6.2 (顺序一致性公理)**
对于任意顺序一致的内存模型：
1. 所有操作都有全局顺序
2. 每个线程的操作按程序顺序出现
3. 所有线程看到相同的顺序

### 1.6.3 弱内存模型

**定义 1.6.3 (弱内存模型)**
弱内存模型允许某些重排序以提高性能。

**定理 1.6.1 (弱内存模型定理)**
弱内存模型需要显式同步来保证正确性。

**证明：**
通过反例证明：

```rust
// 弱内存模型示例
#[derive(Debug, Clone)]
struct WeakMemoryExample {
    x: AtomicI32,
    y: AtomicI32,
    ready: AtomicBool,
}

impl WeakMemoryExample {
    fn new() -> Self {
        WeakMemoryExample {
            x: AtomicI32::new(0),
            y: AtomicI32::new(0),
            ready: AtomicBool::new(false),
        }
    }
    
    fn thread1(&self) {
        self.x.store(1, Ordering::Relaxed);
        self.y.store(1, Ordering::Relaxed);
        self.ready.store(true, Ordering::Release);
    }
    
    fn thread2(&self) {
        while !self.ready.load(Ordering::Acquire) {
            std::thread::yield_now();
        }
        
        let y_val = self.y.load(Ordering::Relaxed);
        let x_val = self.x.load(Ordering::Relaxed);
        
        // 在弱内存模型中，x_val可能为0
        println!("y = {}, x = {}", y_val, x_val);
    }
}
```

## 1.7 并发控制

### 1.7.1 并发控制定义

**定义 1.7.1 (并发控制)**
并发控制是管理并发访问共享资源的技术。

**公理 1.7.1 (并发控制公理)**
对于任意并发控制系统：
1. 保证数据一致性
2. 避免死锁
3. 提高并发性
4. 保证正确性

### 1.7.2 乐观并发控制

**定义 1.7.2 (乐观并发控制)**
乐观并发控制假设冲突很少发生，在提交时检查冲突。

**公理 1.7.2 (乐观并发控制公理)**
对于任意乐观并发控制：
1. 读取时不加锁
2. 提交时验证
3. 冲突时回滚
4. 冲突少时高效

### 1.7.3 悲观并发控制

**定义 1.7.3 (悲观并发控制)**
悲观并发控制假设冲突经常发生，在访问时加锁。

**公理 1.7.3 (悲观并发控制公理)**
对于任意悲观并发控制：
1. 访问时加锁
2. 使用完释放锁
3. 保证互斥访问
4. 可能降低并发性

## 1.8 形式化证明

### 1.8.1 并发系统一致性证明

**定理 1.8.1 (并发系统一致性)**
并发系统公理系统是一致的。

**证明：**
通过模型构造证明：

```rust
// 并发系统一致性证明
#[derive(Debug, Clone)]
struct ConcurrentSystem {
    processes: Vec<Process>,
    resources: Vec<Resource>,
    synchronization_primitives: Vec<SynchronizationPrimitive>,
    memory_model: MemoryModel,
    time_model: TimeModel,
}

// 一致性检查
fn check_consistency(system: &ConcurrentSystem) -> bool {
    let process_consistent = check_process_consistency(&system.processes);
    let resource_consistent = check_resource_consistency(&system.resources);
    let sync_consistent = check_synchronization_consistency(&system.synchronization_primitives);
    let memory_consistent = check_memory_consistency(&system.memory_model);
    let time_consistent = check_time_consistency(&system.time_model);
    
    process_consistent && resource_consistent && sync_consistent && memory_consistent && time_consistent
}

// 模型构造
fn construct_model(system: &ConcurrentSystem) -> Model {
    let process_model = construct_process_model(&system.processes);
    let resource_model = construct_resource_model(&system.resources);
    let sync_model = construct_synchronization_model(&system.synchronization_primitives);
    
    Model {
        process_model,
        resource_model,
        sync_model,
    }
}
```

### 1.8.2 死锁避免算法正确性证明

**定理 1.8.2 (死锁避免算法正确性)**
银行家算法能够避免死锁。

**证明：**
通过安全性检查证明：

```rust
// 银行家算法正确性证明
#[derive(Debug, Clone)]
struct BankersAlgorithm {
    available: Vec<i32>,
    maximum: Vec<Vec<i32>>,
    allocation: Vec<Vec<i32>>,
    need: Vec<Vec<i32>>,
}

impl BankersAlgorithm {
    fn is_safe_state(&self) -> bool {
        let mut work = self.available.clone();
        let mut finish = vec![false; self.maximum.len()];
        
        // 查找可以完成的进程
        loop {
            let mut found = false;
            for i in 0..self.maximum.len() {
                if !finish[i] && self.can_allocate(i, &work) {
                    // 分配资源给进程i
                    for j in 0..work.len() {
                        work[j] += self.allocation[i][j];
                    }
                    finish[i] = true;
                    found = true;
                }
            }
            
            if !found {
                break;
            }
        }
        
        // 检查所有进程是否都能完成
        finish.iter().all(|&f| f)
    }
    
    fn can_allocate(&self, process: usize, work: &[i32]) -> bool {
        for j in 0..work.len() {
            if self.need[process][j] > work[j] {
                return false;
            }
        }
        true
    }
}
```

### 1.8.3 同步原语正确性证明

**定理 1.8.3 (同步原语正确性)**
互斥锁保证互斥访问。

**证明：**
通过不变式证明：

```rust
// 互斥锁正确性证明
#[derive(Debug, Clone)]
struct MutexCorrectness {
    mutex: Mutex,
    threads: Vec<Thread>,
    invariants: Vec<Invariant>,
}

// 正确性检查
fn check_mutex_correctness(correctness: &MutexCorrectness) -> bool {
    // 检查互斥性
    let mutual_exclusion = check_mutual_exclusion(&correctness.mutex, &correctness.threads);
    
    // 检查无死锁
    let no_deadlock = check_no_deadlock(&correctness.mutex, &correctness.threads);
    
    // 检查无饥饿
    let no_starvation = check_no_starvation(&correctness.mutex, &correctness.threads);
    
    // 检查不变式
    let invariants_hold = check_invariants(&correctness.invariants);
    
    mutual_exclusion && no_deadlock && no_starvation && invariants_hold
}

// 互斥性检查
fn check_mutual_exclusion(mutex: &Mutex, threads: &[Thread]) -> bool {
    let mut holders = 0;
    
    for thread in threads {
        if thread.holds_mutex(mutex) {
            holders += 1;
        }
    }
    
    holders <= 1 // 最多只有一个线程持有锁
}
```

---

## 参考文献

1. Herlihy, M., & Shavit, N. (2012). *The Art of Multiprocessor Programming*. Morgan Kaufmann.
2. Silberschatz, A., Galvin, P. B., & Gagne, G. (2018). *Operating System Concepts*. Wiley.
3. Tanenbaum, A. S., & Bos, H. (2014). *Modern Operating Systems*. Pearson.
4. Lamport, L. (1978). Time, clocks, and the ordering of events in a distributed system. *Communications of the ACM*, 21(7), 558-565.
5. Dijkstra, E. W. (1965). Solution of a problem in concurrent programming control. *Communications of the ACM*, 8(9), 569. 