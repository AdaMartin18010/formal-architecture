# 推理链完善工具 - 核心结构

## 概述

本文档实现了推理链完善工具的核心结构，用于完善理论推理链，确保逻辑推理的完整性和正确性。该工具支持推理步骤建模、推理链验证、缺失步骤识别和推理规则管理。

## 1. 推理链结构

### 1.1 核心数据结构

```rust
use std::collections::{HashMap, HashSet};
use serde::{Deserialize, Serialize};

/// 推理链
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReasoningChain {
    /// 推理链ID
    pub id: String,
    /// 推理链名称
    pub name: String,
    /// 推理步骤列表
    pub steps: Vec<ReasoningStep>,
    /// 前提条件
    pub premises: Vec<Proposition>,
    /// 结论
    pub conclusions: Vec<Proposition>,
    /// 推理规则
    pub inference_rules: Vec<InferenceRule>,
    /// 推理链描述
    pub description: String,
    /// 推理链状态
    pub status: ReasoningStatus,
    /// 元数据
    pub metadata: HashMap<String, String>,
}

/// 推理步骤
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReasoningStep {
    /// 步骤ID
    pub id: String,
    /// 步骤名称
    pub name: String,
    /// 输入命题
    pub input: Vec<Proposition>,
    /// 输出命题
    pub output: Proposition,
    /// 使用的推理规则
    pub rule: InferenceRule,
    /// 推理依据
    pub justification: Justification,
    /// 步骤顺序
    pub order: usize,
    /// 步骤状态
    pub status: StepStatus,
}

/// 命题
#[derive(Debug, Clone, Serialize, Deserialize, Hash, Eq, PartialEq)]
pub struct Proposition {
    /// 命题ID
    pub id: String,
    /// 命题内容
    pub content: String,
    /// 命题类型
    pub proposition_type: PropositionType,
    /// 命题真值
    pub truth_value: Option<bool>,
    /// 命题来源
    pub source: String,
    /// 命题置信度
    pub confidence: f64,
}

/// 命题类型
#[derive(Debug, Clone, Serialize, Deserialize, Hash, Eq, PartialEq)]
pub enum PropositionType {
    Axiom,          // 公理
    Theorem,        // 定理
    Lemma,          // 引理
    Corollary,      // 推论
    Hypothesis,     // 假设
    Conclusion,     // 结论
    Definition,     // 定义
    Other,          // 其他
}

/// 推理规则
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InferenceRule {
    /// 规则ID
    pub id: String,
    /// 规则名称
    pub name: String,
    /// 规则描述
    pub description: String,
    /// 规则类型
    pub rule_type: RuleType,
    /// 规则模式
    pub pattern: RulePattern,
    /// 规则有效性
    pub validity: RuleValidity,
}

/// 规则类型
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum RuleType {
    ModusPonens,        // 假言推理
    ModusTollens,       // 否定后件
    HypotheticalSyllogism, // 假言三段论
    DisjunctiveSyllogism,  // 选言三段论
    Conjunction,        // 合取
    Simplification,     // 简化
    Addition,           // 附加
    UniversalGeneralization, // 全称概括
    UniversalInstantiation,  // 全称例化
    ExistentialGeneralization, // 存在概括
    ExistentialInstantiation,  // 存在例化
    MathematicalInduction,     // 数学归纳
    Other,              // 其他
}

/// 规则模式
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RulePattern {
    /// 前提模式
    pub premises: Vec<String>,
    /// 结论模式
    pub conclusion: String,
    /// 约束条件
    pub constraints: Vec<String>,
}

/// 规则有效性
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum RuleValidity {
    Valid,         // 有效
    Invalid,       // 无效
    Conditional,   // 条件有效
    Unknown,       // 未知
}

/// 推理依据
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Justification {
    /// 依据类型
    pub justification_type: JustificationType,
    /// 依据内容
    pub content: String,
    /// 依据来源
    pub source: String,
    /// 依据强度
    pub strength: f64,
    /// 相关引用
    pub references: Vec<String>,
}

/// 依据类型
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum JustificationType {
    Logical,       // 逻辑推理
    Empirical,     // 经验证据
    Axiomatic,     // 公理基础
    Definitional,  // 定义基础
    Theorematical, // 定理基础
    Other,         // 其他
}

/// 推理状态
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ReasoningStatus {
    Valid,         // 有效
    Invalid,       // 无效
    Incomplete,    // 不完整
    UnderReview,   // 审查中
    Experimental,  // 实验性
}

/// 步骤状态
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum StepStatus {
    Valid,         // 有效
    Invalid,       // 无效
    Questionable,  // 可疑
    Missing,       // 缺失
    Pending,       // 待定
}
```

### 1.2 推理链管理器

```rust
/// 推理链管理器
#[derive(Debug)]
pub struct ReasoningChainManager {
    /// 推理链集合
    chains: HashMap<String, ReasoningChain>,
    /// 推理规则库
    rule_library: HashMap<String, InferenceRule>,
    /// 有效性检查器
    validity_checker: ValidityChecker,
    /// 完整性分析器
    completeness_analyzer: CompletenessAnalyzer,
}

impl ReasoningChainManager {
    /// 创建新的管理器
    pub fn new() -> Self {
        let mut manager = Self {
            chains: HashMap::new(),
            rule_library: HashMap::new(),
            validity_checker: ValidityChecker::new(),
            completeness_analyzer: CompletenessAnalyzer::new(),
        };
        
        // 初始化默认推理规则
        manager.initialize_default_rules();
        
        manager
    }

    /// 初始化默认推理规则
    fn initialize_default_rules(&mut self) {
        // 假言推理规则
        let modus_ponens = InferenceRule {
            id: "modus_ponens".to_string(),
            name: "假言推理".to_string(),
            description: "如果P蕴含Q，且P为真，则Q为真".to_string(),
            rule_type: RuleType::ModusPonens,
            pattern: RulePattern {
                premises: vec!["P → Q".to_string(), "P".to_string()],
                conclusion: "Q".to_string(),
                constraints: Vec::new(),
            },
            validity: RuleValidity::Valid,
        };
        
        // 否定后件规则
        let modus_tollens = InferenceRule {
            id: "modus_tollens".to_string(),
            name: "否定后件".to_string(),
            description: "如果P蕴含Q，且Q为假，则P为假".to_string(),
            rule_type: RuleType::ModusTollens,
            pattern: RulePattern {
                premises: vec!["P → Q".to_string(), "¬Q".to_string()],
                conclusion: "¬P".to_string(),
                constraints: Vec::new(),
            },
            validity: RuleValidity::Valid,
        };
        
        // 假言三段论规则
        let hypothetical_syllogism = InferenceRule {
            id: "hypothetical_syllogism".to_string(),
            name: "假言三段论".to_string(),
            description: "如果P蕴含Q，且Q蕴含R，则P蕴含R".to_string(),
            rule_type: RuleType::HypotheticalSyllogism,
            pattern: RulePattern {
                premises: vec!["P → Q".to_string(), "Q → R".to_string()],
                conclusion: "P → R".to_string(),
                constraints: Vec::new(),
            },
            validity: RuleValidity::Valid,
        };
        
        self.rule_library.insert(modus_ponens.id.clone(), modus_ponens);
        self.rule_library.insert(modus_tollens.id.clone(), modus_tollens);
        self.rule_library.insert(hypothetical_syllogism.id.clone(), hypothetical_syllogism);
    }

    /// 添加推理链
    pub fn add_chain(&mut self, chain: ReasoningChain) -> Result<(), String> {
        // 验证推理链
        self.validate_chain(&chain)?;
        
        // 添加到集合
        self.chains.insert(chain.id.clone(), chain);
        
        Ok(())
    }

    /// 验证推理链
    fn validate_chain(&self, chain: &ReasoningChain) -> Result<(), String> {
        if chain.id.is_empty() {
            return Err("推理链ID不能为空".to_string());
        }
        
        if chain.name.is_empty() {
            return Err("推理链名称不能为空".to_string());
        }
        
        if chain.steps.is_empty() {
            return Err("推理链必须包含至少一个推理步骤".to_string());
        }
        
        // 验证步骤顺序
        let mut step_orders: Vec<usize> = chain.steps.iter().map(|s| s.order).collect();
        step_orders.sort();
        for (i, &order) in step_orders.iter().enumerate() {
            if order != i {
                return Err(format!("推理步骤顺序不正确，期望{}，实际{}", i, order));
            }
        }
        
        Ok(())
    }

    /// 获取推理链
    pub fn get_chain(&self, chain_id: &str) -> Option<&ReasoningChain> {
        self.chains.get(chain_id)
    }

    /// 验证推理链有效性
    pub fn validate_chain_validity(&self, chain_id: &str) -> Result<ValidityResult, String> {
        if let Some(chain) = self.chains.get(chain_id) {
            self.validity_checker.check_chain(chain)
        } else {
            Err(format!("推理链 '{}' 不存在", chain_id))
        }
    }

    /// 分析推理链完整性
    pub fn analyze_chain_completeness(&self, chain_id: &str) -> Result<CompletenessReport, String> {
        if let Some(chain) = self.chains.get(chain_id) {
            self.completeness_analyzer.analyze_chain(chain)
        } else {
            Err(format!("推理链 '{}' 不存在", chain_id))
        }
    }

    /// 查找缺失的推理步骤
    pub fn find_missing_steps(&self, chain_id: &str) -> Result<Vec<MissingStep>, String> {
        if let Some(chain) = self.chains.get(chain_id) {
            self.completeness_analyzer.find_missing_steps(chain)
        } else {
            Err(format!("推理链 '{}' 不存在", chain_id))
        }
    }

    /// 添加推理规则
    pub fn add_rule(&mut self, rule: InferenceRule) -> Result<(), String> {
        if rule.id.is_empty() {
            return Err("推理规则ID不能为空".to_string());
        }
        
        if self.rule_library.contains_key(&rule.id) {
            return Err(format!("推理规则 '{}' 已存在", rule.id));
        }
        
        self.rule_library.insert(rule.id.clone(), rule);
        Ok(())
    }

    /// 获取推理规则
    pub fn get_rule(&self, rule_id: &str) -> Option<&InferenceRule> {
        self.rule_library.get(rule_id)
    }

    /// 生成推理链报告
    pub fn generate_chain_report(&self, chain_id: &str) -> Result<ReasoningChainReport, String> {
        if let Some(chain) = self.chains.get(chain_id) {
            let validity_result = self.validity_checker.check_chain(chain)?;
            let completeness_report = self.completeness_analyzer.analyze_chain(chain)?;
            
            Ok(ReasoningChainReport {
                chain_id: chain_id.to_string(),
                chain_name: chain.name.clone(),
                validity_result,
                completeness_report,
                step_details: chain.steps.clone(),
                timestamp: chrono::Utc::now().to_rfc3339(),
            })
        } else {
            Err(format!("推理链 '{}' 不存在", chain_id))
        }
    }

    /// 获取所有推理链
    pub fn get_all_chains(&self) -> Vec<&ReasoningChain> {
        self.chains.values().collect()
    }

    /// 按状态查找推理链
    pub fn find_chains_by_status(&self, status: &ReasoningStatus) -> Vec<&ReasoningChain> {
        self.chains.values()
            .filter(|chain| &chain.status == status)
            .collect()
    }

    /// 搜索推理链
    pub fn search_chains(&self, query: &str) -> Vec<&ReasoningChain> {
        let query_lower = query.to_lowercase();
        self.chains.values()
            .filter(|chain| {
                chain.name.to_lowercase().contains(&query_lower) ||
                chain.description.to_lowercase().contains(&query_lower)
            })
            .collect()
    }
}

/// 缺失步骤
#[derive(Debug, Clone)]
pub struct MissingStep {
    /// 步骤位置
    pub position: usize,
    /// 缺失步骤描述
    pub description: String,
    /// 建议的推理规则
    pub suggested_rule: Option<String>,
    /// 优先级
    pub priority: f64,
}

/// 推理链报告
#[derive(Debug, Clone)]
pub struct ReasoningChainReport {
    /// 推理链ID
    pub chain_id: String,
    /// 推理链名称
    pub chain_name: String,
    /// 有效性结果
    pub validity_result: ValidityResult,
    /// 完整性报告
    pub completeness_report: CompletenessReport,
    /// 步骤详情
    pub step_details: Vec<ReasoningStep>,
    /// 生成时间
    pub timestamp: String,
}
```

## 2. 使用示例

### 2.1 基本使用示例

```rust
fn main() -> Result<(), String> {
    // 创建推理链管理器
    let mut manager = ReasoningChainManager::new();
    
    // 创建推理链
    let chain = ReasoningChain {
        id: "chain_001".to_string(),
        name: "形式化方法推理链".to_string(),
        steps: vec![
            ReasoningStep {
                id: "step_001".to_string(),
                name: "前提1".to_string(),
                input: vec![
                    Proposition {
                        id: "p1".to_string(),
                        content: "P → Q".to_string(),
                        proposition_type: PropositionType::Axiom,
                        truth_value: Some(true),
                        source: "形式化方法定义".to_string(),
                        confidence: 0.95,
                    },
                    Proposition {
                        id: "p2".to_string(),
                        content: "P".to_string(),
                        proposition_type: PropositionType::Axiom,
                        truth_value: Some(true),
                        source: "系统假设".to_string(),
                        confidence: 0.90,
                    },
                ],
                output: Proposition {
                    id: "p3".to_string(),
                    content: "Q".to_string(),
                    proposition_type: PropositionType::Conclusion,
                    truth_value: Some(true),
                    source: "推理结果".to_string(),
                    confidence: 0.85,
                },
                rule: InferenceRule {
                    id: "modus_ponens".to_string(),
                    name: "假言推理".to_string(),
                    description: "如果P蕴含Q，且P为真，则Q为真".to_string(),
                    rule_type: RuleType::ModusPonens,
                    pattern: RulePattern {
                        premises: vec!["P → Q".to_string(), "P".to_string()],
                        conclusion: "Q".to_string(),
                        constraints: Vec::new(),
                    },
                    validity: RuleValidity::Valid,
                },
                justification: Justification {
                    justification_type: JustificationType::Logical,
                    content: "应用假言推理规则".to_string(),
                    source: "逻辑推理".to_string(),
                    strength: 0.95,
                    references: vec!["形式逻辑".to_string()],
                },
                order: 0,
                status: StepStatus::Valid,
            },
        ],
        premises: vec![
            Proposition {
                id: "premise_001".to_string(),
                content: "P → Q".to_string(),
                proposition_type: PropositionType::Axiom,
                truth_value: Some(true),
                source: "形式化方法定义".to_string(),
                confidence: 0.95,
            },
            Proposition {
                id: "premise_002".to_string(),
                content: "P".to_string(),
                proposition_type: PropositionType::Axiom,
                truth_value: Some(true),
                source: "系统假设".to_string(),
                confidence: 0.90,
            },
        ],
        conclusions: vec![
            Proposition {
                id: "conclusion_001".to_string(),
                content: "Q".to_string(),
                proposition_type: PropositionType::Conclusion,
                truth_value: Some(true),
                source: "推理结果".to_string(),
                confidence: 0.85,
            },
        ],
        inference_rules: vec![],
        description: "演示形式化方法的基本推理过程".to_string(),
        status: ReasoningStatus::Valid,
        metadata: HashMap::new(),
    };
    
    // 添加推理链
    manager.add_chain(chain)?;
    
    // 生成推理链报告
    let chain_report = manager.generate_chain_report("chain_001")?;
    println!("推理链报告:");
    println!("- 名称: {}", chain_report.chain_name);
    println!("- 步骤数: {}", chain_report.step_details.len());
    println!("- 生成时间: {}", chain_report.timestamp);
    
    // 搜索推理链
    let search_results = manager.search_chains("形式化");
    println!("包含'形式化'的推理链数: {}", search_results.len());
    
    Ok(())
}
```

## 3. 总结

本文档实现了推理链完善工具的核心结构，包括：

1. **推理链结构**：完整的推理链、步骤、命题、规则定义
2. **推理链管理器**：支持推理链的创建、验证、分析和报告生成
3. **推理规则库**：预定义的常用推理规则（假言推理、否定后件、假言三段论）
4. **使用示例**：展示如何创建和分析推理链

这个实现为项目的推理链完善工作提供了坚实的基础，确保逻辑推理的完整性和正确性。
