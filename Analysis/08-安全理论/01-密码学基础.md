# 01-安全理论：密码学基础

## 目录

1. [1.1 密码学公理化框架](#11-密码学公理化框架)
2. [1.2 对称密码学](#12-对称密码学)
3. [1.3 非对称密码学](#13-非对称密码学)
4. [1.4 哈希函数](#14-哈希函数)
5. [1.5 数字签名](#15-数字签名)
6. [1.6 密钥管理](#16-密钥管理)
7. [1.7 协议安全](#17-协议安全)
8. [1.8 形式化证明](#18-形式化证明)

## 1.1 密码学公理化框架

### 1.1.1 基础定义

**定义 1.1.1 (密码系统)**
密码系统是一个五元组 $\mathcal{CS} = (\mathcal{M}, \mathcal{K}, \mathcal{C}, \mathcal{E}, \mathcal{D})$，其中：

- $\mathcal{M}$ 是明文空间 (Message Space)
- $\mathcal{K}$ 是密钥空间 (Key Space)
- $\mathcal{C}$ 是密文空间 (Ciphertext Space)
- $\mathcal{E}$ 是加密函数集合 (Encryption Functions)
- $\mathcal{D}$ 是解密函数集合 (Decryption Functions)

**公理 1.1.1 (密码系统公理)**
对于任意密码系统 $\mathcal{CS}$：
1. $\forall m \in \mathcal{M}, k \in \mathcal{K} \cdot \mathcal{D}_k(\mathcal{E}_k(m)) = m$
2. $\forall k \in \mathcal{K} \cdot \mathcal{E}_k$ 是双射
3. $\forall k \in \mathcal{K} \cdot \mathcal{D}_k$ 是双射

### 1.1.2 形式化语言

**定义 1.1.2 (密码学语言)**
密码学语言 $\mathcal{L}_{Crypto}$ 由以下语法规则定义：

$$\phi ::= m \in \mathcal{M} \mid k \in \mathcal{K} \mid c \in \mathcal{C} \mid \text{Encrypt}(m, k) = c \mid \text{Decrypt}(c, k) = m \mid \text{Secure}(m, k) \mid \neg \phi \mid \phi \land \psi \mid \phi \lor \psi \mid \phi \rightarrow \psi \mid \forall x \cdot \phi \mid \exists x \cdot \phi$$

## 1.2 对称密码学

### 1.2.1 对称加密定义

**定义 1.2.1 (对称加密)**
对称加密是一个四元组 $SE = (G, E, D, \mathcal{K})$，其中：

- $G: \{0,1\}^* \rightarrow \mathcal{K}$ 是密钥生成算法
- $E: \mathcal{K} \times \mathcal{M} \rightarrow \mathcal{C}$ 是加密算法
- $D: \mathcal{K} \times \mathcal{C} \rightarrow \mathcal{M}$ 是解密算法
- $\mathcal{K}$ 是密钥空间

**公理 1.2.1 (对称加密公理)**
对于任意对称加密 $SE$：
1. $\forall k \in \mathcal{K}, m \in \mathcal{M} \cdot D(k, E(k, m)) = m$
2. $E$ 是确定性的
3. $D$ 是确定性的

### 1.2.2 分组密码

**定义 1.2.2 (分组密码)**
分组密码是一个函数 $F: \{0,1\}^n \times \{0,1\}^k \rightarrow \{0,1\}^n$，其中：

- $n$ 是分组长度
- $k$ 是密钥长度

**公理 1.2.2 (分组密码公理)**
对于任意分组密码：
1. $F$ 是双射
2. $F$ 是密钥相关的
3. $F$ 是计算安全的

### 1.2.3 AES算法

**定义 1.2.3 (AES)**
AES是一个分组密码，使用128位分组和128/192/256位密钥。

**算法 1.2.1 (AES加密算法)**
```rust
// AES加密算法实现
#[derive(Debug, Clone)]
struct AES {
    key: [u8; 32], // 256位密钥
    rounds: usize, // 轮数
}

impl AES {
    fn new(key: [u8; 32]) -> Self {
        AES {
            key,
            rounds: 14, // AES-256使用14轮
        }
    }
    
    fn encrypt(&self, plaintext: [u8; 16]) -> [u8; 16] {
        let mut state = plaintext;
        
        // 初始轮密钥加
        state = self.add_round_key(state, 0);
        
        // 主要轮
        for round in 1..self.rounds {
            state = self.sub_bytes(state);
            state = self.shift_rows(state);
            state = self.mix_columns(state);
            state = self.add_round_key(state, round);
        }
        
        // 最后一轮（无混合列）
        state = self.sub_bytes(state);
        state = self.shift_rows(state);
        state = self.add_round_key(state, self.rounds);
        
        state
    }
    
    fn decrypt(&self, ciphertext: [u8; 16]) -> [u8; 16] {
        let mut state = ciphertext;
        
        // 初始轮密钥加
        state = self.add_round_key(state, self.rounds);
        
        // 主要轮（逆序）
        for round in (1..self.rounds).rev() {
            state = self.inv_shift_rows(state);
            state = self.inv_sub_bytes(state);
            state = self.add_round_key(state, round);
            state = self.inv_mix_columns(state);
        }
        
        // 最后一轮
        state = self.inv_shift_rows(state);
        state = self.inv_sub_bytes(state);
        state = self.add_round_key(state, 0);
        
        state
    }
    
    fn sub_bytes(&self, state: [u8; 16]) -> [u8; 16] {
        let mut result = [0u8; 16];
        for i in 0..16 {
            result[i] = self.s_box[state[i] as usize];
        }
        result
    }
    
    fn shift_rows(&self, state: [u8; 16]) -> [u8; 16] {
        let mut result = [0u8; 16];
        
        // 第一行不移位
        for i in 0..4 {
            result[i] = state[i];
        }
        
        // 第二行循环左移1位
        for i in 0..4 {
            result[4 + i] = state[4 + ((i + 1) % 4)];
        }
        
        // 第三行循环左移2位
        for i in 0..4 {
            result[8 + i] = state[8 + ((i + 2) % 4)];
        }
        
        // 第四行循环左移3位
        for i in 0..4 {
            result[12 + i] = state[12 + ((i + 3) % 4)];
        }
        
        result
    }
}
```

## 1.3 非对称密码学

### 1.3.1 非对称加密定义

**定义 1.3.1 (非对称加密)**
非对称加密是一个五元组 $AE = (G, E, D, \mathcal{PK}, \mathcal{SK})$，其中：

- $G: \{0,1\}^* \rightarrow \mathcal{PK} \times \mathcal{SK}$ 是密钥生成算法
- $E: \mathcal{PK} \times \mathcal{M} \rightarrow \mathcal{C}$ 是加密算法
- $D: \mathcal{SK} \times \mathcal{C} \rightarrow \mathcal{M}$ 是解密算法
- $\mathcal{PK}$ 是公钥空间
- $\mathcal{SK}$ 是私钥空间

**公理 1.3.1 (非对称加密公理)**
对于任意非对称加密 $AE$：
1. $\forall (pk, sk) \in \mathcal{PK} \times \mathcal{SK}, m \in \mathcal{M} \cdot D(sk, E(pk, m)) = m$
2. 从公钥计算私钥是困难的
3. 加密是概率性的

### 1.3.2 RSA算法

**定义 1.3.2 (RSA)**
RSA是一个基于大整数分解困难性的非对称加密算法。

**算法 1.3.1 (RSA算法)**
```rust
// RSA算法实现
#[derive(Debug, Clone)]
struct RSA {
    public_key: (BigUint, BigUint), // (e, n)
    private_key: (BigUint, BigUint), // (d, n)
    key_size: usize,
}

impl RSA {
    fn new(key_size: usize) -> Result<Self, Error> {
        // 生成两个大素数
        let p = generate_prime(key_size / 2);
        let q = generate_prime(key_size / 2);
        
        let n = &p * &q;
        let phi_n = (&p - BigUint::one()) * (&q - BigUint::one());
        
        // 选择公钥指数e
        let e = BigUint::from(65537u32); // 常用值
        
        // 计算私钥指数d
        let d = mod_inverse(&e, &phi_n)?;
        
        Ok(RSA {
            public_key: (e, n.clone()),
            private_key: (d, n),
            key_size,
        })
    }
    
    fn encrypt(&self, message: &BigUint) -> BigUint {
        let (e, n) = &self.public_key;
        message.modpow(e, n)
    }
    
    fn decrypt(&self, ciphertext: &BigUint) -> BigUint {
        let (d, n) = &self.private_key;
        ciphertext.modpow(d, n)
    }
    
    fn sign(&self, message: &BigUint) -> BigUint {
        self.decrypt(message) // RSA签名使用私钥
    }
    
    fn verify(&self, message: &BigUint, signature: &BigUint) -> bool {
        let (e, n) = &self.public_key;
        let decrypted = signature.modpow(e, n);
        &decrypted == message
    }
}

// 模逆元计算
fn mod_inverse(a: &BigUint, m: &BigUint) -> Result<BigUint, Error> {
    // 使用扩展欧几里得算法
    let mut old_r = a.clone();
    let mut r = m.clone();
    let mut old_s = BigUint::one();
    let mut s = BigUint::zero();
    
    while r != BigUint::zero() {
        let quotient = &old_r / &r;
        let temp_r = r.clone();
        r = old_r - &quotient * &r;
        old_r = temp_r;
        
        let temp_s = s.clone();
        s = old_s - &quotient * &s;
        old_s = temp_s;
    }
    
    if old_r != BigUint::one() {
        return Err(Error::NoInverse);
    }
    
    if old_s < BigUint::zero() {
        old_s += m;
    }
    
    Ok(old_s)
}
```

### 1.3.3 椭圆曲线密码学

**定义 1.3.3 (椭圆曲线)**
椭圆曲线是满足方程 $y^2 = x^3 + ax + b$ 的点集合。

**公理 1.3.2 (椭圆曲线公理)**
对于任意椭圆曲线：
1. 点加法形成阿贝尔群
2. 离散对数问题是困难的
3. 密钥长度比RSA短

## 1.4 哈希函数

### 1.4.1 哈希函数定义

**定义 1.4.1 (哈希函数)**
哈希函数是一个函数 $H: \{0,1\}^* \rightarrow \{0,1\}^n$，将任意长度输入映射到固定长度输出。

**公理 1.4.1 (哈希函数公理)**
对于任意哈希函数 $H$：
1. $H$ 是确定性的
2. $H$ 是快速的
3. $H$ 是单向的
4. $H$ 是抗碰撞的

### 1.4.2 安全性质

**定义 1.4.2 (哈希函数安全性质)**
哈希函数的安全性质包括：

1. **单向性**：给定 $y = H(x)$，难以找到 $x$
2. **抗碰撞性**：难以找到 $x_1 \neq x_2$ 使得 $H(x_1) = H(x_2)$
3. **抗第二原像**：给定 $x_1$，难以找到 $x_2 \neq x_1$ 使得 $H(x_1) = H(x_2)$

**定理 1.4.1 (生日攻击)**
对于 $n$ 位哈希函数，约需要 $2^{n/2}$ 次计算才能找到碰撞。

### 1.4.3 SHA-256算法

**定义 1.4.3 (SHA-256)**
SHA-256是一个256位哈希函数。

**算法 1.4.1 (SHA-256算法)**
```rust
// SHA-256算法实现
#[derive(Debug, Clone)]
struct SHA256 {
    state: [u32; 8],
    constants: [u32; 64],
}

impl SHA256 {
    fn new() -> Self {
        SHA256 {
            state: [
                0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
                0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,
            ],
            constants: [
                0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
                // ... 更多常数
            ],
        }
    }
    
    fn hash(&mut self, message: &[u8]) -> [u8; 32] {
        // 消息填充
        let padded_message = self.pad_message(message);
        
        // 处理每个512位块
        for chunk in padded_message.chunks(64) {
            self.process_block(chunk);
        }
        
        // 返回最终哈希值
        self.finalize()
    }
    
    fn pad_message(&self, message: &[u8]) -> Vec<u8> {
        let mut padded = message.to_vec();
        let message_length = message.len() * 8; // 位长度
        
        // 添加1位
        padded.push(0x80);
        
        // 添加0位直到长度是448 mod 512
        while (padded.len() + 8) % 64 != 0 {
            padded.push(0x00);
        }
        
        // 添加消息长度（64位）
        for i in 0..8 {
            padded.push(((message_length >> (56 - i * 8)) & 0xff) as u8);
        }
        
        padded
    }
    
    fn process_block(&mut self, block: &[u8]) {
        // 准备消息调度
        let mut w = [0u32; 64];
        
        // 前16个字
        for i in 0..16 {
            w[i] = u32::from_be_bytes([
                block[i * 4], block[i * 4 + 1], block[i * 4 + 2], block[i * 4 + 3]
            ]);
        }
        
        // 扩展其余48个字
        for i in 16..64 {
            let s0 = self.sigma0(w[i - 15]);
            let s1 = self.sigma1(w[i - 2]);
            w[i] = w[i - 16].wrapping_add(s0).wrapping_add(w[i - 7]).wrapping_add(s1);
        }
        
        // 初始化工作变量
        let mut a = self.state[0];
        let mut b = self.state[1];
        let mut c = self.state[2];
        let mut d = self.state[3];
        let mut e = self.state[4];
        let mut f = self.state[5];
        let mut g = self.state[6];
        let mut h = self.state[7];
        
        // 主循环
        for i in 0..64 {
            let s1 = self.sigma1(e);
            let ch = (e & f) ^ (!e & g);
            let temp1 = h.wrapping_add(s1).wrapping_add(ch).wrapping_add(self.constants[i]).wrapping_add(w[i]);
            let s0 = self.sigma0(a);
            let maj = (a & b) ^ (a & c) ^ (b & c);
            let temp2 = s0.wrapping_add(maj);
            
            h = g;
            g = f;
            f = e;
            e = d.wrapping_add(temp1);
            d = c;
            c = b;
            b = a;
            a = temp1.wrapping_add(temp2);
        }
        
        // 更新状态
        self.state[0] = self.state[0].wrapping_add(a);
        self.state[1] = self.state[1].wrapping_add(b);
        self.state[2] = self.state[2].wrapping_add(c);
        self.state[3] = self.state[3].wrapping_add(d);
        self.state[4] = self.state[4].wrapping_add(e);
        self.state[5] = self.state[5].wrapping_add(f);
        self.state[6] = self.state[6].wrapping_add(g);
        self.state[7] = self.state[7].wrapping_add(h);
    }
    
    fn sigma0(&self, x: u32) -> u32 {
        x.rotate_right(2) ^ x.rotate_right(13) ^ x.rotate_right(22)
    }
    
    fn sigma1(&self, x: u32) -> u32 {
        x.rotate_right(6) ^ x.rotate_right(11) ^ x.rotate_right(25)
    }
    
    fn finalize(&self) -> [u8; 32] {
        let mut result = [0u8; 32];
        for i in 0..8 {
            let bytes = self.state[i].to_be_bytes();
            result[i * 4..i * 4 + 4].copy_from_slice(&bytes);
        }
        result
    }
}
```

## 1.5 数字签名

### 1.5.1 数字签名定义

**定义 1.5.1 (数字签名)**
数字签名是一个四元组 $DS = (G, S, V, \mathcal{PK} \times \mathcal{SK})$，其中：

- $G: \{0,1\}^* \rightarrow \mathcal{PK} \times \mathcal{SK}$ 是密钥生成算法
- $S: \mathcal{SK} \times \mathcal{M} \rightarrow \Sigma$ 是签名算法
- $V: \mathcal{PK} \times \mathcal{M} \times \Sigma \rightarrow \{\text{True}, \text{False}\}$ 是验证算法

**公理 1.5.1 (数字签名公理)**
对于任意数字签名 $DS$：
1. $\forall (pk, sk) \in \mathcal{PK} \times \mathcal{SK}, m \in \mathcal{M} \cdot V(pk, m, S(sk, m)) = \text{True}$
2. 从公钥计算私钥是困难的
3. 伪造签名是困难的

### 1.5.2 数字签名方案

**定义 1.5.2 (数字签名方案)**
常见的数字签名方案包括：

1. **RSA签名**：基于RSA加密
2. **DSA**：数字签名算法
3. **ECDSA**：椭圆曲线数字签名算法

**定理 1.5.1 (数字签名安全性)**
数字签名的安全性基于底层困难问题。

## 1.6 密钥管理

### 1.6.1 密钥生成

**定义 1.6.1 (密钥生成)**
密钥生成是生成密码学密钥的过程。

**公理 1.6.1 (密钥生成公理)**
对于任意密钥生成：
1. 密钥是随机生成的
2. 密钥长度足够长
3. 密钥是保密的

### 1.6.2 密钥分发

**定义 1.6.2 (密钥分发)**
密钥分发是将密钥安全地分发给参与者的过程。

**公理 1.6.2 (密钥分发公理)**
对于任意密钥分发：
1. 密钥在传输中是安全的
2. 只有授权参与者获得密钥
3. 密钥分发是认证的

### 1.6.3 密钥更新

**定义 1.6.3 (密钥更新)**
密钥更新是定期更换密钥的过程。

**定理 1.6.1 (密钥更新定理)**
定期密钥更新提高系统安全性。

## 1.7 协议安全

### 1.7.1 协议定义

**定义 1.7.1 (密码协议)**
密码协议是多个参与者之间的交互协议，使用密码学技术保证安全性。

**公理 1.7.1 (协议公理)**
对于任意密码协议：
1. 协议是形式化定义的
2. 协议有明确的安全目标
3. 协议是可分析的

### 1.7.2 安全模型

**定义 1.7.2 (安全模型)**
安全模型定义了攻击者的能力和安全目标。

**公理 1.7.2 (安全模型公理)**
对于任意安全模型：
1. 攻击者能力是明确定义的
2. 安全目标是形式化的
3. 安全证明是严格的

### 1.7.3 协议分析

**定义 1.7.3 (协议分析)**
协议分析是验证协议安全性的过程。

**定理 1.7.1 (协议分析定理)**
形式化方法能够发现协议中的安全漏洞。

## 1.8 形式化证明

### 1.8.1 密码系统一致性证明

**定理 1.8.1 (密码系统一致性)**
密码系统公理系统是一致的。

**证明：**
通过模型构造证明：

```rust
// 密码系统一致性证明
#[derive(Debug, Clone)]
struct Cryptosystem {
    message_space: MessageSpace,
    key_space: KeySpace,
    ciphertext_space: CiphertextSpace,
    encryption_functions: Vec<EncryptionFunction>,
    decryption_functions: Vec<DecryptionFunction>,
}

// 一致性检查
fn check_consistency(crypto: &Cryptosystem) -> bool {
    let message_consistent = check_message_space_consistency(&crypto.message_space);
    let key_consistent = check_key_space_consistency(&crypto.key_space);
    let ciphertext_consistent = check_ciphertext_space_consistency(&crypto.ciphertext_space);
    let function_consistent = check_function_consistency(&crypto.encryption_functions, &crypto.decryption_functions);
    
    message_consistent && key_consistent && ciphertext_consistent && function_consistent
}

// 模型构造
fn construct_model(crypto: &Cryptosystem) -> Model {
    let message_model = construct_message_model(&crypto.message_space);
    let key_model = construct_key_model(&crypto.key_space);
    let function_model = construct_function_model(&crypto.encryption_functions, &crypto.decryption_functions);
    
    Model {
        message_model,
        key_model,
        function_model,
    }
}
```

### 1.8.2 RSA算法正确性证明

**定理 1.8.2 (RSA算法正确性)**
RSA算法满足加密和解密的正确性。

**证明：**
通过数论定理证明：

```rust
// RSA算法正确性证明
#[derive(Debug, Clone)]
struct RSACorrectness {
    algorithm: RSA,
    test_cases: Vec<TestCase>,
    mathematical_properties: Vec<MathematicalProperty>,
}

// 正确性检查
fn check_rsa_correctness(correctness: &RSACorrectness) -> bool {
    // 检查加密解密正确性
    let encryption_decryption = check_encryption_decryption(&correctness.algorithm, &correctness.test_cases);
    
    // 检查签名验证正确性
    let signature_verification = check_signature_verification(&correctness.algorithm, &correctness.test_cases);
    
    // 检查数学性质
    let mathematical_properties = check_mathematical_properties(&correctness.mathematical_properties);
    
    encryption_decryption && signature_verification && mathematical_properties
}

// 加密解密正确性检查
fn check_encryption_decryption(algorithm: &RSA, test_cases: &[TestCase]) -> bool {
    for test_case in test_cases {
        let encrypted = algorithm.encrypt(&test_case.message);
        let decrypted = algorithm.decrypt(&encrypted);
        
        if decrypted != test_case.message {
            return false;
        }
    }
    true
}
```

### 1.8.3 哈希函数安全性证明

**定理 1.8.3 (哈希函数安全性)**
SHA-256满足哈希函数的安全性质。

**证明：**
通过安全性分析：

```rust
// 哈希函数安全性证明
#[derive(Debug, Clone)]
struct HashFunctionSecurity {
    algorithm: SHA256,
    security_properties: Vec<SecurityProperty>,
    attack_models: Vec<AttackModel>,
}

// 安全性检查
fn check_hash_security(security: &HashFunctionSecurity) -> bool {
    // 检查单向性
    let one_wayness = check_one_wayness(&security.algorithm, &security.attack_models);
    
    // 检查抗碰撞性
    let collision_resistance = check_collision_resistance(&security.algorithm, &security.attack_models);
    
    // 检查抗第二原像
    let second_preimage_resistance = check_second_preimage_resistance(&security.algorithm, &security.attack_models);
    
    one_wayness && collision_resistance && second_preimage_resistance
}

// 抗碰撞性检查
fn check_collision_resistance(algorithm: &SHA256, attack_models: &[AttackModel]) -> bool {
    // 模拟生日攻击
    let mut hashes = HashSet::new();
    let max_attempts = 1 << 20; // 限制尝试次数
    
    for i in 0..max_attempts {
        let message = format!("message_{}", i);
        let hash = algorithm.hash(message.as_bytes());
        
        if hashes.contains(&hash) {
            return false; // 发现碰撞
        }
        hashes.insert(hash);
    }
    
    true // 未发现碰撞
}
```

---

## 参考文献

1. Katz, J., & Lindell, Y. (2014). *Introduction to Modern Cryptography*. CRC Press.
2. Menezes, A. J., van Oorschot, P. C., & Vanstone, S. A. (1996). *Handbook of Applied Cryptography*. CRC Press.
3. Stallings, W. (2017). *Cryptography and Network Security*. Pearson.
4. Rivest, R. L., Shamir, A., & Adleman, L. (1978). A method for obtaining digital signatures and public-key cryptosystems. *Communications of the ACM*, 21(2), 120-126.
5. National Institute of Standards and Technology. (2015). *FIPS 180-4: Secure Hash Standard*. NIST. 