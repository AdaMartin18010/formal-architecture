# 设计模式理论

## 1. 设计模式概述

### 1.1 基本定义

**定义 1.1 (设计模式)**
设计模式是在软件设计中反复出现的问题的典型解决方案，它描述了在特定软件设计问题中重复出现的通用解决方案。

**形式化表述**：
$$\text{Pattern} = \langle \text{Problem}, \text{Solution}, \text{Consequences} \rangle$$

其中：
- $\text{Problem}$ 是问题描述
- $\text{Solution}$ 是解决方案
- $\text{Consequences}$ 是使用后果

**定义 1.2 (模式分类)**
设计模式按目的分为三类：
1. **创建型模式**：处理对象创建
2. **结构型模式**：处理类和对象组合
3. **行为型模式**：处理对象间通信

### 1.2 模式语言

**定义 1.3 (模式语言)**
模式语言是相互关联的设计模式的集合，形成完整的系统设计方法。

**形式化模型**：
$$\text{PatternLanguage} = \langle \text{Patterns}, \text{Relations}, \text{Constraints} \rangle$$

## 2. 创建型模式

### 2.1 单例模式

**定义 2.1 (单例模式)**
单例模式确保一个类只有一个实例，并提供全局访问点。

**形式化表述**：
$$\text{Singleton}(C) = \forall x, y \in C : x = y$$

**Rust实现**：
```rust
use std::sync::{Mutex, Once, ONCE_INIT};

pub struct Singleton<T> {
    instance: Option<T>,
    once: Once,
}

impl<T> Singleton<T> {
    pub fn new<F>(init: F) -> Self
    where F: FnOnce() -> T,
    {
        let mut singleton = Singleton {
            instance: None,
            once: ONCE_INIT,
        };
        
        singleton.once.call_once(|| {
            singleton.instance = Some(init());
        });
        
        singleton
    }
    
    pub fn get_instance(&self) -> Option<&T> {
        self.instance.as_ref()
    }
}

// 线程安全版本
pub struct ThreadSafeSingleton<T> {
    inner: Mutex<Option<T>>,
    once: Once,
}

impl<T> ThreadSafeSingleton<T> {
    pub fn new<F>(init: F) -> Self
    where F: FnOnce() -> T,
    {
        let mut singleton = ThreadSafeSingleton {
            inner: Mutex::new(None),
            once: ONCE_INIT,
        };
        
        singleton.once.call_once(|| {
            let mut guard = singleton.inner.lock().unwrap();
            *guard = Some(init());
        });
        
        singleton
    }
    
    pub fn get_instance(&self) -> Option<std::sync::MutexGuard<Option<T>>> {
        self.inner.lock().ok()
    }
}
```

**定理 2.1 (单例唯一性)**
单例模式保证全局唯一性。

**证明**：通过构造证明，单例模式通过静态变量和初始化保证唯一性。

### 2.2 工厂方法模式

**定义 2.2 (工厂方法)**
工厂方法定义创建对象的接口，让子类决定实例化哪个类。

**形式化表述**：
$$\text{FactoryMethod} = \langle \text{Creator}, \text{Product}, \text{create} \rangle$$

其中：
- $\text{Creator}$ 是创建者接口
- $\text{Product}$ 是产品接口
- $\text{create}$ 是创建方法

**Rust实现**：
```rust
pub trait Product {
    fn operation(&self) -> String;
}

pub trait Creator {
    type ProductType: Product;
    
    fn create_product(&self) -> Self::ProductType;
    
    fn some_operation(&self) -> String {
        let product = self.create_product();
        format!("Creator: {}", product.operation())
    }
}

pub struct ConcreteProductA;
impl Product for ConcreteProductA {
    fn operation(&self) -> String {
        "ConcreteProductA".to_string()
    }
}

pub struct ConcreteProductB;
impl Product for ConcreteProductB {
    fn operation(&self) -> String {
        "ConcreteProductB".to_string()
    }
}

pub struct ConcreteCreatorA;
impl Creator for ConcreteCreatorA {
    type ProductType = ConcreteProductA;
    
    fn create_product(&self) -> Self::ProductType {
        ConcreteProductA
    }
}

pub struct ConcreteCreatorB;
impl Creator for ConcreteCreatorB {
    type ProductType = ConcreteProductB;
    
    fn create_product(&self) -> Self::ProductType {
        ConcreteProductB
    }
}
```

**定理 2.2 (工厂方法可扩展性)**
工厂方法模式支持开闭原则。

**证明**：通过添加新的具体创建者，可以创建新产品而不修改现有代码。

### 2.3 抽象工厂模式

**定义 2.3 (抽象工厂)**
抽象工厂提供创建一系列相关对象的接口，而无需指定具体类。

**形式化表述**：
$$\text{AbstractFactory} = \langle \text{Factory}, \text{ProductFamily}, \text{create} \rangle$$

**Rust实现**：
```rust
pub trait AbstractProductA {
    fn operation_a(&self) -> String;
}

pub trait AbstractProductB {
    fn operation_b(&self) -> String;
}

pub trait AbstractFactory {
    type ProductA: AbstractProductA;
    type ProductB: AbstractProductB;
    
    fn create_product_a(&self) -> Self::ProductA;
    fn create_product_b(&self) -> Self::ProductB;
}

pub struct ConcreteProductA1;
impl AbstractProductA for ConcreteProductA1 {
    fn operation_a(&self) -> String {
        "ConcreteProductA1".to_string()
    }
}

pub struct ConcreteProductB1;
impl AbstractProductB for ConcreteProductB1 {
    fn operation_b(&self) -> String {
        "ConcreteProductB1".to_string()
    }
}

pub struct ConcreteFactory1;
impl AbstractFactory for ConcreteFactory1 {
    type ProductA = ConcreteProductA1;
    type ProductB = ConcreteProductB1;
    
    fn create_product_a(&self) -> Self::ProductA {
        ConcreteProductA1
    }
    
    fn create_product_b(&self) -> Self::ProductB {
        ConcreteProductB1
    }
}
```

## 3. 结构型模式

### 3.1 适配器模式

**定义 3.1 (适配器)**
适配器模式将一个类的接口转换成客户期望的另一个接口。

**形式化表述**：
$$\text{Adapter} = \langle \text{Target}, \text{Adaptee}, \text{adapt} \rangle$$

**Rust实现**：
```rust
// 目标接口
pub trait Target {
    fn request(&self) -> String;
}

// 被适配的类
pub struct Adaptee;
impl Adaptee {
    pub fn specific_request(&self) -> String {
        "Adaptee specific request".to_string()
    }
}

// 适配器
pub struct Adapter {
    adaptee: Adaptee,
}

impl Adapter {
    pub fn new(adaptee: Adaptee) -> Self {
        Adapter { adaptee }
    }
}

impl Target for Adapter {
    fn request(&self) -> String {
        format!("Adapter: {}", self.adaptee.specific_request())
    }
}
```

**定理 3.1 (适配器兼容性)**
适配器模式保证接口兼容性。

### 3.2 装饰器模式

**定义 3.2 (装饰器)**
装饰器模式动态地给对象添加额外的职责。

**形式化表述**：
$$\text{Decorator} = \langle \text{Component}, \text{Decorator}, \text{decorate} \rangle$$

**Rust实现**：
```rust
pub trait Component {
    fn operation(&self) -> String;
}

pub struct ConcreteComponent;
impl Component for ConcreteComponent {
    fn operation(&self) -> String {
        "ConcreteComponent".to_string()
    }
}

pub struct Decorator<T: Component> {
    component: T,
}

impl<T: Component> Decorator<T> {
    pub fn new(component: T) -> Self {
        Decorator { component }
    }
}

impl<T: Component> Component for Decorator<T> {
    fn operation(&self) -> String {
        format!("Decorator({})", self.component.operation())
    }
}

// 具体装饰器
pub struct ConcreteDecoratorA<T: Component> {
    decorator: Decorator<T>,
}

impl<T: Component> ConcreteDecoratorA<T> {
    pub fn new(component: T) -> Self {
        ConcreteDecoratorA {
            decorator: Decorator::new(component),
        }
    }
}

impl<T: Component> Component for ConcreteDecoratorA<T> {
    fn operation(&self) -> String {
        format!("ConcreteDecoratorA({})", self.decorator.operation())
    }
}
```

## 4. 行为型模式

### 4.1 观察者模式

**定义 4.1 (观察者)**
观察者模式定义对象间的一对多依赖关系，当一个对象状态改变时，所有依赖者都得到通知。

**形式化表述**：
$$\text{Observer} = \langle \text{Subject}, \text{Observer}, \text{notify} \rangle$$

**Rust实现**：
```rust
use std::collections::HashMap;
use std::sync::{Arc, Mutex};

pub trait Observer {
    fn update(&self, subject: &Subject);
}

pub trait Subject {
    fn attach(&mut self, observer: Arc<Mutex<dyn Observer + Send>>);
    fn detach(&mut self, observer: Arc<Mutex<dyn Observer + Send>>);
    fn notify(&self);
}

pub struct ConcreteSubject {
    observers: Vec<Arc<Mutex<dyn Observer + Send>>>,
    state: String,
}

impl ConcreteSubject {
    pub fn new() -> Self {
        ConcreteSubject {
            observers: Vec::new(),
            state: String::new(),
        }
    }
    
    pub fn set_state(&mut self, state: String) {
        self.state = state;
        self.notify();
    }
    
    pub fn get_state(&self) -> &str {
        &self.state
    }
}

impl Subject for ConcreteSubject {
    fn attach(&mut self, observer: Arc<Mutex<dyn Observer + Send>>) {
        self.observers.push(observer);
    }
    
    fn detach(&mut self, observer: Arc<Mutex<dyn Observer + Send>>) {
        self.observers.retain(|obs| !Arc::ptr_eq(obs, &observer));
    }
    
    fn notify(&self) {
        for observer in &self.observers {
            if let Ok(obs) = observer.lock() {
                obs.update(self);
            }
        }
    }
}

pub struct ConcreteObserver {
    name: String,
}

impl ConcreteObserver {
    pub fn new(name: String) -> Self {
        ConcreteObserver { name }
    }
}

impl Observer for ConcreteObserver {
    fn update(&self, subject: &Subject) {
        if let Some(concrete_subject) = subject.as_any().downcast_ref::<ConcreteSubject>() {
            println!("Observer {}: Subject state changed to {}", 
                     self.name, concrete_subject.get_state());
        }
    }
}
```

### 4.2 策略模式

**定义 4.2 (策略)**
策略模式定义一系列算法，使它们可以互相替换，算法的变化不会影响使用算法的客户。

**形式化表述**：
$$\text{Strategy} = \langle \text{Context}, \text{Strategy}, \text{execute} \rangle$$

**Rust实现**：
```rust
pub trait Strategy {
    fn execute(&self, data: &str) -> String;
}

pub struct Context<S: Strategy> {
    strategy: S,
}

impl<S: Strategy> Context<S> {
    pub fn new(strategy: S) -> Self {
        Context { strategy }
    }
    
    pub fn execute_strategy(&self, data: &str) -> String {
        self.strategy.execute(data)
    }
}

pub struct ConcreteStrategyA;
impl Strategy for ConcreteStrategyA {
    fn execute(&self, data: &str) -> String {
        format!("StrategyA: {}", data.to_uppercase())
    }
}

pub struct ConcreteStrategyB;
impl Strategy for ConcreteStrategyB {
    fn execute(&self, data: &str) -> String {
        format!("StrategyB: {}", data.to_lowercase())
    }
}
```

## 5. 并发模式

### 5.1 Actor模型

**定义 5.1 (Actor)**
Actor是并发计算的基本单元，包含状态、行为和邮箱。

**形式化表述**：
$$\text{Actor} = \langle \text{State}, \text{Behavior}, \text{Mailbox} \rangle$$

**Rust实现**：
```rust
use std::sync::mpsc::{channel, Sender, Receiver};
use std::thread;

pub trait Message: Send + 'static {}

pub trait Actor: Send + 'static {
    type Message: Message;
    
    fn handle(&mut self, message: Self::Message);
}

pub struct ActorRef<M: Message> {
    sender: Sender<M>,
}

impl<M: Message> ActorRef<M> {
    pub fn send(&self, message: M) -> Result<(), M> {
        self.sender.send(message).map_err(|e| e.0)
    }
}

pub struct ActorSystem;

impl ActorSystem {
    pub fn spawn<A: Actor>(mut actor: A) -> ActorRef<A::Message> {
        let (sender, receiver) = channel();
        
        thread::spawn(move || {
            while let Ok(message) = receiver.recv() {
                actor.handle(message);
            }
        });
        
        ActorRef { sender }
    }
}

// 示例Actor
pub struct Counter {
    count: i32,
}

impl Counter {
    pub fn new() -> Self {
        Counter { count: 0 }
    }
}

pub enum CounterMessage {
    Increment,
    Decrement,
    GetCount(Sender<i32>),
}

impl Message for CounterMessage {}

impl Actor for Counter {
    type Message = CounterMessage;
    
    fn handle(&mut self, message: Self::Message) {
        match message {
            CounterMessage::Increment => {
                self.count += 1;
                println!("Count incremented to {}", self.count);
            }
            CounterMessage::Decrement => {
                self.count -= 1;
                println!("Count decremented to {}", self.count);
            }
            CounterMessage::GetCount(sender) => {
                let _ = sender.send(self.count);
            }
        }
    }
}
```

### 5.2 生产者-消费者模式

**定义 5.2 (生产者-消费者)**
生产者-消费者模式通过共享缓冲区协调生产者和消费者。

**形式化表述**：
$$\text{ProducerConsumer} = \langle \text{Buffer}, \text{Producer}, \text{Consumer} \rangle$$

**Rust实现**：
```rust
use std::sync::{Arc, Mutex};
use std::collections::VecDeque;
use std::thread;
use std::time::Duration;

pub struct Buffer<T> {
    queue: Mutex<VecDeque<T>>,
    capacity: usize,
}

impl<T> Buffer<T> {
    pub fn new(capacity: usize) -> Self {
        Buffer {
            queue: Mutex::new(VecDeque::new()),
            capacity,
        }
    }
    
    pub fn push(&self, item: T) -> Result<(), T> {
        let mut queue = self.queue.lock().unwrap();
        if queue.len() < self.capacity {
            queue.push_back(item);
            Ok(())
        } else {
            Err(item)
        }
    }
    
    pub fn pop(&self) -> Option<T> {
        let mut queue = self.queue.lock().unwrap();
        queue.pop_front()
    }
}

pub struct Producer<T> {
    buffer: Arc<Buffer<T>>,
    id: usize,
}

impl<T: Send + 'static> Producer<T> {
    pub fn new(buffer: Arc<Buffer<T>>, id: usize) -> Self {
        Producer { buffer, id }
    }
    
    pub fn start<F>(self, generator: F)
    where F: Fn() -> T + Send + 'static,
    {
        thread::spawn(move || {
            loop {
                let item = generator();
                match self.buffer.push(item) {
                    Ok(_) => println!("Producer {}: item produced", self.id),
                    Err(_) => {
                        println!("Producer {}: buffer full, waiting", self.id);
                        thread::sleep(Duration::from_millis(100));
                    }
                }
            }
        });
    }
}

pub struct Consumer<T> {
    buffer: Arc<Buffer<T>>,
    id: usize,
}

impl<T: Send + 'static> Consumer<T> {
    pub fn new(buffer: Arc<Buffer<T>>, id: usize) -> Self {
        Consumer { buffer, id }
    }
    
    pub fn start<F>(self, processor: F)
    where F: Fn(T) + Send + 'static,
    {
        thread::spawn(move || {
            loop {
                if let Some(item) = self.buffer.pop() {
                    println!("Consumer {}: processing item", self.id);
                    processor(item);
                } else {
                    println!("Consumer {}: buffer empty, waiting", self.id);
                    thread::sleep(Duration::from_millis(100));
                }
            }
        });
    }
}
```

## 6. 分布式模式

### 6.1 熔断器模式

**定义 6.1 (熔断器)**
熔断器模式防止系统在故障时继续尝试可能失败的操作。

**形式化表述**：
$$\text{CircuitBreaker} = \langle \text{State}, \text{Threshold}, \text{Timeout} \rangle$$

**Rust实现**：
```rust
use std::sync::{Arc, Mutex};
use std::time::{Duration, Instant};

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum CircuitState {
    Closed,
    Open,
    HalfOpen,
}

pub struct CircuitBreaker {
    state: Mutex<CircuitState>,
    failure_count: Mutex<u32>,
    failure_threshold: u32,
    timeout: Duration,
    last_failure_time: Mutex<Option<Instant>>,
}

impl CircuitBreaker {
    pub fn new(failure_threshold: u32, timeout: Duration) -> Self {
        CircuitBreaker {
            state: Mutex::new(CircuitState::Closed),
            failure_count: Mutex::new(0),
            failure_threshold,
            timeout,
            last_failure_time: Mutex::new(None),
        }
    }
    
    pub fn call<F, T, E>(&self, operation: F) -> Result<T, CircuitBreakerError<E>>
    where F: FnOnce() -> Result<T, E>,
    {
        let current_state = *self.state.lock().unwrap();
        
        match current_state {
            CircuitState::Open => {
                if self.should_attempt_reset() {
                    self.transition_to_half_open();
                    self.call(operation)
                } else {
                    Err(CircuitBreakerError::CircuitOpen)
                }
            }
            CircuitState::HalfOpen | CircuitState::Closed => {
                match operation() {
                    Ok(result) => {
                        self.on_success();
                        Ok(result)
                    }
                    Err(error) => {
                        self.on_failure();
                        Err(CircuitBreakerError::OperationFailed(error))
                    }
                }
            }
        }
    }
    
    fn should_attempt_reset(&self) -> bool {
        if let Some(last_failure) = *self.last_failure_time.lock().unwrap() {
            Instant::now().duration_since(last_failure) >= self.timeout
        } else {
            false
        }
    }
    
    fn transition_to_half_open(&self) {
        let mut state = self.state.lock().unwrap();
        *state = CircuitState::HalfOpen;
    }
    
    fn on_success(&self) {
        let mut state = self.state.lock().unwrap();
        let mut failure_count = self.failure_count.lock().unwrap();
        
        *state = CircuitState::Closed;
        *failure_count = 0;
    }
    
    fn on_failure(&self) {
        let mut failure_count = self.failure_count.lock().unwrap();
        let mut last_failure_time = self.last_failure_time.lock().unwrap();
        let mut state = self.state.lock().unwrap();
        
        *failure_count += 1;
        *last_failure_time = Some(Instant::now());
        
        if *failure_count >= self.failure_threshold {
            *state = CircuitState::Open;
        }
    }
}

#[derive(Debug)]
pub enum CircuitBreakerError<E> {
    CircuitOpen,
    OperationFailed(E),
}
```

## 7. 模式组合与演化

### 7.1 模式组合

**定义 7.1 (模式组合)**
模式组合是将多个设计模式结合使用以解决复杂问题。

**形式化表述**：
$$\text{PatternComposition} = \langle \text{Patterns}, \text{CompositionRules}, \text{Constraints} \rangle$$

### 7.2 模式演化

**定义 7.2 (模式演化)**
模式演化是设计模式随时间的发展和改进。

**演化规律**：
1. **抽象化**：从具体实现到抽象接口
2. **组合化**：从单一模式到模式组合
3. **领域化**：从通用模式到领域特定模式

## 8. 结论

设计模式理论为软件架构提供了重要的理论基础和实践指导。通过形式化分析和系统化组织，设计模式能够：

1. **提高代码质量**：通过标准化解决方案
2. **增强可维护性**：通过清晰的架构结构
3. **促进重用**：通过通用解决方案
4. **支持演化**：通过灵活的架构设计

设计模式的核心价值在于将软件设计经验系统化，为复杂系统的构建提供可靠的理论基础和实践方法。

---

**参考文献**：
1. Gamma, E., Helm, R., Johnson, R., & Vlissides, J. (1994). Design patterns: Elements of reusable object-oriented software. Pearson Education.
2. Freeman, E., Robson, E., Sierra, K., & Bates, B. (2004). Head first design patterns. O'Reilly Media, Inc.
3. Schmidt, D., Stal, M., Rohnert, H., & Buschmann, F. (2013). Pattern-oriented software architecture, patterns for concurrent and networked objects. John Wiley & Sons.
4. Hohpe, G., & Woolf, B. (2003). Enterprise integration patterns: Designing, building, and deploying messaging solutions. Addison-Wesley.

---

**更新时间**：2024年12月
**版本**：v1.0
**状态**：完成
