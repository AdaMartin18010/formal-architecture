# 分层定义体系工具 - 核心结构

## 概述

本文档实现了分层定义体系工具的核心结构，用于建立概念的分层定义体系，确保定义的完整性和一致性。该工具支持从非形式化描述到数学定义的多个层次。

## 1. 分层定义结构

### 1.1 定义层次结构

```rust
use std::collections::HashMap;
use serde::{Deserialize, Serialize};

/// 定义层次
#[derive(Debug, Clone, Serialize, Deserialize, Hash, Eq, PartialEq)]
pub enum DefinitionLevel {
    Informal,      // 非形式化描述
    SemiFormal,    // 半形式化定义
    Formal,        // 形式化定义
    Mathematical,  // 数学定义
}

/// 定义内容
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Definition {
    /// 定义内容
    pub content: String,
    /// 定义语言
    pub language: DefinitionLanguage,
    /// 定义来源
    pub source: String,
    /// 定义日期
    pub date: String,
    /// 置信度 (0.0-1.0)
    pub confidence: f64,
    /// 相关引用
    pub references: Vec<String>,
}

/// 定义语言
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum DefinitionLanguage {
    Natural,        // 自然语言
    Formal,         // 形式化语言
    Mathematical,   // 数学符号
    Code,           // 代码示例
    Diagram,        // 图表
}

/// 分层定义
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LayeredDefinition {
    /// 概念名称
    pub concept: String,
    /// 各层次定义
    pub levels: HashMap<DefinitionLevel, Definition>,
    /// 一致性检查结果
    pub consistency_checks: Vec<ConsistencyCheck>,
    /// 定义关联关系
    pub relationships: Vec<DefinitionRelationship>,
}

/// 一致性检查
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConsistencyCheck {
    /// 检查类型
    pub check_type: ConsistencyCheckType,
    /// 检查结果
    pub result: ConsistencyResult,
    /// 检查时间
    pub timestamp: String,
    /// 检查描述
    pub description: String,
}

/// 一致性检查类型
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ConsistencyCheckType {
    SemanticConsistency,    // 语义一致性
    LogicalConsistency,     // 逻辑一致性
    MathematicalConsistency, // 数学一致性
    CrossLevelConsistency,  // 跨层次一致性
}

/// 一致性结果
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ConsistencyResult {
    Consistent,     // 一致
    Inconsistent,   // 不一致
    Partial,        // 部分一致
    Unknown,        // 未知
}

/// 定义关联关系
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DefinitionRelationship {
    /// 源定义
    pub source: String,
    /// 目标定义
    pub target: String,
    /// 关系类型
    pub relationship_type: RelationshipType,
    /// 关系强度 (0.0-1.0)
    pub strength: f64,
    /// 关系描述
    pub description: String,
}

/// 关系类型
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum RelationshipType {
    Implies,        // 蕴含
    Equivalent,     // 等价
    Generalizes,    // 泛化
    Specializes,    // 特化
    Complements,    // 补充
    Conflicts,      // 冲突
}
```

### 1.2 分层定义管理器

```rust
/// 分层定义管理器
#[derive(Debug)]
pub struct LayeredDefinitionManager {
    /// 定义集合
    definitions: HashMap<String, LayeredDefinition>,
    /// 一致性检查器
    consistency_checker: ConsistencyChecker,
    /// 定义验证器
    definition_validator: DefinitionValidator,
}

impl LayeredDefinitionManager {
    /// 创建新的管理器
    pub fn new() -> Self {
        Self {
            definitions: HashMap::new(),
            consistency_checker: ConsistencyChecker::new(),
            definition_validator: DefinitionValidator::new(),
        }
    }

    /// 添加分层定义
    pub fn add_definition(&mut self, definition: LayeredDefinition) -> Result<(), String> {
        // 验证定义
        self.definition_validator.validate(&definition)?;
        
        // 添加到集合
        self.definitions.insert(definition.concept.clone(), definition);
        
        Ok(())
    }

    /// 获取定义
    pub fn get_definition(&self, concept: &str) -> Option<&LayeredDefinition> {
        self.definitions.get(concept)
    }

    /// 更新定义
    pub fn update_definition(&mut self, concept: &str, level: DefinitionLevel, definition: Definition) -> Result<(), String> {
        if let Some(layered_def) = self.definitions.get_mut(concept) {
            layered_def.levels.insert(level, definition);
            
            // 重新检查一致性
            self.check_consistency(concept)?;
            
            Ok(())
        } else {
            Err(format!("概念 '{}' 不存在", concept))
        }
    }

    /// 检查一致性
    pub fn check_consistency(&mut self, concept: &str) -> Result<ConsistencyReport, String> {
        if let Some(definition) = self.definitions.get(concept) {
            let report = self.consistency_checker.check_definition(definition);
            
            // 更新检查结果
            if let Some(layered_def) = self.definitions.get_mut(concept) {
                layered_def.consistency_checks = report.checks.clone();
            }
            
            Ok(report)
        } else {
            Err(format!("概念 '{}' 不存在", concept))
        }
    }

    /// 检查所有定义的一致性
    pub fn check_all_consistency(&mut self) -> HashMap<String, ConsistencyReport> {
        let mut reports = HashMap::new();
        
        for concept in self.definitions.keys().cloned().collect::<Vec<_>>() {
            if let Ok(report) = self.check_consistency(&concept) {
                reports.insert(concept, report);
            }
        }
        
        reports
    }

    /// 查找缺失定义
    pub fn find_missing_definitions(&self) -> Vec<MissingDefinition> {
        let mut missing = Vec::new();
        
        for (concept, definition) in &self.definitions {
            for level in &[DefinitionLevel::Informal, DefinitionLevel::SemiFormal, DefinitionLevel::Formal, DefinitionLevel::Mathematical] {
                if !definition.levels.contains_key(level) {
                    missing.push(MissingDefinition {
                        concept: concept.clone(),
                        level: level.clone(),
                        priority: self.calculate_priority(level),
                    });
                }
            }
        }
        
        missing.sort_by(|a, b| b.priority.partial_cmp(&a.priority).unwrap());
        missing
    }

    /// 计算优先级
    fn calculate_priority(&self, level: &DefinitionLevel) -> f64 {
        match level {
            DefinitionLevel::Mathematical => 1.0,
            DefinitionLevel::Formal => 0.8,
            DefinitionLevel::SemiFormal => 0.6,
            DefinitionLevel::Informal => 0.4,
        }
    }

    /// 生成定义报告
    pub fn generate_definition_report(&self) -> DefinitionReport {
        let mut report = DefinitionReport::new();
        
        for (concept, definition) in &self.definitions {
            let completeness = definition.levels.len() as f64 / 4.0; // 4个层次
            let consistency_score = self.calculate_consistency_score(definition);
            
            report.add_concept_summary(ConceptSummary {
                concept: concept.clone(),
                completeness,
                consistency_score,
                levels: definition.levels.keys().cloned().collect(),
            });
        }
        
        report
    }

    /// 计算一致性评分
    fn calculate_consistency_score(&self, definition: &LayeredDefinition) -> f64 {
        if definition.consistency_checks.is_empty() {
            return 0.0;
        }
        
        let consistent_count = definition.consistency_checks.iter()
            .filter(|check| matches!(check.result, ConsistencyResult::Consistent))
            .count();
        
        consistent_count as f64 / definition.consistency_checks.len() as f64
    }
}

/// 缺失定义
#[derive(Debug, Clone)]
pub struct MissingDefinition {
    /// 概念名称
    pub concept: String,
    /// 缺失的层次
    pub level: DefinitionLevel,
    /// 优先级
    pub priority: f64,
}

/// 定义报告
#[derive(Debug)]
pub struct DefinitionReport {
    /// 报告时间
    pub timestamp: String,
    /// 概念摘要列表
    pub concept_summaries: Vec<ConceptSummary>,
    /// 总体统计
    pub statistics: DefinitionStatistics,
}

/// 概念摘要
#[derive(Debug, Clone)]
pub struct ConceptSummary {
    /// 概念名称
    pub concept: String,
    /// 完整性评分
    pub completeness: f64,
    /// 一致性评分
    pub consistency_score: f64,
    /// 已定义的层次
    pub levels: Vec<DefinitionLevel>,
}

/// 定义统计
#[derive(Debug, Clone)]
pub struct DefinitionStatistics {
    /// 总概念数
    pub total_concepts: usize,
    /// 平均完整性
    pub average_completeness: f64,
    /// 平均一致性
    pub average_consistency: f64,
    /// 完整定义数
    pub complete_definitions: usize,
    /// 一致定义数
    pub consistent_definitions: usize,
}

impl DefinitionReport {
    /// 创建新报告
    pub fn new() -> Self {
        Self {
            timestamp: chrono::Utc::now().to_rfc3339(),
            concept_summaries: Vec::new(),
            statistics: DefinitionStatistics {
                total_concepts: 0,
                average_completeness: 0.0,
                average_consistency: 0.0,
                complete_definitions: 0,
                consistent_definitions: 0,
            },
        }
    }

    /// 添加概念摘要
    pub fn add_concept_summary(&mut self, summary: ConceptSummary) {
        self.concept_summaries.push(summary);
    }

    /// 计算统计信息
    pub fn calculate_statistics(&mut self) {
        if self.concept_summaries.is_empty() {
            return;
        }
        
        self.statistics.total_concepts = self.concept_summaries.len();
        
        let total_completeness: f64 = self.concept_summaries.iter()
            .map(|s| s.completeness)
            .sum();
        self.statistics.average_completeness = total_completeness / self.concept_summaries.len() as f64;
        
        let total_consistency: f64 = self.concept_summaries.iter()
            .map(|s| s.consistency_score)
            .sum();
        self.statistics.average_consistency = total_consistency / self.concept_summaries.len() as f64;
        
        self.statistics.complete_definitions = self.concept_summaries.iter()
            .filter(|s| s.completeness >= 1.0)
            .count();
        
        self.statistics.consistent_definitions = self.concept_summaries.iter()
            .filter(|s| s.consistency_score >= 0.8)
            .count();
    }

    /// 生成报告文本
    pub fn generate_text(&self) -> String {
        let mut report = format!(
            "分层定义报告\n\
            生成时间: {}\n\
            总概念数: {}\n\
            平均完整性: {:.2}\n\
            平均一致性: {:.2}\n\
            完整定义数: {}\n\
            一致定义数: {}\n\n",
            self.timestamp,
            self.statistics.total_concepts,
            self.statistics.average_completeness,
            self.statistics.average_consistency,
            self.statistics.complete_definitions,
            self.statistics.consistent_definitions,
        );
        
        report.push_str("概念详情:\n");
        for summary in &self.concept_summaries {
            report.push_str(&format!(
                "- {}: 完整性={:.2}, 一致性={:.2}, 层次={:?}\n",
                summary.concept,
                summary.completeness,
                summary.consistency_score,
                summary.levels
            ));
        }
        
        report
    }
}
```

## 2. 使用示例

### 2.1 基本使用示例

```rust
fn main() -> Result<(), String> {
    // 创建分层定义管理器
    let mut manager = LayeredDefinitionManager::new();
    
    // 创建形式化方法的分层定义
    let formal_methods_definition = LayeredDefinition {
        concept: "形式化方法".to_string(),
        levels: HashMap::from([
            (DefinitionLevel::Informal, Definition {
                content: "基于数学的技术，用于软件和硬件系统的规范、开发和验证".to_string(),
                language: DefinitionLanguage::Natural,
                source: "Wikipedia".to_string(),
                date: "2024-01-01".to_string(),
                confidence: 0.95,
                references: vec!["https://en.wikipedia.org/wiki/Formal_methods".to_string()],
            }),
            (DefinitionLevel::SemiFormal, Definition {
                content: "Formal methods are mathematical techniques for the specification, development and verification of software and hardware systems".to_string(),
                language: DefinitionLanguage::Natural,
                source: "IEEE Standard".to_string(),
                date: "2024-01-01".to_string(),
                confidence: 0.95,
                references: vec!["IEEE 1471:2000".to_string()],
            }),
            (DefinitionLevel::Formal, Definition {
                content: "Formal methods = {specification, development, verification} where each component uses mathematical techniques".to_string(),
                language: DefinitionLanguage::Formal,
                source: "Academic Paper".to_string(),
                date: "2024-01-01".to_string(),
                confidence: 0.90,
                references: vec!["Principles of Model Checking".to_string()],
            }),
            (DefinitionLevel::Mathematical, Definition {
                content: "FM(S) = {f: S → {0,1} | f is a mathematical function that maps system S to truth values}".to_string(),
                language: DefinitionLanguage::Mathematical,
                source: "Mathematical Foundation".to_string(),
                date: "2024-01-01".to_string(),
                confidence: 0.85,
                references: vec!["Mathematical Logic".to_string()],
            }),
        ]),
        consistency_checks: Vec::new(),
        relationships: Vec::new(),
    };
    
    // 添加定义
    manager.add_definition(formal_methods_definition)?;
    
    // 生成定义报告
    let mut definition_report = manager.generate_definition_report();
    definition_report.calculate_statistics();
    println!("{}", definition_report.generate_text());
    
    // 查找缺失定义
    let missing_definitions = manager.find_missing_definitions();
    println!("\n缺失定义:");
    for missing in missing_definitions {
        println!("- {}: {:?} (优先级: {:.2})", missing.concept, missing.level, missing.priority);
    }
    
    Ok(())
}
```

## 3. 总结

本文档实现了分层定义体系工具的核心结构，包括：

1. **分层定义结构**：支持从非形式化到数学定义的多个层次
2. **定义管理器**：完整的定义管理和报告生成功能
3. **缺失定义检测**：自动识别和优先级排序缺失的定义
4. **使用示例**：展示如何创建和管理分层定义

这个实现为项目的概念定义完善工作提供了坚实的基础，确保定义的完整性和一致性。
