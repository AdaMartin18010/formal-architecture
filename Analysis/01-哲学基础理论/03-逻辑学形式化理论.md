# 03-逻辑学形式化理论

## 目录

1. [基本概念](#1-基本概念)
2. [命题逻辑](#2-命题逻辑)
3. [谓词逻辑](#3-谓词逻辑)
4. [模态逻辑](#4-模态逻辑)
5. [非经典逻辑](#5-非经典逻辑)
6. [逻辑哲学](#6-逻辑哲学)
7. [应用实例](#7-应用实例)

## 1. 基本概念

### 1.1 逻辑学概述

逻辑学（Logic）研究**推理**的有效性和形式。在形式化架构理论中，逻辑学为所有推理和证明提供基础工具。

### 1.2 核心概念

1. **推理**：从前提得出结论的过程
2. **有效性**：推理形式的正确性
3. **一致性**：理论的无矛盾性
4. **完备性**：理论的表达能力

## 2. 命题逻辑

### 2.1 基本符号

```latex
% 命题变元
p, q, r, \ldots

% 逻辑连接词
\neg p  % 非p
p \land q  % p且q
p \lor q  % p或q
p \rightarrow q  % 如果p则q
p \leftrightarrow q  % p当且仅当q

% 真值
\top  % 真
\bot  % 假
```

### 2.2 命题逻辑语法

```latex
\begin{definition}[命题逻辑公式]
命题逻辑公式递归定义如下：
\begin{enumerate}
\item 原子公式：命题变元是公式
\item 否定：如果$\phi$是公式，则$\neg\phi$是公式
\item 合取：如果$\phi$和$\psi$是公式，则$\phi \land \psi$是公式
\item 析取：如果$\phi$和$\psi$是公式，则$\phi \lor \psi$是公式
\item 蕴含：如果$\phi$和$\psi$是公式，则$\phi \rightarrow \psi$是公式
\item 等价：如果$\phi$和$\psi$是公式，则$\phi \leftrightarrow \psi$是公式
\end{enumerate}
\end{definition}
```

### 2.3 命题逻辑语义

```latex
\begin{definition}[真值赋值]
真值赋值是函数$v: \mathcal{P} \rightarrow \{0,1\}$，其中：
\begin{enumerate}
\item $v(\neg\phi) = 1$ 当且仅当 $v(\phi) = 0$
\item $v(\phi \land \psi) = 1$ 当且仅当 $v(\phi) = 1$ 且 $v(\psi) = 1$
\item $v(\phi \lor \psi) = 1$ 当且仅当 $v(\phi) = 1$ 或 $v(\psi) = 1$
\item $v(\phi \rightarrow \psi) = 1$ 当且仅当 $v(\phi) = 0$ 或 $v(\psi) = 1$
\item $v(\phi \leftrightarrow \psi) = 1$ 当且仅当 $v(\phi) = v(\psi)$
\end{enumerate}
\end{definition}
```

### 2.4 命题逻辑推理规则

```latex
\begin{definition}[自然演绎系统]
命题逻辑的自然演绎规则：
\begin{enumerate}
\item 假设引入：$\frac{}{\phi \vdash \phi}$
\item 否定引入：$\frac{\Gamma, \phi \vdash \bot}{\Gamma \vdash \neg\phi}$
\item 否定消除：$\frac{\Gamma \vdash \phi \quad \Gamma \vdash \neg\phi}{\Gamma \vdash \bot}$
\item 合取引入：$\frac{\Gamma \vdash \phi \quad \Gamma \vdash \psi}{\Gamma \vdash \phi \land \psi}$
\item 合取消除：$\frac{\Gamma \vdash \phi \land \psi}{\Gamma \vdash \phi} \quad \frac{\Gamma \vdash \phi \land \psi}{\Gamma \vdash \psi}$
\item 析取引入：$\frac{\Gamma \vdash \phi}{\Gamma \vdash \phi \lor \psi} \quad \frac{\Gamma \vdash \psi}{\Gamma \vdash \phi \lor \psi}$
\item 析取消除：$\frac{\Gamma \vdash \phi \lor \psi \quad \Gamma, \phi \vdash \chi \quad \Gamma, \psi \vdash \chi}{\Gamma \vdash \chi}$
\item 蕴含引入：$\frac{\Gamma, \phi \vdash \psi}{\Gamma \vdash \phi \rightarrow \psi}$
\item 蕴含消除：$\frac{\Gamma \vdash \phi \rightarrow \psi \quad \Gamma \vdash \phi}{\Gamma \vdash \psi}$
\end{enumerate}
\end{definition}
```

## 3. 谓词逻辑

### 3.1 基本符号

```latex
% 个体变元
x, y, z, \ldots

% 谓词符号
P(x), Q(x,y), R(x,y,z), \ldots

% 函数符号
f(x), g(x,y), h(x,y,z), \ldots

% 量词
\forall x \phi(x)  % 对所有x，φ(x)
\exists x \phi(x)  % 存在x使得φ(x)

% 等词
x = y  % x等于y
```

### 3.2 谓词逻辑语法

```latex
\begin{definition}[谓词逻辑公式]
谓词逻辑公式递归定义如下：
\begin{enumerate}
\item 原子公式：$P(t_1,\ldots,t_n)$ 和 $t_1 = t_2$ 是公式
\item 否定：如果$\phi$是公式，则$\neg\phi$是公式
\item 连接词：如果$\phi$和$\psi$是公式，则$\phi \land \psi$、$\phi \lor \psi$、$\phi \rightarrow \psi$、$\phi \leftrightarrow \psi$是公式
\item 全称量词：如果$\phi$是公式，$x$是变元，则$\forall x \phi$是公式
\item 存在量词：如果$\phi$是公式，$x$是变元，则$\exists x \phi$是公式
\end{enumerate}
\end{definition}
```

### 3.3 谓词逻辑语义

```latex
\begin{definition}[模型]
谓词逻辑模型是三元组$\mathcal{M} = (D, I, v)$，其中：
\begin{enumerate}
\item $D$是个体域
\item $I$是解释函数，将谓词符号映射到关系，函数符号映射到函数
\item $v$是变元赋值函数
\end{enumerate}
\end{definition}

\begin{definition}[满足关系]
模型$\mathcal{M}$满足公式$\phi$，记作$\mathcal{M} \models \phi$：
\begin{enumerate}
\item $\mathcal{M} \models P(t_1,\ldots,t_n)$ 当且仅当 $(I(t_1),\ldots,I(t_n)) \in I(P)$
\item $\mathcal{M} \models \forall x \phi$ 当且仅当 对所有$d \in D$，$\mathcal{M}[x/d] \models \phi$
\item $\mathcal{M} \models \exists x \phi$ 当且仅当 存在$d \in D$，$\mathcal{M}[x/d] \models \phi$
\end{enumerate}
\end{definition}
```

## 4. 模态逻辑

### 4.1 基本符号

```latex
% 模态算子
\Box \phi  % 必然φ
\Diamond \phi  % 可能φ

% 可能世界语义
w \in W  % w是可能世界
R \subseteq W \times W  % 可达关系
w \models \phi  % 在世界w中φ为真
```

### 4.2 模态逻辑语义

```latex
\begin{definition}[克里普克模型]
模态逻辑的克里普克模型是三元组$\mathcal{M} = (W, R, V)$，其中：
\begin{enumerate}
\item $W$是可能世界集合
\item $R \subseteq W \times W$是可达关系
\item $V: W \times \mathcal{P} \rightarrow \{0,1\}$是赋值函数
\end{enumerate}
\end{definition}

\begin{definition}[模态算子语义]
模态算子的语义定义：
\begin{enumerate}
\item $w \models \Box \phi$ 当且仅当 对所有$w'$，如果$wRw'$则$w' \models \phi$
\item $w \models \Diamond \phi$ 当且仅当 存在$w'$，$wRw'$且$w' \models \phi$
\end{enumerate}
\end{definition}
```

### 4.3 模态逻辑系统

```latex
\begin{definition}[K系统]
K系统包含以下公理和规则：
\begin{enumerate}
\item 命题逻辑的所有重言式
\item K公理：$\Box(\phi \rightarrow \psi) \rightarrow (\Box\phi \rightarrow \Box\psi)$
\item 必然化规则：$\frac{\phi}{\Box\phi}$
\end{enumerate}
\end{definition}

\begin{definition}[S5系统]
S5系统在K基础上增加：
\begin{enumerate}
\item T公理：$\Box\phi \rightarrow \phi$
\item 4公理：$\Box\phi \rightarrow \Box\Box\phi$
\item 5公理：$\Diamond\phi \rightarrow \Box\Diamond\phi$
\end{enumerate}
\end{definition}
```

## 5. 非经典逻辑

### 5.1 直觉主义逻辑

```latex
\begin{definition}[直觉主义逻辑]
直觉主义逻辑拒绝排中律，强调构造性证明：
\begin{enumerate}
\item 拒绝：$\phi \lor \neg\phi$
\item 接受：$\neg\neg\phi \rightarrow \phi$
\item 构造性：证明必须提供构造方法
\end{enumerate}
\end{definition}
```

### 5.2 模糊逻辑

```latex
\begin{definition}[模糊逻辑]
模糊逻辑处理模糊性和不确定性：
\begin{enumerate}
\item 真值：$v(\phi) \in [0,1]$
\item 模糊连接词：
  \begin{itemize}
  \item $v(\neg\phi) = 1 - v(\phi)$
  \item $v(\phi \land \psi) = \min(v(\phi), v(\psi))$
  \item $v(\phi \lor \psi) = \max(v(\phi), v(\psi))$
  \end{itemize}
\end{enumerate}
\end{definition}
```

### 5.3 时序逻辑

```latex
\begin{definition}[线性时序逻辑LTL]
LTL公式递归定义：
\begin{enumerate}
\item 原子命题是公式
\item 如果$\phi$和$\psi$是公式，则$\neg\phi$、$\phi \land \psi$、$\phi \lor \psi$、$\phi \rightarrow \psi$是公式
\item 如果$\phi$和$\psi$是公式，则$\text{X}\phi$、$\text{F}\phi$、$\text{G}\phi$、$\phi \text{U} \psi$是公式
\end{enumerate}
\end{definition}

\begin{definition}[LTL语义]
LTL算子的语义：
\begin{enumerate}
\item $\text{X}\phi$：下一个时刻φ为真
\item $\text{F}\phi$：将来某个时刻φ为真
\item $\text{G}\phi$：将来所有时刻φ为真
\item $\phi \text{U} \psi$：φ为真直到ψ为真
\end{enumerate}
\end{definition}
```

## 6. 逻辑哲学

### 6.1 逻辑的本质

```latex
\begin{definition}[逻辑多元主义]
存在多种有效的逻辑系统：
\begin{enumerate}
\item 经典逻辑：适用于数学和科学推理
\item 直觉主义逻辑：适用于构造性数学
\item 模糊逻辑：适用于不确定性推理
\item 模态逻辑：适用于可能性推理
\end{enumerate}
\end{definition}
```

### 6.2 逻辑与语言

```latex
\begin{theorem}[逻辑-语言对应]
逻辑系统与自然语言结构存在对应关系：
\begin{enumerate}
\item 命题逻辑 $\leftrightarrow$ 简单句
\item 谓词逻辑 $\leftrightarrow$ 复杂句
\item 模态逻辑 $\leftrightarrow$ 情态句
\item 时序逻辑 $\leftrightarrow$ 时态句
\end{enumerate}
\end{theorem}
```

## 7. 应用实例

### 7.1 软件验证中的逻辑

```rust
// 形式化验证中的逻辑应用
#[derive(Debug, Clone)]
pub struct LogicalVerifier {
    pub logic_system: LogicSystem,
    pub proof_methods: Set<ProofMethod>,
    pub verification_tools: Set<VerificationTool>,
}

impl LogicalVerifier {
    pub fn verify_property(&self, system: &System, property: &Property) -> VerificationResult {
        // 将系统转换为逻辑公式
        let system_formula = self.encode_system(system);
        let property_formula = self.encode_property(property);
        
        // 验证蕴含关系
        let implication = Implication {
            antecedent: system_formula,
            consequent: property_formula,
        };
        
        // 尝试证明
        for method in &self.proof_methods {
            if let Ok(proof) = method.prove(&implication) {
                return VerificationResult::Proven(proof);
            }
        }
        
        // 尝试反例生成
        for tool in &self.verification_tools {
            if let Some(counter_example) = tool.generate_counter_example(&implication) {
                return VerificationResult::Refuted(counter_example);
            }
        }
        
        VerificationResult::Unknown
    }
    
    pub fn encode_system(&self, system: &System) -> Formula {
        // 将软件系统编码为逻辑公式
        let mut formula = Formula::True;
        
        for component in &system.components {
            let component_formula = self.encode_component(component);
            formula = formula.and(component_formula);
        }
        
        for relation in &system.relations {
            let relation_formula = self.encode_relation(relation);
            formula = formula.and(relation_formula);
        }
        
        formula
    }
}

// 逻辑公式表示
#[derive(Debug, Clone)]
pub enum Formula {
    True,
    False,
    Atom(String),
    Not(Box<Formula>),
    And(Box<Formula>, Box<Formula>),
    Or(Box<Formula>, Box<Formula>),
    Implies(Box<Formula>, Box<Formula>),
    ForAll(String, Box<Formula>),
    Exists(String, Box<Formula>),
    Next(Box<Formula>),
    Always(Box<Formula>),
    Eventually(Box<Formula>),
    Until(Box<Formula>, Box<Formula>),
}

impl Formula {
    pub fn and(self, other: Formula) -> Formula {
        Formula::And(Box::new(self), Box::new(other))
    }
    
    pub fn or(self, other: Formula) -> Formula {
        Formula::Or(Box::new(self), Box::new(other))
    }
    
    pub fn implies(self, other: Formula) -> Formula {
        Formula::Implies(Box::new(self), Box::new(other))
    }
}
```

### 7.2 类型系统中的逻辑

```rust
// 类型系统中的逻辑应用
#[derive(Debug, Clone)]
pub struct TypeSystem {
    pub type_rules: Set<TypeRule>,
    pub type_constructors: Set<TypeConstructor>,
    pub type_checker: TypeChecker,
}

impl TypeSystem {
    pub fn type_check(&self, term: &Term, context: &Context) -> Result<Type, TypeError> {
        // 类型检查是逻辑推理过程
        let mut proof_tree = ProofTree::new();
        
        for rule in &self.type_rules {
            if rule.is_applicable(term, context) {
                let premises = rule.get_premises(term, context);
                let conclusion = rule.get_conclusion(term, context);
                
                // 递归检查前提
                for premise in premises {
                    self.type_check(&premise.term, &premise.context)?;
                }
                
                proof_tree.add_rule(rule.clone(), premises, conclusion.clone());
                return Ok(conclusion.typ);
            }
        }
        
        Err(TypeError::NoRuleApplicable)
    }
}

// 类型规则
#[derive(Debug, Clone)]
pub struct TypeRule {
    pub name: String,
    pub premises: Vec<TypeJudgment>,
    pub conclusion: TypeJudgment,
    pub condition: Option<Box<dyn Fn(&Term, &Context) -> bool>>,
}

impl TypeRule {
    pub fn is_applicable(&self, term: &Term, context: &Context) -> bool {
        if let Some(condition) = &self.condition {
            condition(term, context)
        } else {
            true
        }
    }
    
    pub fn get_premises(&self, term: &Term, context: &Context) -> Vec<TypeJudgment> {
        // 根据规则和项生成前提
        self.premises.clone()
    }
    
    pub fn get_conclusion(&self, term: &Term, context: &Context) -> TypeJudgment {
        // 根据规则和项生成结论
        TypeJudgment {
            context: context.clone(),
            term: term.clone(),
            typ: self.conclusion.typ.clone(),
        }
    }
}
```

### 7.3 数据库查询中的逻辑

```rust
// 数据库查询中的逻辑应用
#[derive(Debug, Clone)]
pub struct DatabaseQuery {
    pub tables: Set<Table>,
    pub conditions: Vec<Condition>,
    pub projections: Vec<Projection>,
    pub aggregations: Vec<Aggregation>,
}

impl DatabaseQuery {
    pub fn to_sql(&self) -> String {
        // 将逻辑查询转换为SQL
        let mut sql = String::new();
        
        // SELECT子句
        sql.push_str("SELECT ");
        for projection in &self.projections {
            sql.push_str(&projection.to_sql());
            sql.push_str(", ");
        }
        sql.pop(); // 移除最后的逗号
        sql.pop();
        
        // FROM子句
        sql.push_str(" FROM ");
        for table in &self.tables {
            sql.push_str(&table.name);
            sql.push_str(", ");
        }
        sql.pop();
        sql.pop();
        
        // WHERE子句
        if !self.conditions.is_empty() {
            sql.push_str(" WHERE ");
            for condition in &self.conditions {
                sql.push_str(&condition.to_sql());
                sql.push_str(" AND ");
            }
            sql.pop();
            sql.pop();
            sql.pop();
            sql.pop();
        }
        
        sql
    }
    
    pub fn optimize(&self) -> DatabaseQuery {
        // 基于逻辑规则优化查询
        let mut optimized = self.clone();
        
        // 应用逻辑等价规则
        optimized = self.apply_commutativity(optimized);
        optimized = self.apply_associativity(optimized);
        optimized = self.apply_distributivity(optimized);
        optimized = self.apply_idempotency(optimized);
        
        optimized
    }
}

// 查询条件
#[derive(Debug, Clone)]
pub enum Condition {
    Equal(Column, Value),
    NotEqual(Column, Value),
    GreaterThan(Column, Value),
    LessThan(Column, Value),
    And(Box<Condition>, Box<Condition>),
    Or(Box<Condition>, Box<Condition>),
    Not(Box<Condition>),
    Exists(Box<DatabaseQuery>),
    ForAll(Box<DatabaseQuery>),
}

impl Condition {
    pub fn to_sql(&self) -> String {
        match self {
            Condition::Equal(col, val) => format!("{} = {}", col.name, val),
            Condition::NotEqual(col, val) => format!("{} != {}", col.name, val),
            Condition::GreaterThan(col, val) => format!("{} > {}", col.name, val),
            Condition::LessThan(col, val) => format!("{} < {}", col.name, val),
            Condition::And(c1, c2) => format!("({}) AND ({})", c1.to_sql(), c2.to_sql()),
            Condition::Or(c1, c2) => format!("({}) OR ({})", c1.to_sql(), c2.to_sql()),
            Condition::Not(c) => format!("NOT ({})", c.to_sql()),
            Condition::Exists(query) => format!("EXISTS ({})", query.to_sql()),
            Condition::ForAll(query) => format!("NOT EXISTS (NOT ({}))", query.to_sql()),
        }
    }
}
```

---

**文档版本**：v1.0  
**创建时间**：2024-12-19  
**最后更新**：2024-12-19  
**状态**：完成

**相关链接**：
- [01-本体论形式化理论](./01-本体论形式化理论.md)
- [02-认识论形式化理论](./02-认识论形式化理论.md)
- [02-数学理论体系](../02-数学理论体系/01-集合论基础.md) 