# 02-01 集合论基础

## 目录

1. [基本概念](#1-基本概念)
2. [ZFC公理体系](#2-zfc公理体系)
3. [集合运算](#3-集合运算)
4. [关系与函数](#4-关系与函数)
5. [基数理论](#5-基数理论)
6. [序数理论](#6-序数理论)
7. [形式化表达](#7-形式化表达)
8. [应用实例](#8-应用实例)

## 1. 基本概念

### 定义 1.1 (集合)

集合是满足特定条件的对象的汇集。如果 $x$ 是集合 $A$ 的元素，记作 $x \in A$。

### 定义 1.2 (集合相等)

两个集合 $A$ 和 $B$ 相等，当且仅当它们包含相同的元素：
$$A = B \Leftrightarrow \forall x (x \in A \Leftrightarrow x \in B)$$

### 定义 1.3 (子集)

集合 $A$ 是集合 $B$ 的子集，记作 $A \subseteq B$，当且仅当：
$$A \subseteq B \Leftrightarrow \forall x (x \in A \Rightarrow x \in B)$$

### 定义 1.4 (真子集)

集合 $A$ 是集合 $B$ 的真子集，记作 $A \subset B$，当且仅当：
$$A \subset B \Leftrightarrow A \subseteq B \land A \neq B$$

## 2. ZFC公理体系

### 公理 2.1 (外延公理)

两个集合相等当且仅当它们包含相同的元素：
$$\forall A \forall B [\forall x (x \in A \Leftrightarrow x \in B) \Rightarrow A = B]$$

### 公理 2.2 (空集公理)

存在一个不包含任何元素的集合：
$$\exists A \forall x (x \notin A)$$

这个集合记作 $\emptyset$。

### 公理 2.3 (配对公理)

对于任意两个集合 $a$ 和 $b$，存在一个集合包含它们：
$$\forall a \forall b \exists A \forall x [x \in A \Leftrightarrow (x = a \lor x = b)]$$

这个集合记作 $\{a, b\}$。

### 公理 2.4 (并集公理)

对于任意集合族 $\mathcal{F}$，存在一个集合包含所有成员集合的元素：
$$\forall \mathcal{F} \exists A \forall x [x \in A \Leftrightarrow \exists B (B \in \mathcal{F} \land x \in B)]$$

这个集合记作 $\bigcup \mathcal{F}$。

### 公理 2.5 (幂集公理)

对于任意集合 $A$，存在一个集合包含 $A$ 的所有子集：
$$\forall A \exists P \forall x [x \in P \Leftrightarrow x \subseteq A]$$

这个集合记作 $\mathcal{P}(A)$。

### 公理 2.6 (分离公理模式)

对于任意集合 $A$ 和任意性质 $\phi(x)$，存在一个集合包含 $A$ 中满足 $\phi$ 的所有元素：
$$\forall A \exists B \forall x [x \in B \Leftrightarrow (x \in A \land \phi(x))]$$

这个集合记作 $\{x \in A : \phi(x)\}$。

### 公理 2.7 (无穷公理)

存在一个归纳集：
$$\exists A [\emptyset \in A \land \forall x (x \in A \Rightarrow x \cup \{x\} \in A)]$$

### 公理 2.8 (替换公理模式)

如果 $\phi(x, y)$ 是一个函数性质，那么对于任意集合 $A$，存在一个集合包含所有 $y$ 使得 $\phi(x, y)$ 对某个 $x \in A$ 成立：
$$\forall A [\forall x \in A \exists! y \phi(x, y) \Rightarrow \exists B \forall y (y \in B \Leftrightarrow \exists x \in A \phi(x, y))]$$

### 公理 2.9 (正则公理)

每个非空集合都有一个 $\in$-极小元素：
$$\forall A [A \neq \emptyset \Rightarrow \exists x \in A (x \cap A = \emptyset)]$$

### 公理 2.10 (选择公理)

对于任意非空集合族，存在一个选择函数：
$$\forall \mathcal{F} [\emptyset \notin \mathcal{F} \Rightarrow \exists f : \mathcal{F} \rightarrow \bigcup \mathcal{F} \forall A \in \mathcal{F} (f(A) \in A)]$$

## 3. 集合运算

### 定义 3.1 (并集)

两个集合 $A$ 和 $B$ 的并集是：
$$A \cup B = \{x : x \in A \lor x \in B\}$$

### 定义 3.2 (交集)

两个集合 $A$ 和 $B$ 的交集是：
$$A \cap B = \{x : x \in A \land x \in B\}$$

### 定义 3.3 (差集)

集合 $A$ 相对于集合 $B$ 的差集是：
$$A \setminus B = \{x : x \in A \land x \notin B\}$$

### 定义 3.4 (对称差)

两个集合 $A$ 和 $B$ 的对称差是：
$$A \triangle B = (A \setminus B) \cup (B \setminus A)$$

### 定理 3.1 (德摩根律)

对于任意集合 $A$, $B$, $C$：
$$\begin{align}
A \setminus (B \cup C) &= (A \setminus B) \cap (A \setminus C) \\
A \setminus (B \cap C) &= (A \setminus B) \cup (A \setminus C)
\end{align}$$

**证明**：
1. $x \in A \setminus (B \cup C) \Leftrightarrow x \in A \land x \notin (B \cup C)$
2. $\Leftrightarrow x \in A \land (x \notin B \land x \notin C)$
3. $\Leftrightarrow (x \in A \land x \notin B) \land (x \in A \land x \notin C)$
4. $\Leftrightarrow x \in (A \setminus B) \cap (A \setminus C)$

### 定理 3.2 (分配律)
对于任意集合 $A$, $B$, $C$：
$$\begin{align}
A \cap (B \cup C) &= (A \cap B) \cup (A \cap C) \\
A \cup (B \cap C) &= (A \cup B) \cap (A \cup C)
\end{align}$$

## 4. 关系与函数

### 定义 4.1 (有序对)
有序对 $(a, b)$ 定义为：
$$(a, b) = \{\{a\}, \{a, b\}\}$$

### 定义 4.2 (笛卡尔积)
两个集合 $A$ 和 $B$ 的笛卡尔积是：
$$A \times B = \{(a, b) : a \in A \land b \in B\}$$

### 定义 4.3 (关系)
从集合 $A$ 到集合 $B$ 的关系是 $A \times B$ 的子集。

### 定义 4.4 (函数)
函数 $f$ 从集合 $A$ 到集合 $B$ 是一个关系，满足：
$$\forall x \in A \exists! y \in B ((x, y) \in f)$$

记作 $f : A \rightarrow B$。

### 定义 4.5 (函数类型)
- **单射**：$\forall x_1, x_2 \in A (f(x_1) = f(x_2) \Rightarrow x_1 = x_2)$
- **满射**：$\forall y \in B \exists x \in A (f(x) = y)$
- **双射**：既是单射又是满射

### 定理 4.1 (函数复合)
如果 $f : A \rightarrow B$ 和 $g : B \rightarrow C$，则 $g \circ f : A \rightarrow C$ 定义为：
$$(g \circ f)(x) = g(f(x))$$

## 5. 基数理论

### 定义 5.1 (等势)
两个集合 $A$ 和 $B$ 等势，记作 $A \approx B$，当且仅当存在从 $A$ 到 $B$ 的双射。

### 定义 5.2 (基数)
集合 $A$ 的基数 $|A|$ 是与 $A$ 等势的所有集合的等价类。

### 定义 5.3 (有限集)
集合 $A$ 是有限的，当且仅当存在自然数 $n$ 使得 $A \approx \{0, 1, \ldots, n-1\}$。

### 定义 5.4 (可数集)
集合 $A$ 是可数的，当且仅当 $A \approx \mathbb{N}$。

### 定理 5.1 (康托尔定理)
对于任意集合 $A$，$|A| < |\mathcal{P}(A)|$。

**证明**：
1. 假设存在双射 $f : A \rightarrow \mathcal{P}(A)$
2. 定义 $B = \{x \in A : x \notin f(x)\}$
3. 由于 $f$ 是满射，存在 $a \in A$ 使得 $f(a) = B$
4. 如果 $a \in B$，则 $a \notin f(a) = B$，矛盾
5. 如果 $a \notin B$，则 $a \in f(a) = B$，矛盾
6. 因此不存在这样的双射

### 定理 5.2 (施罗德-伯恩斯坦定理)
如果 $|A| \leq |B|$ 且 $|B| \leq |A|$，则 $|A| = |B|$。

## 6. 序数理论

### 定义 6.1 (良序集)
集合 $A$ 上的关系 $<$ 是良序，当且仅当：
1. $<$ 是全序
2. $A$ 的每个非空子集都有最小元素

### 定义 6.2 (序数)
序数是传递的良序集。

### 定义 6.3 (后继序数)
序数 $\alpha$ 的后继是 $\alpha + 1 = \alpha \cup \{\alpha\}$。

### 定义 6.4 (极限序数)
序数 $\alpha$ 是极限序数，当且仅当 $\alpha \neq 0$ 且 $\alpha$ 不是后继序数。

### 定理 6.1 (序数良序定理)
序数类 $\text{Ord}$ 上的 $\in$ 关系是良序。

### 定理 6.2 (超限归纳)
如果 $\phi(\alpha)$ 是序数的性质，且：
1. $\phi(0)$ 成立
2. $\phi(\alpha) \Rightarrow \phi(\alpha + 1)$
3. 对于极限序数 $\lambda$，$\forall \alpha < \lambda \phi(\alpha) \Rightarrow \phi(\lambda)$

则 $\forall \alpha \phi(\alpha)$。

## 7. 形式化表达

### 7.1 类型论表达

集合论可以用类型论表达：

```haskell
-- 集合类型
data Set a = Set [a]

-- 集合操作
class SetOperations a where
  -- 成员关系
  member :: a -> Set a -> Bool
  
  -- 子集关系
  subset :: Set a -> Set a -> Bool
  
  -- 并集
  union :: Set a -> Set a -> Set a
  
  -- 交集
  intersection :: Set a -> Set a -> Set a
  
  -- 差集
  difference :: Set a -> Set a -> Set a

-- 关系类型
data Relation a b = Relation [(a, b)]

-- 函数类型
data Function a b = Function (a -> b)

-- 基数类型
data Cardinality = Finite Int | Countable | Uncountable
```

### 7.2 范畴论表达

集合论也可以用范畴论表达：

```haskell
-- 集合范畴
class SetCategory where
  type Object
  type Morphism
  
  -- 对象是集合
  object :: Set a -> Object
  
  -- 态射是函数
  morphism :: Function a b -> Morphism
  
  -- 恒等态射
  identity :: Object -> Morphism
  
  -- 态射复合
  compose :: Morphism -> Morphism -> Morphism

-- 幂集函子
class PowerSetFunctor where
  -- 幂集对象映射
  powerSetObject :: Object -> Object
  
  -- 幂集态射映射
  powerSetMorphism :: Morphism -> Morphism
```

## 8. 应用实例

### 8.1 软件系统中的集合论

在软件系统中应用集合论：

```rust
// 集合实现
# [derive(Debug, Clone, PartialEq)]
pub struct Set<T: Clone + PartialEq> {
    elements: Vec<T>,
}

impl<T: Clone + PartialEq> Set<T> {
    // 创建空集
    pub fn new() -> Self {
        Set { elements: Vec::new() }
    }

    // 创建单元素集
    pub fn singleton(element: T) -> Self {
        Set { elements: vec![element] }
    }

    // 添加元素
    pub fn insert(&mut self, element: T) {
        if !self.contains(&element) {
            self.elements.push(element);
        }
    }

    // 移除元素
    pub fn remove(&mut self, element: &T) {
        self.elements.retain(|x| x != element);
    }

    // 检查成员关系
    pub fn contains(&self, element: &T) -> bool {
        self.elements.contains(element)
    }

    // 子集关系
    pub fn is_subset(&self, other: &Set<T>) -> bool {
        self.elements.iter().all(|x| other.contains(x))
    }

    // 并集
    pub fn union(&self, other: &Set<T>) -> Set<T> {
        let mut result = self.clone();
        for element in &other.elements {
            result.insert(element.clone());
        }
        result
    }

    // 交集
    pub fn intersection(&self, other: &Set<T>) -> Set<T> {
        let mut result = Set::new();
        for element in &self.elements {
            if other.contains(element) {
                result.insert(element.clone());
            }
        }
        result
    }

    // 差集
    pub fn difference(&self, other: &Set<T>) -> Set<T> {
        let mut result = Set::new();
        for element in &self.elements {
            if !other.contains(element) {
                result.insert(element.clone());
            }
        }
        result
    }

    // 对称差
    pub fn symmetric_difference(&self, other: &Set<T>) -> Set<T> {
        self.difference(other).union(&other.difference(self))
    }

    // 幂集
    pub fn power_set(&self) -> Set<Set<T>> {
        let mut result = Set::new();
        let n = self.elements.len();

        // 生成所有子集
        for i in 0..(1 << n) {
            let mut subset = Set::new();
            for j in 0..n {
                if (i >> j) & 1 == 1 {
                    subset.insert(self.elements[j].clone());
                }
            }
            result.insert(subset);
        }

        result
    }

    // 笛卡尔积
    pub fn cartesian_product<U: Clone + PartialEq>(&self, other: &Set<U>) -> Set<(T, U)> {
        let mut result = Set::new();
        for a in &self.elements {
            for b in &other.elements {
                result.insert((a.clone(), b.clone()));
            }
        }
        result
    }
}

// 关系实现
# [derive(Debug, Clone)]
pub struct Relation<T: Clone + PartialEq, U: Clone + PartialEq> {
    pairs: Set<(T, U)>,
}

impl<T: Clone + PartialEq, U: Clone + PartialEq> Relation<T, U> {
    // 创建空关系
    pub fn new() -> Self {
        Relation { pairs: Set::new() }
    }

    // 添加有序对
    pub fn insert(&mut self, pair: (T, U)) {
        self.pairs.insert(pair);
    }

    // 检查关系
    pub fn relates(&self, x: &T, y: &U) -> bool {
        self.pairs.contains(&(x.clone(), y.clone()))
    }

    // 定义域
    pub fn domain(&self) -> Set<T> {
        let mut result = Set::new();
        for (x, _) in &self.pairs.elements {
            result.insert(x.clone());
        }
        result
    }

    // 值域
    pub fn range(&self) -> Set<U> {
        let mut result = Set::new();
        for (_, y) in &self.pairs.elements {
            result.insert(y.clone());
        }
        result
    }
}

// 函数实现
# [derive(Debug, Clone)]
pub struct Function<T: Clone + PartialEq, U: Clone + PartialEq> {
    relation: Relation<T, U>,
}

impl<T: Clone + PartialEq, U: Clone + PartialEq> Function<T, U> {
    // 创建函数
    pub fn new() -> Self {
        Function { relation: Relation::new() }
    }

    // 定义函数值
    pub fn define(&mut self, x: T, y: U) {
        self.relation.insert((x, y));
    }

    // 函数应用
    pub fn apply(&self, x: &T) -> Option<U> {
        for (a, b) in &self.relation.pairs.elements {
            if a == x {
                return Some(b.clone());
            }
        }
        None
    }

    // 检查是否为函数
    pub fn is_function(&self) -> bool {
        // 检查每个定义域元素都有唯一的函数值
        let domain = self.relation.domain();
        for x in &domain.elements {
            let mut count = 0;
            for (a, _) in &self.relation.pairs.elements {
                if a == x {
                    count += 1;
                }
            }
            if count != 1 {
                return false;
            }
        }
        true
    }
}
```

### 8.2 基数计算

实现基数计算：

```rust
// 基数类型
# [derive(Debug, Clone, PartialEq)]
pub enum Cardinality {
    Finite(usize),
    Countable,
    Uncountable,
}

impl<T: Clone + PartialEq> Set<T> {
    // 计算基数
    pub fn cardinality(&self) -> Cardinality {
        let n = self.elements.len();
        Cardinality::Finite(n)
    }

    // 检查是否有限
    pub fn is_finite(&self) -> bool {
        true // 在计算机中所有集合都是有限的
    }

    // 检查是否可数
    pub fn is_countable(&self) -> bool {
        self.is_finite()
    }

    // 检查是否等势
    pub fn is_equinumerous(&self, other: &Set<T>) -> bool {
        self.elements.len() == other.elements.len()
    }
}
```

## 总结

本文档建立了严格的集合论基础，包括：

1. **基本概念**：集合、子集、相等关系
2. **ZFC公理体系**：完整的公理化基础
3. **集合运算**：并、交、差、对称差
4. **关系与函数**：有序对、笛卡尔积、函数类型
5. **基数理论**：等势、基数、康托尔定理
6. **序数理论**：良序、序数、超限归纳
7. **形式化表达**：类型论和范畴论表达
8. **应用实例**：软件系统中的集合论应用

这个基础为后续的数学理论构建提供了严格的公理化基础。
