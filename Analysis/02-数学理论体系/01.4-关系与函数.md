# 关系与函数理论

## 目录

1. [关系基础](#10-关系基础)
2. [等价关系](#20-等价关系)
3. [序关系](#30-序关系)
4. [函数基础](#40-函数基础)
5. [函数分类](#50-函数分类)
6. [函数运算](#60-函数运算)
7. [函数空间](#70-函数空间)
8. [关系与函数应用](#80-关系与函数应用)
9. [关系数据库理论](#90-关系数据库理论)
10. [函数式编程](#100-函数式编程)

---

## 1.0 关系基础

### 1.1 关系定义

**定义 1.1.1** 二元关系
设 $A$ 和 $B$ 为集合，$A$ 到 $B$ 的二元关系 $R$ 是笛卡尔积 $A \times B$ 的子集：
$$R \subseteq A \times B$$

**定义 1.1.2** 关系表示
- 集合表示：$R = \{(a, b) \mid a \in A, b \in B, aRb\}$
- 矩阵表示：$M_R[i,j] = 1$ 当且仅当 $(a_i, b_j) \in R$
- 图表示：有向图 $G = (V, E)$ 其中 $V = A \cup B$

```rust
#[derive(Debug, Clone)]
struct BinaryRelation<T> {
    domain: Vec<T>,
    codomain: Vec<T>,
    pairs: Vec<(T, T)>,
}

impl<T: Clone + Eq + Hash> BinaryRelation<T> {
    fn new(domain: Vec<T>, codomain: Vec<T>) -> Self {
        Self {
            domain,
            codomain,
            pairs: Vec::new(),
        }
    }
    
    fn add_pair(&mut self, a: T, b: T) {
        self.pairs.push((a, b));
    }
    
    fn contains(&self, a: &T, b: &T) -> bool {
        self.pairs.contains(&(a.clone(), b.clone()))
    }
    
    fn matrix_representation(&self) -> Vec<Vec<bool>> {
        let mut matrix = vec![vec![false; self.codomain.len()]; self.domain.len()];
        for (a, b) in &self.pairs {
            if let (Some(i), Some(j)) = (
                self.domain.iter().position(|x| x == a),
                self.codomain.iter().position(|x| x == b)
            ) {
                matrix[i][j] = true;
            }
        }
        matrix
    }
}
```

### 1.2 关系性质

**定义 1.2.1** 自反性
关系 $R$ 在集合 $A$ 上自反当且仅当：
$$\forall a \in A: (a, a) \in R$$

**定义 1.2.2** 对称性
关系 $R$ 在集合 $A$ 上对称当且仅当：
$$\forall a, b \in A: (a, b) \in R \Rightarrow (b, a) \in R$$

**定义 1.2.3** 反对称性
关系 $R$ 在集合 $A$ 上反对称当且仅当：
$$\forall a, b \in A: (a, b) \in R \land (b, a) \in R \Rightarrow a = b$$

**定义 1.2.4** 传递性
关系 $R$ 在集合 $A$ 上传递当且仅当：
$$\forall a, b, c \in A: (a, b) \in R \land (b, c) \in R \Rightarrow (a, c) \in R$$

```rust
impl<T: Clone + Eq + Hash> BinaryRelation<T> {
    fn is_reflexive(&self) -> bool {
        self.domain.iter().all(|a| self.contains(a, a))
    }
    
    fn is_symmetric(&self) -> bool {
        self.pairs.iter().all(|(a, b)| self.contains(b, a))
    }
    
    fn is_antisymmetric(&self) -> bool {
        self.pairs.iter().all(|(a, b)| {
            if self.contains(b, a) {
                a == b
            } else {
                true
            }
        })
    }
    
    fn is_transitive(&self) -> bool {
        for (a, b) in &self.pairs {
            for (c, d) in &self.pairs {
                if b == c && !self.contains(a, d) {
                    return false;
                }
            }
        }
        true
    }
}
```

### 1.3 关系运算

**定义 1.3.1** 关系合成
设 $R \subseteq A \times B$ 和 $S \subseteq B \times C$，则合成关系：
$$R \circ S = \{(a, c) \mid \exists b \in B: (a, b) \in R \land (b, c) \in S\}$$

**定义 1.3.2** 关系逆
关系 $R$ 的逆关系：
$$R^{-1} = \{(b, a) \mid (a, b) \in R\}$$

**定理 1.3.1** 关系合成结合律
$$(R \circ S) \circ T = R \circ (S \circ T)$$

```rust
impl<T: Clone + Eq + Hash> BinaryRelation<T> {
    fn compose<U: Clone + Eq + Hash>(&self, other: &BinaryRelation<T>) -> BinaryRelation<T> {
        let mut result = BinaryRelation::new(self.domain.clone(), other.codomain.clone());
        
        for (a, b) in &self.pairs {
            for (c, d) in &other.pairs {
                if b == c {
                    result.add_pair(a.clone(), d.clone());
                }
            }
        }
        
        result
    }
    
    fn inverse(&self) -> BinaryRelation<T> {
        let mut result = BinaryRelation::new(self.codomain.clone(), self.domain.clone());
        
        for (a, b) in &self.pairs {
            result.add_pair(b.clone(), a.clone());
        }
        
        result
    }
    
    fn power(&self, n: usize) -> BinaryRelation<T> {
        if n == 0 {
            // 返回恒等关系
            let mut result = BinaryRelation::new(self.domain.clone(), self.domain.clone());
            for a in &self.domain {
                result.add_pair(a.clone(), a.clone());
            }
            result
        } else if n == 1 {
            self.clone()
        } else {
            let mut result = self.clone();
            for _ in 1..n {
                result = result.compose(self);
            }
            result
        }
    }
}
```

## 2.0 等价关系

### 2.1 等价关系定义

**定义 2.1.1** 等价关系
关系 $R$ 在集合 $A$ 上是等价关系当且仅当：
- 自反性：$\forall a \in A: (a, a) \in R$
- 对称性：$\forall a, b \in A: (a, b) \in R \Rightarrow (b, a) \in R$
- 传递性：$\forall a, b, c \in A: (a, b) \in R \land (b, c) \in R \Rightarrow (a, c) \in R$

**定义 2.1.2** 等价类
设 $R$ 为 $A$ 上的等价关系，$a \in A$，则 $a$ 的等价类：
$$[a]_R = \{b \in A \mid (a, b) \in R\}$$

**定理 2.1.1** 等价类性质
1. $\forall a \in A: a \in [a]_R$
2. $\forall a, b \in A: [a]_R = [b]_R \lor [a]_R \cap [b]_R = \emptyset$
3. $\bigcup_{a \in A} [a]_R = A$

```rust
#[derive(Debug, Clone)]
struct EquivalenceRelation<T> {
    relation: BinaryRelation<T>,
}

impl<T: Clone + Eq + Hash> EquivalenceRelation<T> {
    fn new(domain: Vec<T>) -> Self {
        Self {
            relation: BinaryRelation::new(domain.clone(), domain),
        }
    }
    
    fn is_equivalence(&self) -> bool {
        self.relation.is_reflexive() && 
        self.relation.is_symmetric() && 
        self.relation.is_transitive()
    }
    
    fn equivalence_class(&self, element: &T) -> Vec<T> {
        self.relation.domain.iter()
            .filter(|a| self.relation.contains(element, a))
            .cloned()
            .collect()
    }
    
    fn partition(&self) -> Vec<Vec<T>> {
        let mut partition = Vec::new();
        let mut processed = std::collections::HashSet::new();
        
        for a in &self.relation.domain {
            if !processed.contains(a) {
                let class = self.equivalence_class(a);
                for element in &class {
                    processed.insert(element.clone());
                }
                partition.push(class);
            }
        }
        
        partition
    }
}
```

### 2.2 商集与自然映射

**定义 2.2.1** 商集
设 $R$ 为 $A$ 上的等价关系，商集：
$$A/R = \{[a]_R \mid a \in A\}$$

**定义 2.2.2** 自然映射
自然映射 $\pi: A \rightarrow A/R$ 定义为：
$$\pi(a) = [a]_R$$

**定理 2.2.1** 商集性质
1. $A/R$ 是 $A$ 的划分
2. $\pi$ 是满射
3. $\ker(\pi) = R$

```rust
impl<T: Clone + Eq + Hash> EquivalenceRelation<T> {
    fn quotient_set(&self) -> Vec<Vec<T>> {
        self.partition()
    }
    
    fn natural_map(&self, element: &T) -> Vec<T> {
        self.equivalence_class(element)
    }
    
    fn kernel(&self) -> BinaryRelation<T> {
        self.relation.clone()
    }
}
```

## 3.0 序关系

### 3.1 偏序关系

**定义 3.1.1** 偏序关系
关系 $R$ 在集合 $A$ 上是偏序关系当且仅当：
- 自反性：$\forall a \in A: (a, a) \in R$
- 反对称性：$\forall a, b \in A: (a, b) \in R \land (b, a) \in R \Rightarrow a = b$
- 传递性：$\forall a, b, c \in A: (a, b) \in R \land (b, c) \in R \Rightarrow (a, c) \in R$

**定义 3.1.2** 全序关系
偏序关系 $R$ 是全序关系当且仅当：
$$\forall a, b \in A: (a, b) \in R \lor (b, a) \in R$$

```rust
#[derive(Debug, Clone)]
struct PartialOrder<T> {
    relation: BinaryRelation<T>,
}

impl<T: Clone + Eq + Hash> PartialOrder<T> {
    fn new(domain: Vec<T>) -> Self {
        Self {
            relation: BinaryRelation::new(domain.clone(), domain),
        }
    }
    
    fn is_partial_order(&self) -> bool {
        self.relation.is_reflexive() && 
        self.relation.is_antisymmetric() && 
        self.relation.is_transitive()
    }
    
    fn is_total_order(&self) -> bool {
        if !self.is_partial_order() {
            return false;
        }
        
        for a in &self.relation.domain {
            for b in &self.relation.domain {
                if !self.relation.contains(a, b) && !self.relation.contains(b, a) {
                    return false;
                }
            }
        }
        true
    }
    
    fn minimal_elements(&self) -> Vec<T> {
        self.relation.domain.iter()
            .filter(|a| {
                self.relation.domain.iter()
                    .all(|b| !self.relation.contains(b, a) || a == b)
            })
            .cloned()
            .collect()
    }
    
    fn maximal_elements(&self) -> Vec<T> {
        self.relation.domain.iter()
            .filter(|a| {
                self.relation.domain.iter()
                    .all(|b| !self.relation.contains(a, b) || a == b)
            })
            .cloned()
            .collect()
    }
}
```

### 3.2 格与布尔代数

**定义 3.2.1** 格
偏序集 $(L, \leq)$ 是格当且仅当任意两个元素都有最小上界和最大下界：
- 最小上界：$\sup\{a, b\} = a \lor b$
- 最大下界：$\inf\{a, b\} = a \land b$

**定义 3.2.2** 布尔代数
布尔代数 $(B, \lor, \land, \neg, 0, 1)$ 满足：
- 交换律：$a \lor b = b \lor a$, $a \land b = b \land a$
- 结合律：$(a \lor b) \lor c = a \lor (b \lor c)$
- 分配律：$a \land (b \lor c) = (a \land b) \lor (a \land c)$
- 补律：$a \lor \neg a = 1$, $a \land \neg a = 0$

```rust
#[derive(Debug, Clone)]
struct Lattice<T> {
    order: PartialOrder<T>,
    join: fn(&T, &T) -> T,
    meet: fn(&T, &T) -> T,
}

impl<T: Clone + Eq + Hash> Lattice<T> {
    fn new(
        domain: Vec<T>, 
        join: fn(&T, &T) -> T, 
        meet: fn(&T, &T) -> T
    ) -> Self {
        Self {
            order: PartialOrder::new(domain),
            join,
            meet,
        }
    }
    
    fn join(&self, a: &T, b: &T) -> T {
        (self.join)(a, b)
    }
    
    fn meet(&self, a: &T, b: &T) -> T {
        (self.meet)(a, b)
    }
}

#[derive(Debug, Clone)]
struct BooleanAlgebra<T> {
    lattice: Lattice<T>,
    complement: fn(&T) -> T,
    zero: T,
    one: T,
}

impl<T: Clone + Eq + Hash> BooleanAlgebra<T> {
    fn complement(&self, a: &T) -> T {
        (self.complement)(a)
    }
    
    fn de_morgan_law(&self, a: &T, b: &T) -> bool {
        let left = self.complement(&self.lattice.join(a, b));
        let right = self.lattice.meet(&self.complement(a), &self.complement(b));
        left == right
    }
}
```

---

## 4.0 函数基础

### 4.1 函数定义

**定义 4.1.1** 函数
设 $A$ 和 $B$ 为集合，函数 $f: A \rightarrow B$ 是满足以下条件的二元关系：
$$\forall a \in A: \exists! b \in B: (a, b) \in f$$

**定义 4.1.2** 函数表示
- 集合表示：$f = \{(a, f(a)) \mid a \in A\}$
- 公式表示：$f(x) = \text{expression}$
- 图形表示：函数图像

```rust
#[derive(Debug, Clone)]
struct Function<T, U> {
    domain: Vec<T>,
    codomain: Vec<U>,
    mapping: HashMap<T, U>,
}

impl<T: Clone + Eq + Hash, U: Clone> Function<T, U> {
    fn new(domain: Vec<T>, codomain: Vec<U>) -> Self {
        Self {
            domain,
            codomain,
            mapping: HashMap::new(),
        }
    }
    
    fn apply(&self, x: &T) -> Option<&U> {
        self.mapping.get(x)
    }
    
    fn is_well_defined(&self) -> bool {
        self.domain.iter().all(|a| self.mapping.contains_key(a))
    }
    
    fn image(&self) -> Vec<U> {
        self.mapping.values().cloned().collect()
    }
    
    fn preimage(&self, y: &U) -> Vec<T> {
        self.mapping.iter()
            .filter(|(_, v)| v == &y)
            .map(|(k, _)| k.clone())
            .collect()
    }
}
```

### 4.2 函数性质

**定义 4.2.1** 单射（一对一）
函数 $f: A \rightarrow B$ 是单射当且仅当：
$$\forall a_1, a_2 \in A: f(a_1) = f(a_2) \Rightarrow a_1 = a_2$$

**定义 4.2.2** 满射（映上）
函数 $f: A \rightarrow B$ 是满射当且仅当：
$$\forall b \in B: \exists a \in A: f(a) = b$$

**定义 4.2.3** 双射（一一对应）
函数 $f: A \rightarrow B$ 是双射当且仅当它既是单射又是满射。

```rust
impl<T: Clone + Eq + Hash, U: Clone + Eq + Hash> Function<T, U> {
    fn is_injective(&self) -> bool {
        let mut seen = HashSet::new();
        for value in self.mapping.values() {
            if !seen.insert(value) {
                return false;
            }
        }
        true
    }
    
    fn is_surjective(&self) -> bool {
        let image: HashSet<_> = self.mapping.values().collect();
        let codomain: HashSet<_> = self.codomain.iter().collect();
        image == codomain
    }
    
    fn is_bijective(&self) -> bool {
        self.is_injective() && self.is_surjective()
    }
    
    fn inverse(&self) -> Option<Function<U, T>> {
        if !self.is_bijective() {
            return None;
        }
        
        let mut inverse_mapping = HashMap::new();
        for (k, v) in &self.mapping {
            inverse_mapping.insert(v.clone(), k.clone());
        }
        
        Some(Function {
            domain: self.codomain.clone(),
            codomain: self.domain.clone(),
            mapping: inverse_mapping,
        })
    }
}
```

---

## 总结

关系与函数是数学的基础概念，它们在集合论、代数、分析等各个数学分支中都有重要应用。关系理论为等价关系、序关系等提供了统一的框架，而函数理论则为映射、变换等概念提供了严格的数学基础。

在现代计算机科学中，关系理论支撑着数据库理论，函数理论支撑着函数式编程范式，这些理论为软件系统的设计和实现提供了重要的理论基础。 