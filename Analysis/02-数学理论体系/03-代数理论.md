# 03-代数理论

## 目录

1. [基本概念](#1-基本概念)
2. [群论](#2-群论)
3. [环论](#3-环论)
4. [域论](#4-域论)
5. [模论](#5-模论)
6. [线性代数](#6-线性代数)
7. [应用实例](#7-应用实例)

## 1. 基本概念

### 1.1 代数结构概述

代数理论研究具有运算的集合的结构性质。在形式化架构理论中，代数理论为软件系统的抽象结构和操作提供数学基础。

### 1.2 基本运算

```latex
\begin{definition}[二元运算]
集合 $A$ 上的二元运算是函数：
$$\circ: A \times A \rightarrow A$$
\end{definition}

\begin{definition}[运算性质]
二元运算 $\circ$ 具有以下性质：
\begin{enumerate}
\item 结合律：$(a \circ b) \circ c = a \circ (b \circ c)$
\item 交换律：$a \circ b = b \circ a$
\item 单位元：$\exists e \in A, \forall a \in A, e \circ a = a \circ e = a$
\item 逆元：$\forall a \in A, \exists a^{-1} \in A, a \circ a^{-1} = a^{-1} \circ a = e$
\end{enumerate}
\end{definition}
```

## 2. 群论

### 2.1 群的定义

```latex
\begin{definition}[群]
群是四元组 $(G, \circ, e, ^{-1})$，其中：
\begin{enumerate}
\item $G$ 是非空集合
\item $\circ: G \times G \rightarrow G$ 是二元运算
\item $e \in G$ 是单位元
\item $^{-1}: G \rightarrow G$ 是逆元函数
\end{enumerate}
满足以下公理：
\begin{enumerate}
\item 结合律：$(a \circ b) \circ c = a \circ (b \circ c)$
\item 单位律：$e \circ a = a \circ e = a$
\item 逆元律：$a \circ a^{-1} = a^{-1} \circ a = e$
\end{enumerate}
\end{definition}
```

### 2.2 群的性质

```latex
\begin{theorem}[群的基本性质]
对于群 $(G, \circ, e, ^{-1})$：
\begin{enumerate}
\item 单位元唯一：如果 $e'$ 也是单位元，则 $e = e'$
\item 逆元唯一：如果 $b, c$ 都是 $a$ 的逆元，则 $b = c$
\item 消去律：$a \circ b = a \circ c \Rightarrow b = c$
\item 逆元的逆元：$(a^{-1})^{-1} = a$
\item 积的逆元：$(a \circ b)^{-1} = b^{-1} \circ a^{-1}$
\end{enumerate}
\end{theorem}

\begin{proof}
\textbf{证明单位元唯一：}
\begin{enumerate}
\item 设 $e'$ 是另一个单位元
\item 则 $e = e \circ e' = e'$
\item 因此 $e = e'$
\end{enumerate}
\end{proof}
```

### 2.3 子群

```latex
\begin{definition}[子群]
群 $(G, \circ, e, ^{-1})$ 的子群是子集 $H \subseteq G$ 使得：
\begin{enumerate}
\item $e \in H$
\item $\forall a, b \in H, a \circ b \in H$
\item $\forall a \in H, a^{-1} \in H$
\end{enumerate}
\end{definition}

\begin{theorem}[子群判定定理]
子集 $H \subseteq G$ 是子群当且仅当：
$$\forall a, b \in H, a \circ b^{-1} \in H$$
\end{theorem}
```

### 2.4 同态与同构

```latex
\begin{definition}[群同态]
群 $(G, \circ, e_G, ^{-1})$ 到群 $(H, \cdot, e_H, ^{-1})$ 的同态是函数 $f: G \rightarrow H$ 使得：
$$\forall a, b \in G, f(a \circ b) = f(a) \cdot f(b)$$
\end{definition}

\begin{definition}[群同构]
群同态 $f: G \rightarrow H$ 是同构当且仅当 $f$ 是双射。
\end{definition}

\begin{theorem}[同态基本定理]
如果 $f: G \rightarrow H$ 是群同态，则：
$$G / \ker(f) \cong \text{im}(f)$$
\end{theorem}
```

## 3. 环论

### 3.1 环的定义

```latex
\begin{definition}[环]
环是六元组 $(R, +, \cdot, 0, 1, -)$，其中：
\begin{enumerate}
\item $(R, +, 0, -)$ 是阿贝尔群
\item $(R, \cdot, 1)$ 是幺半群
\item 分配律：$a \cdot (b + c) = a \cdot b + a \cdot c$ 和 $(a + b) \cdot c = a \cdot c + b \cdot c$
\end{enumerate}
\end{definition}
```

### 3.2 环的性质

```latex
\begin{theorem}[环的基本性质]
对于环 $(R, +, \cdot, 0, 1, -)$：
\begin{enumerate}
\item $0 \cdot a = a \cdot 0 = 0$
\item $(-a) \cdot b = a \cdot (-b) = -(a \cdot b)$
\item $(-a) \cdot (-b) = a \cdot b$
\end{enumerate}
\end{theorem}

\begin{definition}[交换环]
环 $R$ 是交换环当且仅当：
$$\forall a, b \in R, a \cdot b = b \cdot a$$
\end{definition}

\begin{definition}[整环]
环 $R$ 是整环当且仅当：
$$\forall a, b \in R, a \cdot b = 0 \Rightarrow a = 0 \lor b = 0$$
\end{definition}
```

### 3.3 理想

```latex
\begin{definition}[理想]
环 $R$ 的理想是子集 $I \subseteq R$ 使得：
\begin{enumerate}
\item $(I, +)$ 是 $(R, +)$ 的子群
\item $\forall a \in I, \forall r \in R, a \cdot r \in I$ 和 $r \cdot a \in I$
\end{enumerate}
\end{definition}

\begin{theorem}[理想判定定理]
子集 $I \subseteq R$ 是理想当且仅当：
$$\forall a, b \in I, \forall r \in R, a - b \in I \land a \cdot r \in I \land r \cdot a \in I$$
\end{theorem}
```

## 4. 域论

### 4.1 域的定义

```latex
\begin{definition}[域]
域是环 $(F, +, \cdot, 0, 1, -)$ 使得：
\begin{enumerate}
\item $F \setminus \{0\}$ 在乘法下构成群
\item 即：$\forall a \in F \setminus \{0\}, \exists a^{-1} \in F, a \cdot a^{-1} = 1$
\end{enumerate}
\end{definition}
```

### 4.2 域的性质

```latex
\begin{theorem}[域的基本性质]
对于域 $(F, +, \cdot, 0, 1, -)$：
\begin{enumerate}
\item $F$ 是整环
\item $F$ 是交换环
\item 非零元素都有乘法逆元
\end{enumerate}
\end{theorem}

\begin{definition}[特征]
域 $F$ 的特征是使得 $n \cdot 1 = 0$ 的最小正整数 $n$，如果不存在则特征为0。
\end{definition}
```

### 4.3 域扩张

```latex
\begin{definition}[域扩张]
域 $K$ 是域 $F$ 的扩张，记作 $K/F$，当且仅当 $F$ 是 $K$ 的子域。
\end{definition}

\begin{definition}[代数扩张]
域扩张 $K/F$ 是代数的当且仅当 $K$ 的每个元素都是 $F$ 上的代数元。
\end{definition}

\begin{definition}[有限扩张]
域扩张 $K/F$ 是有限的当且仅当 $K$ 作为 $F$ 上的向量空间是有限维的。
\end{definition}
```

## 5. 模论

### 5.1 模的定义

```latex
\begin{definition}[左模]
环 $R$ 上的左模是阿贝尔群 $(M, +, 0, -)$ 和标量乘法 $\cdot: R \times M \rightarrow M$ 使得：
\begin{enumerate}
\item $(r + s) \cdot m = r \cdot m + s \cdot m$
\item $r \cdot (m + n) = r \cdot m + r \cdot n$
\item $(r \cdot s) \cdot m = r \cdot (s \cdot m)$
\item $1 \cdot m = m$
\end{enumerate}
\end{definition}
```

### 5.2 模的性质

```latex
\begin{theorem}[模的基本性质]
对于 $R$-模 $M$：
\begin{enumerate}
\item $0 \cdot m = 0$
\item $r \cdot 0 = 0$
\item $(-r) \cdot m = -(r \cdot m) = r \cdot (-m)$
\end{enumerate}
\end{theorem}

\begin{definition}[子模]
$R$-模 $M$ 的子模是子集 $N \subseteq M$ 使得：
\begin{enumerate}
\item $(N, +)$ 是 $(M, +)$ 的子群
\item $\forall r \in R, \forall n \in N, r \cdot n \in N$
\end{enumerate}
\end{definition}
```

## 6. 线性代数

### 6.1 向量空间

```latex
\begin{definition}[向量空间]
域 $F$ 上的向量空间是 $F$-模 $V$。
\end{definition}

\begin{definition}[线性无关]
向量 $v_1, v_2, \ldots, v_n$ 线性无关当且仅当：
$$\sum_{i=1}^n a_i v_i = 0 \Rightarrow a_i = 0 \text{ for all } i$$
\end{definition}

\begin{definition}[基]
向量空间 $V$ 的基是线性无关的生成集。
\end{definition}

\begin{theorem}[基的存在性]
每个向量空间都有基。
\end{theorem}
```

### 6.2 线性变换

```latex
\begin{definition}[线性变换]
向量空间 $V$ 到 $W$ 的线性变换是函数 $T: V \rightarrow W$ 使得：
\begin{enumerate}
\item $T(v + w) = T(v) + T(w)$
\item $T(a \cdot v) = a \cdot T(v)$
\end{enumerate}
\end{definition}

\begin{definition}[核与像]
线性变换 $T: V \rightarrow W$ 的核和像：
\begin{enumerate}
\item $\ker(T) = \{v \in V \mid T(v) = 0\}$
\item $\text{im}(T) = \{T(v) \mid v \in V\}$
\end{enumerate}
\end{definition}

\begin{theorem}[秩-零化度定理]
对于线性变换 $T: V \rightarrow W$：
$$\dim(V) = \dim(\ker(T)) + \dim(\text{im}(T))$$
\end{theorem}
```

## 7. 应用实例

### 7.1 软件系统中的代数结构

```rust
// 软件系统中的代数结构
#[derive(Debug, Clone, PartialEq)]
pub struct AlgebraicSystem<T> {
    pub elements: Set<T>,
    pub operations: Map<String, Operation<T>>,
    pub axioms: Vec<Axiom<T>>,
}

#[derive(Debug, Clone)]
pub struct Operation<T> {
    pub name: String,
    pub arity: usize,
    pub function: Box<dyn Fn(Vec<T>) -> T>,
}

#[derive(Debug, Clone)]
pub struct Axiom<T> {
    pub name: String,
    pub condition: Box<dyn Fn(&Set<T>, &Map<String, Operation<T>>) -> bool>,
}

impl<T: Clone + PartialEq> AlgebraicSystem<T> {
    pub fn new() -> Self {
        AlgebraicSystem {
            elements: Set::new(),
            operations: Map::new(),
            axioms: Vec::new(),
        }
    }
    
    pub fn add_element(&mut self, element: T) {
        self.elements.insert(element);
    }
    
    pub fn add_operation(&mut self, name: String, operation: Operation<T>) {
        self.operations.insert(name, operation);
    }
    
    pub fn add_axiom(&mut self, axiom: Axiom<T>) {
        self.axioms.push(axiom);
    }
    
    pub fn verify_axioms(&self) -> Vec<String> {
        let mut violations = Vec::new();
        
        for axiom in &self.axioms {
            if !(axiom.condition)(&self.elements, &self.operations) {
                violations.push(format!("Axiom violated: {}", axiom.name));
            }
        }
        
        violations
    }
    
    pub fn is_group(&self) -> bool {
        // 检查是否满足群公理
        if let Some(multiplication) = self.operations.get("multiplication") {
            if let Some(identity) = self.operations.get("identity") {
                if let Some(inverse) = self.operations.get("inverse") {
                    return self.check_group_axioms(multiplication, identity, inverse);
                }
            }
        }
        false
    }
    
    pub fn check_group_axioms(&self, 
                             multiplication: &Operation<T>, 
                             identity: &Operation<T>, 
                             inverse: &Operation<T>) -> bool {
        // 检查结合律
        for a in &self.elements {
            for b in &self.elements {
                for c in &self.elements {
                    let left = (multiplication.function)(vec![
                        (multiplication.function)(vec![a.clone(), b.clone()]),
                        c.clone()
                    ]);
                    let right = (multiplication.function)(vec![
                        a.clone(),
                        (multiplication.function)(vec![b.clone(), c.clone()])
                    ]);
                    if left != right {
                        return false;
                    }
                }
            }
        }
        
        // 检查单位元
        let e = (identity.function)(vec![]);
        for a in &self.elements {
            let left = (multiplication.function)(vec![e.clone(), a.clone()]);
            let right = (multiplication.function)(vec![a.clone(), e.clone()]);
            if left != *a || right != *a {
                return false;
            }
        }
        
        // 检查逆元
        for a in &self.elements {
            let a_inv = (inverse.function)(vec![a.clone()]);
            let left = (multiplication.function)(vec![a.clone(), a_inv.clone()]);
            let right = (multiplication.function)(vec![a_inv, a.clone()]);
            if left != e || right != e {
                return false;
            }
        }
        
        true
    }
}

// 群的具体实现
#[derive(Debug, Clone, PartialEq)]
pub struct Group<T> {
    pub elements: Set<T>,
    pub operation: Box<dyn Fn(T, T) -> T>,
    pub identity: T,
    pub inverse: Box<dyn Fn(T) -> T>,
}

impl<T: Clone + PartialEq> Group<T> {
    pub fn new(elements: Set<T>, 
               operation: Box<dyn Fn(T, T) -> T>, 
               identity: T, 
               inverse: Box<dyn Fn(T) -> T>) -> Self {
        Group {
            elements,
            operation,
            identity,
            inverse,
        }
    }
    
    pub fn multiply(&self, a: T, b: T) -> T {
        (self.operation)(a, b)
    }
    
    pub fn inverse(&self, a: T) -> T {
        (self.inverse)(a)
    }
    
    pub fn is_abelian(&self) -> bool {
        for a in &self.elements {
            for b in &self.elements {
                if self.multiply(a.clone(), b.clone()) != self.multiply(b.clone(), a.clone()) {
                    return false;
                }
            }
        }
        true
    }
    
    pub fn order(&self) -> usize {
        self.elements.len()
    }
    
    pub fn subgroup(&self, subset: Set<T>) -> Option<Group<T>> {
        // 检查子群条件
        if !subset.contains(&self.identity) {
            return None;
        }
        
        for a in &subset {
            for b in &subset {
                let product = self.multiply(a.clone(), b.clone());
                if !subset.contains(&product) {
                    return None;
                }
            }
        }
        
        for a in &subset {
            let inv = self.inverse(a.clone());
            if !subset.contains(&inv) {
                return None;
            }
        }
        
        Some(Group {
            elements: subset,
            operation: self.operation.clone(),
            identity: self.identity.clone(),
            inverse: self.inverse.clone(),
        })
    }
}

// 环的具体实现
#[derive(Debug, Clone, PartialEq)]
pub struct Ring<T> {
    pub elements: Set<T>,
    pub addition: Box<dyn Fn(T, T) -> T>,
    pub multiplication: Box<dyn Fn(T, T) -> T>,
    pub zero: T,
    pub one: T,
    pub negation: Box<dyn Fn(T) -> T>,
}

impl<T: Clone + PartialEq> Ring<T> {
    pub fn new(elements: Set<T>,
               addition: Box<dyn Fn(T, T) -> T>,
               multiplication: Box<dyn Fn(T, T) -> T>,
               zero: T,
               one: T,
               negation: Box<dyn Fn(T) -> T>) -> Self {
        Ring {
            elements,
            addition,
            multiplication,
            zero,
            one,
            negation,
        }
    }
    
    pub fn add(&self, a: T, b: T) -> T {
        (self.addition)(a, b)
    }
    
    pub fn multiply(&self, a: T, b: T) -> T {
        (self.multiplication)(a, b)
    }
    
    pub fn negate(&self, a: T) -> T {
        (self.negation)(a)
    }
    
    pub fn is_commutative(&self) -> bool {
        for a in &self.elements {
            for b in &self.elements {
                if self.multiply(a.clone(), b.clone()) != self.multiply(b.clone(), a.clone()) {
                    return false;
                }
            }
        }
        true
    }
    
    pub fn is_integral_domain(&self) -> bool {
        if !self.is_commutative() {
            return false;
        }
        
        for a in &self.elements {
            for b in &self.elements {
                if self.multiply(a.clone(), b.clone()) == self.zero {
                    if *a != self.zero && *b != self.zero {
                        return false;
                    }
                }
            }
        }
        true
    }
}
```

### 7.2 密码学中的代数应用

```rust
// 密码学中的代数应用
#[derive(Debug, Clone)]
pub struct CryptographicGroup {
    pub group: Group<BigUint>,
    pub generator: BigUint,
    pub order: BigUint,
}

impl CryptographicGroup {
    pub fn new(group: Group<BigUint>, generator: BigUint, order: BigUint) -> Self {
        CryptographicGroup {
            group,
            generator,
            order,
        }
    }
    
    pub fn discrete_logarithm(&self, target: BigUint) -> Option<BigUint> {
        // 计算离散对数
        let mut current = self.generator.clone();
        let mut exponent = BigUint::from(1u32);
        
        while exponent < self.order {
            if current == target {
                return Some(exponent);
            }
            current = self.group.multiply(current, self.generator.clone());
            exponent += BigUint::from(1u32);
        }
        
        None
    }
    
    pub fn diffie_hellman(&self, private_key: BigUint) -> (BigUint, BigUint) {
        // Diffie-Hellman密钥交换
        let public_key = self.group.multiply(self.generator.clone(), private_key);
        (private_key, public_key)
    }
    
    pub fn shared_secret(&self, private_key: BigUint, public_key: BigUint) -> BigUint {
        // 计算共享密钥
        self.group.multiply(public_key, private_key)
    }
}

// 椭圆曲线群
#[derive(Debug, Clone)]
pub struct EllipticCurve {
    pub a: BigInt,
    pub b: BigInt,
    pub p: BigUint,
}

#[derive(Debug, Clone, PartialEq)]
pub struct EllipticCurvePoint {
    pub x: BigInt,
    pub y: BigInt,
    pub is_infinity: bool,
}

impl EllipticCurve {
    pub fn new(a: BigInt, b: BigInt, p: BigUint) -> Self {
        EllipticCurve { a, b, p }
    }
    
    pub fn add_points(&self, p1: &EllipticCurvePoint, p2: &EllipticCurvePoint) -> EllipticCurvePoint {
        if p1.is_infinity {
            return p2.clone();
        }
        if p2.is_infinity {
            return p1.clone();
        }
        
        if p1.x == p2.x && p1.y != p2.y {
            return EllipticCurvePoint { x: BigInt::from(0), y: BigInt::from(0), is_infinity: true };
        }
        
        let lambda = if p1.x == p2.x {
            // 切线斜率
            let numerator = 3 * &p1.x * &p1.x + &self.a;
            let denominator = 2 * &p1.y;
            (numerator * mod_inverse(denominator, &self.p)) % &self.p
        } else {
            // 割线斜率
            let numerator = &p2.y - &p1.y;
            let denominator = &p2.x - &p1.x;
            (numerator * mod_inverse(denominator, &self.p)) % &self.p
        };
        
        let x3 = (&lambda * &lambda - &p1.x - &p2.x) % &self.p;
        let y3 = (&lambda * (&p1.x - &x3) - &p1.y) % &self.p;
        
        EllipticCurvePoint {
            x: x3,
            y: y3,
            is_infinity: false,
        }
    }
    
    pub fn scalar_multiply(&self, point: &EllipticCurvePoint, scalar: &BigUint) -> EllipticCurvePoint {
        let mut result = EllipticCurvePoint { x: BigInt::from(0), y: BigInt::from(0), is_infinity: true };
        let mut current = point.clone();
        let mut remaining = scalar.clone();
        
        while remaining > BigUint::from(0u32) {
            if &remaining % BigUint::from(2u32) == BigUint::from(1u32) {
                result = self.add_points(&result, &current);
            }
            current = self.add_points(&current, &current);
            remaining = remaining / BigUint::from(2u32);
        }
        
        result
    }
}

fn mod_inverse(a: BigInt, m: &BigUint) -> BigInt {
    // 计算模逆
    let mut t = (BigInt::from(0), BigInt::from(1));
    let mut r = (a, BigInt::from(m));
    
    while r.1 != BigInt::from(0) {
        let q = &r.0 / &r.1;
        t = (t.1.clone(), t.0 - &q * &t.1);
        r = (r.1.clone(), r.0 - &q * &r.1);
    }
    
    if t.0 < BigInt::from(0) {
        t.0 + BigInt::from(m)
    } else {
        t.0
    }
}
```

### 7.3 数据结构中的代数

```rust
// 数据结构中的代数应用
#[derive(Debug, Clone)]
pub struct Monoid<T> {
    pub elements: Set<T>,
    pub operation: Box<dyn Fn(T, T) -> T>,
    pub identity: T,
}

impl<T: Clone + PartialEq> Monoid<T> {
    pub fn new(elements: Set<T>, 
               operation: Box<dyn Fn(T, T) -> T>, 
               identity: T) -> Self {
        Monoid {
            elements,
            operation,
            identity,
        }
    }
    
    pub fn combine(&self, a: T, b: T) -> T {
        (self.operation)(a, b)
    }
    
    pub fn fold(&self, elements: &[T]) -> T {
        elements.iter().fold(self.identity.clone(), |acc, x| self.combine(acc, x.clone()))
    }
}

// 字符串连接幺半群
pub struct StringMonoid;

impl StringMonoid {
    pub fn new() -> Monoid<String> {
        Monoid {
            elements: Set::new(), // 所有字符串的集合
            operation: Box::new(|a, b| a + &b),
            identity: String::new(),
        }
    }
}

// 列表幺半群
pub struct ListMonoid<T> {
    _phantom: std::marker::PhantomData<T>,
}

impl<T: Clone> ListMonoid<T> {
    pub fn new() -> Monoid<Vec<T>> {
        Monoid {
            elements: Set::new(), // 所有列表的集合
            operation: Box::new(|mut a, b| {
                a.extend(b);
                a
            }),
            identity: Vec::new(),
        }
    }
}

// 函数幺半群
pub struct FunctionMonoid<A, B> {
    _phantom: std::marker::PhantomData<(A, B)>,
}

impl<A, B> FunctionMonoid<A, B> {
    pub fn new() -> Monoid<Box<dyn Fn(A) -> B>> {
        Monoid {
            elements: Set::new(), // 所有函数的集合
            operation: Box::new(|f, g| Box::new(move |x| g(f(x)))),
            identity: Box::new(|_| panic!("Identity function not implemented")),
        }
    }
}
```

---

**文档版本**：v1.0  
**创建时间**：2024-12-19  
**最后更新**：2024-12-19  
**状态**：完成

**相关链接**：
- [01-集合论基础](./01-集合论基础.md)
- [02-范畴论基础](./02-范畴论基础.md)
- [04-拓扑学理论](./04-拓扑学理论.md)
