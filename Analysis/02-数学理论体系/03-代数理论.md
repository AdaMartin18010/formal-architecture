# 03-代数理论

## 目录

1. [基本概念](#1-基本概念)
2. [群论](#2-群论)
3. [环论](#3-环论)
4. [域论](#4-域论)
5. [模论](#5-模论)
6. [线性代数](#6-线性代数)
7. [应用实例](#7-应用实例)

## 1. 基本概念

### 1.1 代数结构概述

代数理论研究具有运算的集合及其性质。在形式化架构理论中，代数理论为数据结构、算法设计和系统建模提供数学基础。

### 1.2 基本定义

```latex
\begin{definition}[代数结构]
代数结构是二元组 $(A, \mathcal{O})$，其中：
\begin{enumerate}
\item $A$ 是非空集合
\item $\mathcal{O}$ 是运算集合
\end{enumerate}
\end{definition}

\begin{definition}[二元运算]
集合 $A$ 上的二元运算是函数：
$$*: A \times A \rightarrow A$$
\end{definition}
```

## 2. 群论

### 2.1 群的定义

```latex
\begin{definition}[群]
群是三元组 $(G, *, e)$，其中：
\begin{enumerate}
\item $G$ 是非空集合
\item $*$ 是 $G$ 上的二元运算
\item $e \in G$ 是单位元
\end{enumerate}
满足以下公理：
\begin{enumerate}
\item 结合律：$(a * b) * c = a * (b * c)$
\item 单位元：$e * a = a * e = a$
\item 逆元：$\forall a \in G, \exists a^{-1} \in G, a * a^{-1} = a^{-1} * a = e$
\end{enumerate}
\end{definition}
```

### 2.2 群的性质

```latex
\begin{theorem}[群的基本性质]
对于群 $(G, *, e)$：
\begin{enumerate}
\item 单位元唯一：如果 $e'$ 也是单位元，则 $e = e'$
\item 逆元唯一：每个元素的逆元唯一
\item 消去律：$a * b = a * c \Rightarrow b = c$
\item 方程可解：$\forall a,b \in G, \exists x \in G, a * x = b$
\end{enumerate}
\end{theorem}

\begin{proof}
\textbf{证明单位元唯一：}
\begin{enumerate}
\item 设 $e'$ 是另一个单位元
\item $e = e * e' = e'$（单位元性质）
\item 因此 $e = e'$
\end{enumerate}
\end{proof}
```

### 2.3 子群

```latex
\begin{definition}[子群]
群 $(G, *, e)$ 的子群是子集 $H \subseteq G$ 使得：
\begin{enumerate}
\item $e \in H$
\item $\forall a,b \in H, a * b \in H$
\item $\forall a \in H, a^{-1} \in H$
\end{enumerate}
\end{definition}

\begin{theorem}[子群判定]
子集 $H \subseteq G$ 是子群当且仅当：
$$\forall a,b \in H, a * b^{-1} \in H$$
\end{theorem}
```

### 2.4 同态与同构

```latex
\begin{definition}[群同态]
群 $(G, *, e_G)$ 到群 $(H, \circ, e_H)$ 的同态是函数 $f: G \rightarrow H$ 使得：
$$f(a * b) = f(a) \circ f(b)$$
\end{definition}

\begin{definition}[群同构]
群同态 $f: G \rightarrow H$ 是同构当且仅当 $f$ 是双射。
\end{definition}
```

## 3. 环论

### 3.1 环的定义

```latex
\begin{definition}[环]
环是四元组 $(R, +, \cdot, 0)$，其中：
\begin{enumerate}
\item $(R, +, 0)$ 是阿贝尔群
\item $\cdot$ 是 $R$ 上的二元运算
\item 满足分配律：$a \cdot (b + c) = a \cdot b + a \cdot c$
\end{enumerate}
\end{definition}

\begin{definition}[交换环]
环 $R$ 是交换环当且仅当：
$$\forall a,b \in R, a \cdot b = b \cdot a$$
\end{definition}

\begin{definition}[单位环]
环 $R$ 是单位环当且仅当存在 $1 \in R$ 使得：
$$\forall a \in R, 1 \cdot a = a \cdot 1 = a$$
\end{definition}
```

### 3.2 理想

```latex
\begin{definition}[理想]
环 $R$ 的理想是子集 $I \subseteq R$ 使得：
\begin{enumerate}
\item $(I, +)$ 是 $(R, +)$ 的子群
\item $\forall a \in I, \forall r \in R, r \cdot a \in I$
\end{enumerate}
\end{definition}

\begin{definition}[主理想]
由元素 $a$ 生成的主理想：
$$(a) = \{r \cdot a \mid r \in R\}$$
\end{definition}
```

### 3.3 商环

```latex
\begin{definition}[商环]
环 $R$ 关于理想 $I$ 的商环：
$$R/I = \{a + I \mid a \in R\}$$
其中运算定义为：
\begin{enumerate}
\item $(a + I) + (b + I) = (a + b) + I$
\item $(a + I) \cdot (b + I) = (a \cdot b) + I$
\end{enumerate}
\end{definition}
```

## 4. 域论

### 4.1 域的定义

```latex
\begin{definition}[域]
域是环 $(F, +, \cdot, 0, 1)$ 使得：
\begin{enumerate}
\item $(F, +, 0)$ 是阿贝尔群
\item $(F \setminus \{0\}, \cdot, 1)$ 是阿贝尔群
\item 满足分配律
\end{enumerate}
\end{definition}

\begin{theorem}[域的性质]
对于域 $F$：
\begin{enumerate}
\item 无零因子：$a \cdot b = 0 \Rightarrow a = 0 \lor b = 0$
\item 消去律：$a \neq 0 \land a \cdot b = a \cdot c \Rightarrow b = c$
\end{enumerate}
\end{theorem}
```

### 4.2 域扩张

```latex
\begin{definition}[域扩张]
域 $K$ 是域 $F$ 的扩张当且仅当 $F$ 是 $K$ 的子域。
\end{definition}

\begin{definition}[代数扩张]
域扩张 $K/F$ 是代数的当且仅当 $K$ 的每个元素都是 $F$ 上代数的。
\end{definition}
```

## 5. 模论

### 5.1 模的定义

```latex
\begin{definition}[左模]
环 $R$ 上的左模是阿贝尔群 $(M, +, 0)$ 配备标量乘法：
$$\cdot: R \times M \rightarrow M$$
满足：
\begin{enumerate}
\item $(r + s) \cdot m = r \cdot m + s \cdot m$
\item $r \cdot (m + n) = r \cdot m + r \cdot n$
\item $(r \cdot s) \cdot m = r \cdot (s \cdot m)$
\item $1 \cdot m = m$（如果 $R$ 有单位元）
\end{enumerate}
\end{definition}
```

### 5.2 自由模

```latex
\begin{definition}[自由模]
$R$-模 $M$ 是自由的当且仅当存在基 $B \subseteq M$ 使得：
$$\forall m \in M, m = \sum_{b \in B} r_b \cdot b$$
其中只有有限个 $r_b$ 非零。
\end{definition}
```

## 6. 线性代数

### 6.1 向量空间

```latex
\begin{definition}[向量空间]
域 $F$ 上的向量空间是 $F$-模 $V$。
\end{definition}

\begin{definition}[线性无关]
向量集 $S \subseteq V$ 线性无关当且仅当：
$$\sum_{v \in S} a_v \cdot v = 0 \Rightarrow \forall v, a_v = 0$$
\end{definition}

\begin{definition}[基]
向量空间 $V$ 的基是线性无关的生成集。
\end{definition}
```

### 6.2 线性变换

```latex
\begin{definition}[线性变换]
向量空间 $V$ 到 $W$ 的线性变换是函数 $T: V \rightarrow W$ 使得：
\begin{enumerate}
\item $T(v + w) = T(v) + T(w)$
\item $T(a \cdot v) = a \cdot T(v)$
\end{enumerate}
\end{definition}

\begin{definition}[矩阵表示]
线性变换 $T: V \rightarrow W$ 关于基 $B_V, B_W$ 的矩阵表示是矩阵 $A$ 使得：
$$[T(v)]_{B_W} = A[v]_{B_V}$$
\end{definition}
```

### 6.3 特征值与特征向量

```latex
\begin{definition}[特征值]
线性变换 $T: V \rightarrow V$ 的特征值是标量 $\lambda$ 使得：
$$\exists v \neq 0, T(v) = \lambda \cdot v$$
\end{definition}

\begin{definition}[特征向量]
向量 $v$ 是特征值 $\lambda$ 的特征向量当且仅当：
$$T(v) = \lambda \cdot v$$
\end{definition}
```

## 7. 应用实例

### 7.1 密码学中的群论

```rust
// 密码学中的群论应用
#[derive(Debug, Clone)]
pub struct CryptographicGroup {
    pub elements: Set<GroupElement>,
    pub operation: GroupOperation,
    pub identity: GroupElement,
    pub generator: GroupElement,
}

#[derive(Debug, Clone)]
pub struct GroupElement {
    pub value: u64,
    pub order: u64,
}

impl CryptographicGroup {
    pub fn new(modulus: u64, generator: u64) -> Self {
        let mut elements = Set::new();
        let mut current = 1;
        
        // 生成循环群
        for _ in 0..modulus {
            elements.insert(GroupElement {
                value: current,
                order: 0,
            });
            current = (current * generator) % modulus;
        }
        
        CryptographicGroup {
            elements,
            operation: GroupOperation::ModularMultiplication { modulus },
            identity: GroupElement { value: 1, order: 1 },
            generator: GroupElement { value: generator, order: 0 },
        }
    }
    
    pub fn multiply(&self, a: &GroupElement, b: &GroupElement) -> GroupElement {
        match &self.operation {
            GroupOperation::ModularMultiplication { modulus } => {
                GroupElement {
                    value: (a.value * b.value) % modulus,
                    order: 0,
                }
            }
        }
    }
    
    pub fn power(&self, base: &GroupElement, exponent: u64) -> GroupElement {
        let mut result = self.identity.clone();
        let mut current = base.clone();
        let mut exp = exponent;
        
        while exp > 0 {
            if exp % 2 == 1 {
                result = self.multiply(&result, &current);
            }
            current = self.multiply(&current, &current);
            exp /= 2;
        }
        
        result
    }
    
    pub fn discrete_logarithm(&self, base: &GroupElement, target: &GroupElement) -> Option<u64> {
        // Baby-step Giant-step算法
        let m = (self.elements.len() as f64).sqrt().ceil() as u64;
        let mut baby_steps = Map::new();
        
        // Baby steps
        let mut current = self.identity.clone();
        for j in 0..m {
            baby_steps.insert(current.value, j);
            current = self.multiply(&current, base);
        }
        
        // Giant steps
        let factor = self.power(base, m);
        let mut current = target.clone();
        
        for i in 0..m {
            if let Some(&j) = baby_steps.get(&current.value) {
                return Some(i * m + j);
            }
            current = self.multiply(&current, &factor);
        }
        
        None
    }
}

// Diffie-Hellman密钥交换
#[derive(Debug, Clone)]
pub struct DiffieHellman {
    pub group: CryptographicGroup,
    pub private_key: u64,
    pub public_key: GroupElement,
}

impl DiffieHellman {
    pub fn new(group: CryptographicGroup) -> Self {
        let private_key = rand::random::<u64>() % 1000;
        let public_key = group.power(&group.generator, private_key);
        
        DiffieHellman {
            group,
            private_key,
            public_key,
        }
    }
    
    pub fn compute_shared_secret(&self, other_public_key: &GroupElement) -> GroupElement {
        self.group.power(other_public_key, self.private_key)
    }
}
```

### 7.2 数据结构中的代数

```rust
// 数据结构中的代数应用
#[derive(Debug, Clone)]
pub struct AlgebraicDataStructure<T> {
    pub elements: Vec<T>,
    pub operation: BinaryOperation<T>,
    pub identity: Option<T>,
}

#[derive(Debug, Clone)]
pub enum BinaryOperation<T> {
    Addition,
    Multiplication,
    Custom(Box<dyn Fn(&T, &T) -> T>),
}

impl<T: Clone + PartialEq> AlgebraicDataStructure<T> {
    pub fn new(operation: BinaryOperation<T>, identity: Option<T>) -> Self {
        AlgebraicDataStructure {
            elements: Vec::new(),
            operation,
            identity,
        }
    }
    
    pub fn apply_operation(&self, a: &T, b: &T) -> T {
        match &self.operation {
            BinaryOperation::Addition => {
                // 假设T实现了加法
                self.add(a, b)
            }
            BinaryOperation::Multiplication => {
                // 假设T实现了乘法
                self.multiply(a, b)
            }
            BinaryOperation::Custom(f) => f(a, b),
        }
    }
    
    pub fn is_group(&self) -> bool {
        // 检查是否满足群的性质
        if self.elements.is_empty() {
            return false;
        }
        
        // 检查结合律
        for a in &self.elements {
            for b in &self.elements {
                for c in &self.elements {
                    let left = self.apply_operation(&self.apply_operation(a, b), c);
                    let right = self.apply_operation(a, &self.apply_operation(b, c));
                    if left != right {
                        return false;
                    }
                }
            }
        }
        
        // 检查单位元
        if let Some(identity) = &self.identity {
            for a in &self.elements {
                if self.apply_operation(identity, a) != *a || 
                   self.apply_operation(a, identity) != *a {
                    return false;
                }
            }
        } else {
            return false;
        }
        
        // 检查逆元（简化版本）
        true
    }
    
    pub fn is_ring(&self) -> bool {
        // 检查是否满足环的性质
        // 需要两个运算：加法和乘法
        // 这里简化处理
        self.is_group()
    }
}

// 多项式环
#[derive(Debug, Clone)]
pub struct Polynomial {
    pub coefficients: Vec<f64>,
    pub degree: usize,
}

impl Polynomial {
    pub fn new(coefficients: Vec<f64>) -> Self {
        let degree = coefficients.len().saturating_sub(1);
        Polynomial { coefficients, degree }
    }
    
    pub fn add(&self, other: &Polynomial) -> Polynomial {
        let max_degree = self.degree.max(other.degree);
        let mut result_coeffs = vec![0.0; max_degree + 1];
        
        for i in 0..=self.degree {
            result_coeffs[i] += self.coefficients[i];
        }
        
        for i in 0..=other.degree {
            result_coeffs[i] += other.coefficients[i];
        }
        
        Polynomial::new(result_coeffs)
    }
    
    pub fn multiply(&self, other: &Polynomial) -> Polynomial {
        let result_degree = self.degree + other.degree;
        let mut result_coeffs = vec![0.0; result_degree + 1];
        
        for i in 0..=self.degree {
            for j in 0..=other.degree {
                result_coeffs[i + j] += self.coefficients[i] * other.coefficients[j];
            }
        }
        
        Polynomial::new(result_coeffs)
    }
    
    pub fn evaluate(&self, x: f64) -> f64 {
        let mut result = 0.0;
        let mut power = 1.0;
        
        for &coeff in &self.coefficients {
            result += coeff * power;
            power *= x;
        }
        
        result
    }
}
```

### 7.3 机器学习中的线性代数

```rust
// 机器学习中的线性代数应用
#[derive(Debug, Clone)]
pub struct Matrix {
    pub rows: usize,
    pub cols: usize,
    pub data: Vec<Vec<f64>>,
}

impl Matrix {
    pub fn new(rows: usize, cols: usize) -> Self {
        let data = vec![vec![0.0; cols]; rows];
        Matrix { rows, cols, data }
    }
    
    pub fn from_data(data: Vec<Vec<f64>>) -> Self {
        let rows = data.len();
        let cols = if rows > 0 { data[0].len() } else { 0 };
        Matrix { rows, cols, data }
    }
    
    pub fn add(&self, other: &Matrix) -> Result<Matrix, String> {
        if self.rows != other.rows || self.cols != other.cols {
            return Err("Matrix dimensions must match".to_string());
        }
        
        let mut result = Matrix::new(self.rows, self.cols);
        for i in 0..self.rows {
            for j in 0..self.cols {
                result.data[i][j] = self.data[i][j] + other.data[i][j];
            }
        }
        
        Ok(result)
    }
    
    pub fn multiply(&self, other: &Matrix) -> Result<Matrix, String> {
        if self.cols != other.rows {
            return Err("Matrix dimensions incompatible for multiplication".to_string());
        }
        
        let mut result = Matrix::new(self.rows, other.cols);
        for i in 0..self.rows {
            for j in 0..other.cols {
                for k in 0..self.cols {
                    result.data[i][j] += self.data[i][k] * other.data[k][j];
                }
            }
        }
        
        Ok(result)
    }
    
    pub fn transpose(&self) -> Matrix {
        let mut result = Matrix::new(self.cols, self.rows);
        for i in 0..self.rows {
            for j in 0..self.cols {
                result.data[j][i] = self.data[i][j];
            }
        }
        result
    }
    
    pub fn determinant(&self) -> Result<f64, String> {
        if self.rows != self.cols {
            return Err("Determinant only defined for square matrices".to_string());
        }
        
        if self.rows == 1 {
            return Ok(self.data[0][0]);
        }
        
        if self.rows == 2 {
            return Ok(self.data[0][0] * self.data[1][1] - self.data[0][1] * self.data[1][0]);
        }
        
        // 递归计算行列式
        let mut det = 0.0;
        for j in 0..self.cols {
            let minor = self.minor(0, j)?;
            det += self.data[0][j] * minor.determinant()? * if j % 2 == 0 { 1.0 } else { -1.0 };
        }
        
        Ok(det)
    }
    
    pub fn minor(&self, row: usize, col: usize) -> Result<Matrix, String> {
        if row >= self.rows || col >= self.cols {
            return Err("Invalid row or column index".to_string());
        }
        
        let mut result = Matrix::new(self.rows - 1, self.cols - 1);
        let mut result_i = 0;
        
        for i in 0..self.rows {
            if i == row {
                continue;
            }
            
            let mut result_j = 0;
            for j in 0..self.cols {
                if j == col {
                    continue;
                }
                
                result.data[result_i][result_j] = self.data[i][j];
                result_j += 1;
            }
            result_i += 1;
        }
        
        Ok(result)
    }
    
    pub fn eigenvalues(&self) -> Result<Vec<f64>, String> {
        if self.rows != self.cols {
            return Err("Eigenvalues only defined for square matrices".to_string());
        }
        
        // 简化的特征值计算（仅适用于2x2矩阵）
        if self.rows == 2 {
            let a = self.data[0][0];
            let b = self.data[0][1];
            let c = self.data[1][0];
            let d = self.data[1][1];
            
            let trace = a + d;
            let det = a * d - b * c;
            
            let discriminant = trace * trace - 4.0 * det;
            if discriminant < 0.0 {
                return Ok(vec![]); // 复数特征值
            }
            
            let sqrt_disc = discriminant.sqrt();
            let lambda1 = (trace + sqrt_disc) / 2.0;
            let lambda2 = (trace - sqrt_disc) / 2.0;
            
            return Ok(vec![lambda1, lambda2]);
        }
        
        Err("Eigenvalue calculation not implemented for this size".to_string())
    }
}

// 线性回归
#[derive(Debug, Clone)]
pub struct LinearRegression {
    pub weights: Vec<f64>,
    pub bias: f64,
}

impl LinearRegression {
    pub fn new(feature_count: usize) -> Self {
        LinearRegression {
            weights: vec![0.0; feature_count],
            bias: 0.0,
        }
    }
    
    pub fn fit(&mut self, X: &Matrix, y: &Vec<f64>) -> Result<(), String> {
        // 最小二乘法求解
        let X_t = X.transpose();
        let X_t_X = X_t.multiply(X)?;
        let X_t_y = self.multiply_matrix_vector(&X_t, y)?;
        
        // 求解线性方程组 (X^T X) w = X^T y
        let solution = self.solve_linear_system(&X_t_X, &X_t_y)?;
        
        self.bias = solution[0];
        self.weights = solution[1..].to_vec();
        
        Ok(())
    }
    
    pub fn predict(&self, X: &Matrix) -> Result<Vec<f64>, String> {
        let mut predictions = Vec::new();
        
        for i in 0..X.rows {
            let mut prediction = self.bias;
            for j in 0..X.cols {
                prediction += self.weights[j] * X.data[i][j];
            }
            predictions.push(prediction);
        }
        
        Ok(predictions)
    }
    
    fn multiply_matrix_vector(&self, matrix: &Matrix, vector: &Vec<f64>) -> Result<Vec<f64>, String> {
        if matrix.cols != vector.len() {
            return Err("Matrix and vector dimensions incompatible".to_string());
        }
        
        let mut result = vec![0.0; matrix.rows];
        for i in 0..matrix.rows {
            for j in 0..matrix.cols {
                result[i] += matrix.data[i][j] * vector[j];
            }
        }
        
        Ok(result)
    }
    
    fn solve_linear_system(&self, A: &Matrix, b: &Vec<f64>) -> Result<Vec<f64>, String> {
        // 高斯消元法求解线性方程组
        let mut augmented = Matrix::new(A.rows, A.cols + 1);
        
        // 构建增广矩阵
        for i in 0..A.rows {
            for j in 0..A.cols {
                augmented.data[i][j] = A.data[i][j];
            }
            augmented.data[i][A.cols] = b[i];
        }
        
        // 前向消元
        for i in 0..augmented.rows {
            let mut max_row = i;
            for k in i + 1..augmented.rows {
                if augmented.data[k][i].abs() > augmented.data[max_row][i].abs() {
                    max_row = k;
                }
            }
            
            // 交换行
            augmented.data.swap(i, max_row);
            
            // 消元
            for k in i + 1..augmented.rows {
                let factor = augmented.data[k][i] / augmented.data[i][i];
                for j in i..=augmented.cols {
                    augmented.data[k][j] -= factor * augmented.data[i][j];
                }
            }
        }
        
        // 回代
        let mut solution = vec![0.0; augmented.rows];
        for i in (0..augmented.rows).rev() {
            let mut sum = 0.0;
            for j in i + 1..augmented.rows {
                sum += augmented.data[i][j] * solution[j];
            }
            solution[i] = (augmented.data[i][augmented.cols] - sum) / augmented.data[i][i];
        }
        
        Ok(solution)
    }
}
```

---

**文档版本**：v1.0  
**创建时间**：2024-12-19  
**最后更新**：2024-12-19  
**状态**：完成

**相关链接**：
- [01-集合论基础](./01-集合论基础.md)
- [02-范畴论基础](./02-范畴论基础.md)
- [04-拓扑学理论](./04-拓扑学理论.md) 