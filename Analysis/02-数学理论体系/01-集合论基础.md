# 01-集合论基础

## 目录

1. [基本概念](#1-基本概念)
2. [集合运算](#2-集合运算)
3. [关系与函数](#3-关系与函数)
4. [基数理论](#4-基数理论)
5. [序数理论](#5-序数理论)
6. [公理化集合论](#6-公理化集合论)
7. [应用实例](#7-应用实例)

## 1. 基本概念

### 1.1 集合的定义

```latex
\begin{definition}[集合]
集合是对象的聚集，具有以下特征：
\begin{enumerate}
\item 外延性：两个集合相等当且仅当它们包含相同的元素
\item 概括性：可以通过性质定义集合
\item 基础性：集合是数学的基础概念
\end{enumerate}
\end{definition}
```

### 1.2 基本符号

```latex
% 集合符号
x \in A  % x属于集合A
x \notin A  % x不属于集合A
A \subseteq B  % A是B的子集
A \subset B  % A是B的真子集
A = B  % A等于B
A \neq B  % A不等于B

% 集合构造
\{x \mid P(x)\}  % 满足性质P的x的集合
\{a, b, c\}  % 包含元素a,b,c的集合
\emptyset  % 空集
```

### 1.3 集合的基本性质

```latex
\begin{theorem}[集合的基本性质]
对于任意集合A, B, C：
\begin{enumerate}
\item 自反性：$A \subseteq A$
\item 反对称性：$A \subseteq B \land B \subseteq A \Rightarrow A = B$
\item 传递性：$A \subseteq B \land B \subseteq C \Rightarrow A \subseteq C$
\item 空集性质：$\emptyset \subseteq A$
\end{enumerate}
\end{theorem}

\begin{proof}
\textbf{证明：}
\begin{enumerate}
\item 自反性：由子集定义直接得到
\item 反对称性：由外延性公理得到
\item 传递性：由子集定义和逻辑推理得到
\item 空集性质：空集不包含任何元素，因此是任何集合的子集
\end{enumerate}
\end{proof}
```

## 2. 集合运算

### 2.1 基本运算

```latex
\begin{definition}[并集]
集合A和B的并集：
\begin{enumerate}
\item $A \cup B = \{x \mid x \in A \lor x \in B\}$
\item 性质：$A \cup B = B \cup A$（交换律）
\item 性质：$(A \cup B) \cup C = A \cup (B \cup C)$（结合律）
\end{enumerate}
\end{definition}

\begin{definition}[交集]
集合A和B的交集：
\begin{enumerate}
\item $A \cap B = \{x \mid x \in A \land x \in B\}$
\item 性质：$A \cap B = B \cap A$（交换律）
\item 性质：$(A \cap B) \cap C = A \cap (B \cap C)$（结合律）
\end{enumerate}
\end{definition}

\begin{definition}[差集]
集合A和B的差集：
\begin{enumerate}
\item $A \setminus B = \{x \mid x \in A \land x \notin B\}$
\item 性质：$A \setminus B \subseteq A$
\item 性质：$A \setminus \emptyset = A$
\end{enumerate}
\end{definition}

\begin{definition}[补集]
集合A在全集U中的补集：
\begin{enumerate}
\item $A^c = U \setminus A = \{x \in U \mid x \notin A\}$
\item 性质：$(A^c)^c = A$
\item 性质：$A \cap A^c = \emptyset$
\end{enumerate}
\end{definition}
```

### 2.2 德摩根定律

```latex
\begin{theorem}[德摩根定律]
对于任意集合A, B：
\begin{enumerate}
\item $(A \cup B)^c = A^c \cap B^c$
\item $(A \cap B)^c = A^c \cup B^c$
\end{enumerate}
\end{theorem}

\begin{proof}
\textbf{证明第一个等式：}
\begin{enumerate}
\item 设 $x \in (A \cup B)^c$，则 $x \notin A \cup B$
\item 因此 $x \notin A$ 且 $x \notin B$
\item 所以 $x \in A^c$ 且 $x \in B^c$
\item 因此 $x \in A^c \cap B^c$
\item 反之亦然
\end{enumerate}
\end{proof}
```

### 2.3 分配律

```latex
\begin{theorem}[分配律]
对于任意集合A, B, C：
\begin{enumerate}
\item $A \cap (B \cup C) = (A \cap B) \cup (A \cap C)$
\item $A \cup (B \cap C) = (A \cup B) \cap (A \cup C)$
\end{enumerate}
\end{theorem}
```

## 3. 关系与函数

### 3.1 笛卡尔积

```latex
\begin{definition}[笛卡尔积]
集合A和B的笛卡尔积：
\begin{enumerate}
\item $A \times B = \{(a,b) \mid a \in A \land b \in B\}$
\item 性质：$A \times \emptyset = \emptyset \times A = \emptyset$
\item 性质：$|A \times B| = |A| \times |B|$（有限集）
\end{enumerate}
\end{definition}
```

### 3.2 二元关系

```latex
\begin{definition}[二元关系]
集合A上的二元关系：
\begin{enumerate}
\item $R \subseteq A \times A$
\item 记作：$aRb$ 或 $(a,b) \in R$
\item 性质：
  \begin{itemize}
  \item 自反性：$\forall a \in A, aRa$
  \item 对称性：$\forall a,b \in A, aRb \Rightarrow bRa$
  \item 传递性：$\forall a,b,c \in A, (aRb \land bRc) \Rightarrow aRc$
  \item 反对称性：$\forall a,b \in A, (aRb \land bRa) \Rightarrow a = b$
  \end{itemize}
\end{enumerate}
\end{definition}
```

### 3.3 等价关系

```latex
\begin{definition}[等价关系]
满足自反性、对称性和传递性的关系：
\begin{enumerate}
\item $R$ 是等价关系当且仅当：
  \begin{itemize}
  \item $\forall a \in A, aRa$（自反性）
  \item $\forall a,b \in A, aRb \Rightarrow bRa$（对称性）
  \item $\forall a,b,c \in A, (aRb \land bRc) \Rightarrow aRc$（传递性）
  \end{itemize}
\item 等价类：$[a]_R = \{b \in A \mid aRb\}$
\item 商集：$A/R = \{[a]_R \mid a \in A\}$
\end{enumerate}
\end{definition}
```

### 3.4 函数

```latex
\begin{definition}[函数]
从集合A到集合B的函数：
\begin{enumerate}
\item $f: A \rightarrow B$ 是 $A \times B$ 的子集
\item 满足：$\forall a \in A \exists! b \in B, (a,b) \in f$
\item 记作：$f(a) = b$
\item 性质：
  \begin{itemize}
  \item 单射：$\forall a_1,a_2 \in A, f(a_1) = f(a_2) \Rightarrow a_1 = a_2$
  \item 满射：$\forall b \in B \exists a \in A, f(a) = b$
  \item 双射：既是单射又是满射
  \end{itemize}
\end{enumerate}
\end{definition}
```

## 4. 基数理论

### 4.1 等势

```latex
\begin{definition}[等势]
两个集合等势当且仅当存在双射：
\begin{enumerate}
\item $A \sim B \Leftrightarrow \exists f: A \rightarrow B, f \text{ 是双射}$
\item 性质：等势是等价关系
\item 基数：$|A|$ 表示集合A的基数
\end{enumerate}
\end{definition}
```

### 4.2 有限集与无限集

```latex
\begin{definition}[有限集]
集合A是有限集当且仅当：
\begin{enumerate}
\item 存在 $n \in \mathbb{N}$，使得 $A \sim \{1,2,\ldots,n\}$
\item 记作：$|A| = n$
\item 空集是有限集，$|\emptyset| = 0$
\end{enumerate}
\end{definition}

\begin{definition}[无限集]
集合A是无限集当且仅当：
\begin{enumerate}
\item A不是有限集
\item 存在真子集B，使得 $A \sim B$
\end{enumerate}
\end{definition}
```

### 4.3 可数集

```latex
\begin{definition}[可数集]
集合A是可数集当且仅当：
\begin{enumerate}
\item A是有限集，或
\item $A \sim \mathbb{N}$
\item 记作：$|A| = \aleph_0$
\end{enumerate}
\end{definition}

\begin{theorem}[可数集的性质]
\begin{enumerate}
\item 可数集的子集是可数的
\item 可数集的并集是可数的
\item 可数集的笛卡尔积是可数的
\end{enumerate}
\end{theorem}
```

## 5. 序数理论

### 5.1 偏序集

```latex
\begin{definition}[偏序集]
集合A上的偏序关系：
\begin{enumerate}
\item 自反性：$\forall a \in A, a \leq a$
\item 反对称性：$\forall a,b \in A, (a \leq b \land b \leq a) \Rightarrow a = b$
\item 传递性：$\forall a,b,c \in A, (a \leq b \land b \leq c) \Rightarrow a \leq c$
\item 记作：$(A, \leq)$
\end{enumerate}
\end{definition}
```

### 5.2 全序集

```latex
\begin{definition}[全序集]
偏序集 $(A, \leq)$ 是全序集当且仅当：
\begin{enumerate}
\item 完全性：$\forall a,b \in A, a \leq b \lor b \leq a$
\item 性质：全序集的任意非空子集都有最小元素
\end{enumerate}
\end{definition}
```

### 5.3 良序集

```latex
\begin{definition}[良序集]
全序集 $(A, \leq)$ 是良序集当且仅当：
\begin{enumerate}
\item 每个非空子集都有最小元素
\item 性质：良序集与序数一一对应
\end{enumerate}
\end{definition}
```

## 6. 公理化集合论

### 6.1 ZFC公理系统

```latex
\begin{axiom}[外延性公理]
两个集合相等当且仅当它们包含相同的元素：
$$\forall x \forall y (\forall z (z \in x \leftrightarrow z \in y) \rightarrow x = y)$$
\end{axiom}

\begin{axiom}[空集公理]
存在空集：
$$\exists x \forall y (y \notin x)$$
\end{axiom}

\begin{axiom}[配对公理]
对于任意两个集合，存在包含它们的集合：
$$\forall x \forall y \exists z \forall w (w \in z \leftrightarrow w = x \lor w = y)$$
\end{axiom}

\begin{axiom}[并集公理]
对于任意集合族，存在并集：
$$\forall F \exists A \forall x (x \in A \leftrightarrow \exists B (B \in F \land x \in B))$$
\end{axiom}

\begin{axiom}[幂集公理]
对于任意集合，存在其幂集：
$$\forall x \exists y \forall z (z \in y \leftrightarrow z \subseteq x)$$
\end{axiom}

\begin{axiom}[无穷公理]
存在无限集：
$$\exists x (\emptyset \in x \land \forall y (y \in x \rightarrow y \cup \{y\} \in x))$$
\end{axiom}

\begin{axiom}[替换公理]
对于任意函数和集合，存在像集：
$$\forall A \forall F (\text{Func}(F) \rightarrow \exists B \forall y (y \in B \leftrightarrow \exists x \in A (F(x) = y)))$$
\end{axiom}

\begin{axiom}[正则公理]
每个非空集合都有最小元素：
$$\forall x (x \neq \emptyset \rightarrow \exists y \in x (y \cap x = \emptyset))$$
\end{axiom}

\begin{axiom}[选择公理]
对于任意非空集合族，存在选择函数：
$$\forall F (\emptyset \notin F \rightarrow \exists f: F \rightarrow \bigcup F \forall A \in F (f(A) \in A))$$
\end{axiom}
```

## 7. 应用实例

### 7.1 软件系统中的集合论

```rust
// 集合论在软件系统中的应用
#[derive(Debug, Clone, PartialEq)]
pub struct Set<T> {
    elements: Vec<T>,
}

impl<T: Clone + PartialEq> Set<T> {
    pub fn new() -> Self {
        Set { elements: Vec::new() }
    }
    
    pub fn from_vec(elements: Vec<T>) -> Self {
        let mut set = Set::new();
        for element in elements {
            set.insert(element);
        }
        set
    }
    
    pub fn insert(&mut self, element: T) {
        if !self.contains(&element) {
            self.elements.push(element);
        }
    }
    
    pub fn contains(&self, element: &T) -> bool {
        self.elements.contains(element)
    }
    
    pub fn union(&self, other: &Set<T>) -> Set<T> {
        let mut result = self.clone();
        for element in &other.elements {
            result.insert(element.clone());
        }
        result
    }
    
    pub fn intersection(&self, other: &Set<T>) -> Set<T> {
        let mut result = Set::new();
        for element in &self.elements {
            if other.contains(element) {
                result.insert(element.clone());
            }
        }
        result
    }
    
    pub fn difference(&self, other: &Set<T>) -> Set<T> {
        let mut result = Set::new();
        for element in &self.elements {
            if !other.contains(element) {
                result.insert(element.clone());
            }
        }
        result
    }
    
    pub fn is_subset(&self, other: &Set<T>) -> bool {
        self.elements.iter().all(|e| other.contains(e))
    }
    
    pub fn is_equal(&self, other: &Set<T>) -> bool {
        self.is_subset(other) && other.is_subset(self)
    }
}

// 关系表示
#[derive(Debug, Clone)]
pub struct Relation<T> {
    pairs: Set<(T, T)>,
}

impl<T: Clone + PartialEq> Relation<T> {
    pub fn new() -> Self {
        Relation { pairs: Set::new() }
    }
    
    pub fn add_pair(&mut self, a: T, b: T) {
        self.pairs.insert((a, b));
    }
    
    pub fn is_reflexive(&self, domain: &Set<T>) -> bool {
        domain.elements.iter().all(|x| self.pairs.contains(&(x.clone(), x.clone())))
    }
    
    pub fn is_symmetric(&self) -> bool {
        self.pairs.elements.iter().all(|(a, b)| {
            self.pairs.contains(&(b.clone(), a.clone()))
        })
    }
    
    pub fn is_transitive(&self) -> bool {
        for (a, b) in &self.pairs.elements {
            for (c, d) in &self.pairs.elements {
                if b == c {
                    if !self.pairs.contains(&(a.clone(), d.clone())) {
                        return false;
                    }
                }
            }
        }
        true
    }
    
    pub fn is_equivalence(&self, domain: &Set<T>) -> bool {
        self.is_reflexive(domain) && self.is_symmetric() && self.is_transitive()
    }
}

// 函数表示
#[derive(Debug, Clone)]
pub struct Function<T, U> {
    domain: Set<T>,
    codomain: Set<U>,
    mapping: Vec<(T, U)>,
}

impl<T: Clone + PartialEq, U: Clone + PartialEq> Function<T, U> {
    pub fn new(domain: Set<T>, codomain: Set<U>) -> Self {
        Function {
            domain,
            codomain,
            mapping: Vec::new(),
        }
    }
    
    pub fn add_mapping(&mut self, input: T, output: U) -> Result<(), String> {
        if !self.domain.contains(&input) {
            return Err("Input not in domain".to_string());
        }
        if !self.codomain.contains(&output) {
            return Err("Output not in codomain".to_string());
        }
        
        // 检查是否已经存在映射
        for (existing_input, _) in &self.mapping {
            if existing_input == &input {
                return Err("Input already mapped".to_string());
            }
        }
        
        self.mapping.push((input, output));
        Ok(())
    }
    
    pub fn apply(&self, input: &T) -> Option<U> {
        for (x, y) in &self.mapping {
            if x == input {
                return Some(y.clone());
            }
        }
        None
    }
    
    pub fn is_injective(&self) -> bool {
        for i in 0..self.mapping.len() {
            for j in (i+1)..self.mapping.len() {
                if self.mapping[i].1 == self.mapping[j].1 {
                    return false;
                }
            }
        }
        true
    }
    
    pub fn is_surjective(&self) -> bool {
        self.codomain.elements.iter().all(|y| {
            self.mapping.iter().any(|(_, output)| output == y)
        })
    }
    
    pub fn is_bijective(&self) -> bool {
        self.is_injective() && self.is_surjective()
    }
}
```

### 7.2 数据库中的集合论

```rust
// 数据库查询中的集合论应用
#[derive(Debug, Clone)]
pub struct Database {
    tables: Vec<Table>,
}

impl Database {
    pub fn query(&self, query: &Query) -> Result<Table, String> {
        match query {
            Query::Select { table, condition } => {
                let table_data = self.get_table(table)?;
                table_data.filter(condition)
            }
            Query::Union { left, right } => {
                let left_result = self.query(left)?;
                let right_result = self.query(right)?;
                left_result.union(&right_result)
            }
            Query::Intersection { left, right } => {
                let left_result = self.query(left)?;
                let right_result = self.query(right)?;
                left_result.intersection(&right_result)
            }
            Query::Difference { left, right } => {
                let left_result = self.query(left)?;
                let right_result = self.query(right)?;
                left_result.difference(&right_result)
            }
            Query::Join { left, right, condition } => {
                let left_result = self.query(left)?;
                let right_result = self.query(right)?;
                left_result.join(&right_result, condition)
            }
        }
    }
}

#[derive(Debug, Clone)]
pub struct Table {
    columns: Vec<String>,
    rows: Vec<Row>,
}

impl Table {
    pub fn filter(&self, condition: &Condition) -> Result<Table, String> {
        let mut filtered_rows = Vec::new();
        
        for row in &self.rows {
            if condition.evaluate(row)? {
                filtered_rows.push(row.clone());
            }
        }
        
        Ok(Table {
            columns: self.columns.clone(),
            rows: filtered_rows,
        })
    }
    
    pub fn union(&self, other: &Table) -> Result<Table, String> {
        if self.columns != other.columns {
            return Err("Tables must have same schema for union".to_string());
        }
        
        let mut union_rows = self.rows.clone();
        for row in &other.rows {
            if !union_rows.contains(row) {
                union_rows.push(row.clone());
            }
        }
        
        Ok(Table {
            columns: self.columns.clone(),
            rows: union_rows,
        })
    }
    
    pub fn intersection(&self, other: &Table) -> Result<Table, String> {
        if self.columns != other.columns {
            return Err("Tables must have same schema for intersection".to_string());
        }
        
        let mut intersection_rows = Vec::new();
        for row in &self.rows {
            if other.rows.contains(row) {
                intersection_rows.push(row.clone());
            }
        }
        
        Ok(Table {
            columns: self.columns.clone(),
            rows: intersection_rows,
        })
    }
    
    pub fn difference(&self, other: &Table) -> Result<Table, String> {
        if self.columns != other.columns {
            return Err("Tables must have same schema for difference".to_string());
        }
        
        let mut difference_rows = Vec::new();
        for row in &self.rows {
            if !other.rows.contains(row) {
                difference_rows.push(row.clone());
            }
        }
        
        Ok(Table {
            columns: self.columns.clone(),
            rows: difference_rows,
        })
    }
}
```

---

**文档版本**：v1.0  
**创建时间**：2024-12-19  
**最后更新**：2024-12-19  
**状态**：完成

**相关链接**：
- [01-哲学基础理论](../01-哲学基础理论/01-本体论形式化理论.md)
- [02-范畴论基础](./02-范畴论基础.md)
- [03-代数理论](./03-代数理论.md)
