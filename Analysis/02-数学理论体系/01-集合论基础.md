# 集合论基础

## 概述

集合论是数学的基础理论，为所有数学分支提供基础。在软件架构中，集合论为数据结构、关系建模和算法设计提供了理论基础。

## 1. 基本概念

### 1.1 集合的定义

集合是元素的聚集，具有以下基本性质：

#### 外延性公理

```latex
\forall x \forall y (\forall z (z \in x \leftrightarrow z \in y) \rightarrow x = y)
```

#### 空集公理

```latex
\exists x \forall y (y \notin x)
```

#### 配对公理

```latex
\forall x \forall y \exists z \forall w (w \in z \leftrightarrow w = x \lor w = y)
```

### 1.2 集合运算

#### 并集运算

```latex
A \cup B = \{x \mid x \in A \lor x \in B\}
```

#### 交集运算

```latex
A \cap B = \{x \mid x \in A \land x \in B\}
```

#### 差集运算

```latex
A \setminus B = \{x \mid x \in A \land x \notin B\}
```

#### 补集运算

```latex
A^c = \{x \mid x \notin A\}
```

## 2. 形式化实现

### 2.1 集合基础结构

```rust
use std::collections::HashSet;
use std::hash::Hash;

#[derive(Debug, Clone)]
pub struct Set<T> {
    elements: HashSet<T>,
}

impl<T: Clone + Eq + Hash> Set<T> {
    pub fn new() -> Self {
        Self {
            elements: HashSet::new(),
        }
    }
    
    pub fn from_elements(elements: Vec<T>) -> Self {
        Self {
            elements: elements.into_iter().collect(),
        }
    }
    
    pub fn add(&mut self, element: T) {
        self.elements.insert(element);
    }
    
    pub fn remove(&mut self, element: &T) -> bool {
        self.elements.remove(element)
    }
    
    pub fn contains(&self, element: &T) -> bool {
        self.elements.contains(element)
    }
    
    pub fn is_empty(&self) -> bool {
        self.elements.is_empty()
    }
    
    pub fn cardinality(&self) -> usize {
        self.elements.len()
    }
    
    pub fn union(&self, other: &Set<T>) -> Set<T> {
        let mut result = self.clone();
        for element in &other.elements {
            result.add(element.clone());
        }
        result
    }
    
    pub fn intersection(&self, other: &Set<T>) -> Set<T> {
        let mut result = Set::new();
        for element in &self.elements {
            if other.contains(element) {
                result.add(element.clone());
            }
        }
        result
    }
    
    pub fn difference(&self, other: &Set<T>) -> Set<T> {
        let mut result = Set::new();
        for element in &self.elements {
            if !other.contains(element) {
                result.add(element.clone());
            }
        }
        result
    }
    
    pub fn symmetric_difference(&self, other: &Set<T>) -> Set<T> {
        self.difference(other).union(&other.difference(self))
    }
    
    pub fn is_subset(&self, other: &Set<T>) -> bool {
        self.elements.iter().all(|e| other.contains(e))
    }
    
    pub fn is_superset(&self, other: &Set<T>) -> bool {
        other.is_subset(self)
    }
    
    pub fn is_disjoint(&self, other: &Set<T>) -> bool {
        self.intersection(other).is_empty()
    }
    
    pub fn power_set(&self) -> Set<Set<T>> {
        let mut power_set = Set::new();
        power_set.add(Set::new()); // 空集
        
        let elements: Vec<T> = self.elements.iter().cloned().collect();
        let n = elements.len();
        
        for i in 1..(1 << n) {
            let mut subset = Set::new();
            for j in 0..n {
                if (i >> j) & 1 == 1 {
                    subset.add(elements[j].clone());
                }
            }
            power_set.add(subset);
        }
        
        power_set
    }
    
    pub fn cartesian_product<U: Clone + Eq + Hash>(&self, other: &Set<U>) -> Set<(T, U)> {
        let mut product = Set::new();
        for a in &self.elements {
            for b in &other.elements {
                product.add((a.clone(), b.clone()));
            }
        }
        product
    }
}

impl<T: Clone + Eq + Hash> PartialEq for Set<T> {
    fn eq(&self, other: &Self) -> bool {
        self.is_subset(other) && other.is_subset(self)
    }
}

impl<T: Clone + Eq + Hash> Eq for Set<T> {}
```

### 2.2 关系理论

```rust
#[derive(Debug, Clone)]
pub struct Relation<T> {
    pairs: HashSet<(T, T)>,
}

impl<T: Clone + Eq + Hash> Relation<T> {
    pub fn new() -> Self {
        Self {
            pairs: HashSet::new(),
        }
    }
    
    pub fn add_pair(&mut self, a: T, b: T) {
        self.pairs.insert((a, b));
    }
    
    pub fn remove_pair(&mut self, a: &T, b: &T) -> bool {
        self.pairs.remove(&(a.clone(), b.clone()))
    }
    
    pub fn contains_pair(&self, a: &T, b: &T) -> bool {
        self.pairs.contains(&(a.clone(), b.clone()))
    }
    
    pub fn domain(&self) -> Set<T> {
        let mut domain = Set::new();
        for (a, _) in &self.pairs {
            domain.add(a.clone());
        }
        domain
    }
    
    pub fn range(&self) -> Set<T> {
        let mut range = Set::new();
        for (_, b) in &self.pairs {
            range.add(b.clone());
        }
        range
    }
    
    pub fn is_reflexive(&self, domain: &Set<T>) -> bool {
        domain.elements.iter().all(|x| self.contains_pair(x, x))
    }
    
    pub fn is_symmetric(&self) -> bool {
        self.pairs.iter().all(|(a, b)| self.contains_pair(b, a))
    }
    
    pub fn is_antisymmetric(&self) -> bool {
        for (a, b) in &self.pairs {
            if a != b && self.contains_pair(b, a) {
                return false;
            }
        }
        true
    }
    
    pub fn is_transitive(&self) -> bool {
        for (a, b) in &self.pairs {
            for (c, d) in &self.pairs {
                if b == c && !self.contains_pair(a, d) {
                    return false;
                }
            }
        }
        true
    }
    
    pub fn is_equivalence(&self, domain: &Set<T>) -> bool {
        self.is_reflexive(domain) && self.is_symmetric() && self.is_transitive()
    }
    
    pub fn is_partial_order(&self, domain: &Set<T>) -> bool {
        self.is_reflexive(domain) && self.is_antisymmetric() && self.is_transitive()
    }
    
    pub fn is_total_order(&self, domain: &Set<T>) -> bool {
        if !self.is_partial_order(domain) {
            return false;
        }
        
        // 检查完全性
        for a in &domain.elements {
            for b in &domain.elements {
                if a != b && !self.contains_pair(a, b) && !self.contains_pair(b, a) {
                    return false;
                }
            }
        }
        true
    }
    
    pub fn transitive_closure(&self) -> Relation<T> {
        let mut closure = self.clone();
        let mut changed = true;
        
        while changed {
            changed = false;
            let mut new_pairs = HashSet::new();
            
            for (a, b) in &closure.pairs {
                for (c, d) in &closure.pairs {
                    if b == c && !closure.contains_pair(a, d) {
                        new_pairs.insert((a.clone(), d.clone()));
                        changed = true;
                    }
                }
            }
            
            for pair in new_pairs {
                closure.add_pair(pair.0, pair.1);
            }
        }
        
        closure
    }
    
    pub fn reflexive_closure(&self, domain: &Set<T>) -> Relation<T> {
        let mut closure = self.clone();
        for element in &domain.elements {
            closure.add_pair(element.clone(), element.clone());
        }
        closure
    }
    
    pub fn symmetric_closure(&self) -> Relation<T> {
        let mut closure = self.clone();
        for (a, b) in &self.pairs {
            closure.add_pair(b.clone(), a.clone());
        }
        closure
    }
}
```

### 2.3 函数理论

```rust
#[derive(Debug, Clone)]
pub struct Function<D, R> {
    domain: Set<D>,
    codomain: Set<R>,
    mapping: HashMap<D, R>,
}

impl<D: Clone + Eq + Hash, R: Clone + Eq + Hash> Function<D, R> {
    pub fn new(domain: Set<D>, codomain: Set<R>) -> Self {
        Self {
            domain,
            codomain,
            mapping: HashMap::new(),
        }
    }
    
    pub fn add_mapping(&mut self, input: D, output: R) -> Result<(), String> {
        if !self.domain.contains(&input) {
            return Err("Input not in domain".to_string());
        }
        if !self.codomain.contains(&output) {
            return Err("Output not in codomain".to_string());
        }
        self.mapping.insert(input, output);
        Ok(())
    }
    
    pub fn apply(&self, input: &D) -> Option<&R> {
        self.mapping.get(input)
    }
    
    pub fn is_total(&self) -> bool {
        self.domain.elements.iter().all(|x| self.mapping.contains_key(x))
    }
    
    pub fn is_partial(&self) -> bool {
        !self.is_total()
    }
    
    pub fn is_injective(&self) -> bool {
        let mut seen = HashSet::new();
        for output in self.mapping.values() {
            if !seen.insert(output) {
                return false;
            }
        }
        true
    }
    
    pub fn is_surjective(&self) -> bool {
        self.codomain.elements.iter().all(|y| {
            self.mapping.values().any(|output| output == y)
        })
    }
    
    pub fn is_bijective(&self) -> bool {
        self.is_injective() && self.is_surjective()
    }
    
    pub fn inverse(&self) -> Option<Function<R, D>> {
        if !self.is_bijective() {
            return None;
        }
        
        let mut inverse = Function::new(self.codomain.clone(), self.domain.clone());
        for (input, output) in &self.mapping {
            inverse.add_mapping(output.clone(), input.clone()).ok();
        }
        Some(inverse)
    }
    
    pub fn compose<C: Clone + Eq + Hash>(&self, other: &Function<R, C>) -> Function<D, C> {
        let mut composition = Function::new(self.domain.clone(), other.codomain.clone());
        
        for (input, output) in &self.mapping {
            if let Some(final_output) = other.apply(output) {
                composition.add_mapping(input.clone(), final_output.clone()).ok();
            }
        }
        
        composition
    }
    
    pub fn image(&self, subset: &Set<D>) -> Set<R> {
        let mut image = Set::new();
        for element in &subset.elements {
            if let Some(output) = self.apply(element) {
                image.add(output.clone());
            }
        }
        image
    }
    
    pub fn preimage(&self, subset: &Set<R>) -> Set<D> {
        let mut preimage = Set::new();
        for (input, output) in &self.mapping {
            if subset.contains(output) {
                preimage.add(input.clone());
            }
        }
        preimage
    }
}
```

## 3. 软件架构应用

### 3.1 数据结构建模

```rust
// 基于集合的数据结构
pub struct SetBasedDataStructure<T> {
    elements: Set<T>,
    operations: HashMap<String, Box<dyn Fn(&Set<T>, &[T]) -> Set<T>>>,
}

impl<T: Clone + Eq + Hash> SetBasedDataStructure<T> {
    pub fn new() -> Self {
        let mut operations = HashMap::new();
        
        // 添加操作
        operations.insert(
            "add".to_string(),
            Box::new(|set: &Set<T>, args: &[T]| {
                let mut result = set.clone();
                for arg in args {
                    result.add(arg.clone());
                }
                result
            }),
        );
        
        // 删除操作
        operations.insert(
            "remove".to_string(),
            Box::new(|set: &Set<T>, args: &[T]| {
                let mut result = set.clone();
                for arg in args {
                    result.remove(arg);
                }
                result
            }),
        );
        
        // 查找操作
        operations.insert(
            "find".to_string(),
            Box::new(|set: &Set<T>, args: &[T]| {
                let mut result = Set::new();
                for arg in args {
                    if set.contains(arg) {
                        result.add(arg.clone());
                    }
                }
                result
            }),
        );
        
        Self {
            elements: Set::new(),
            operations,
        }
    }
    
    pub fn execute_operation(&self, operation_name: &str, args: &[T]) -> Result<Set<T>, String> {
        if let Some(operation) = self.operations.get(operation_name) {
            Ok(operation(&self.elements, args))
        } else {
            Err(format!("Unknown operation: {}", operation_name))
        }
    }
    
    pub fn add_element(&mut self, element: T) {
        self.elements.add(element);
    }
    
    pub fn remove_element(&mut self, element: &T) -> bool {
        self.elements.remove(element)
    }
    
    pub fn contains(&self, element: &T) -> bool {
        self.elements.contains(element)
    }
    
    pub fn size(&self) -> usize {
        self.elements.cardinality()
    }
    
    pub fn is_empty(&self) -> bool {
        self.elements.is_empty()
    }
    
    pub fn clear(&mut self) {
        self.elements = Set::new();
    }
    
    pub fn union_with(&self, other: &Set<T>) -> Set<T> {
        self.elements.union(other)
    }
    
    pub fn intersection_with(&self, other: &Set<T>) -> Set<T> {
        self.elements.intersection(other)
    }
    
    pub fn difference_with(&self, other: &Set<T>) -> Set<T> {
        self.elements.difference(other)
    }
}
```

### 3.2 关系数据库建模

```rust
// 基于关系的数据模型
pub struct RelationalDataModel {
    relations: HashMap<String, Relation<String>>,
    attributes: HashMap<String, Set<String>>,
    constraints: Vec<Constraint>,
}

#[derive(Debug, Clone)]
pub struct Constraint {
    constraint_type: ConstraintType,
    relation_name: String,
    attributes: Vec<String>,
    condition: String,
}

#[derive(Debug, Clone)]
pub enum ConstraintType {
    PrimaryKey,
    ForeignKey,
    Unique,
    NotNull,
    Check,
}

impl RelationalDataModel {
    pub fn new() -> Self {
        Self {
            relations: HashMap::new(),
            attributes: HashMap::new(),
            constraints: Vec::new(),
        }
    }
    
    pub fn create_relation(&mut self, name: String, attributes: Set<String>) {
        self.relations.insert(name.clone(), Relation::new());
        self.attributes.insert(name, attributes);
    }
    
    pub fn add_tuple(&mut self, relation_name: &str, tuple: (String, String)) -> Result<(), String> {
        if let Some(relation) = self.relations.get_mut(relation_name) {
            relation.add_pair(tuple.0, tuple.1);
            Ok(())
        } else {
            Err(format!("Relation {} not found", relation_name))
        }
    }
    
    pub fn remove_tuple(&mut self, relation_name: &str, tuple: (String, String)) -> Result<bool, String> {
        if let Some(relation) = self.relations.get_mut(relation_name) {
            Ok(relation.remove_pair(&tuple.0, &tuple.1))
        } else {
            Err(format!("Relation {} not found", relation_name))
        }
    }
    
    pub fn select(&self, relation_name: &str, condition: &str) -> Result<Set<(String, String)>, String> {
        if let Some(relation) = self.relations.get(relation_name) {
            let mut result = Set::new();
            for pair in &relation.pairs {
                if self.evaluate_condition(pair, condition) {
                    result.add(pair.clone());
                }
            }
            Ok(result)
        } else {
            Err(format!("Relation {} not found", relation_name))
        }
    }
    
    pub fn project(&self, relation_name: &str, attributes: &[String]) -> Result<Set<String>, String> {
        if let Some(relation) = self.relations.get(relation_name) {
            let mut result = Set::new();
            for (a, _) in &relation.pairs {
                if attributes.contains(a) {
                    result.add(a.clone());
                }
            }
            Ok(result)
        } else {
            Err(format!("Relation {} not found", relation_name))
        }
    }
    
    pub fn join(&self, relation1: &str, relation2: &str, join_condition: &str) -> Result<Set<(String, String, String)>, String> {
        let rel1 = self.relations.get(relation1)
            .ok_or_else(|| format!("Relation {} not found", relation1))?;
        let rel2 = self.relations.get(relation2)
            .ok_or_else(|| format!("Relation {} not found", relation2))?;
        
        let mut result = Set::new();
        for (a1, b1) in &rel1.pairs {
            for (a2, b2) in &rel2.pairs {
                if self.evaluate_join_condition((a1, b1), (a2, b2), join_condition) {
                    result.add((a1.clone(), b1.clone(), b2.clone()));
                }
            }
        }
        Ok(result)
    }
    
    fn evaluate_condition(&self, pair: &(String, String), condition: &str) -> bool {
        // 简化的条件求值
        match condition {
            "true" => true,
            "false" => false,
            _ => true, // 默认返回true
        }
    }
    
    fn evaluate_join_condition(
        &self,
        pair1: &(String, String),
        pair2: &(String, String),
        condition: &str,
    ) -> bool {
        // 简化的连接条件求值
        match condition {
            "equi_join" => pair1.1 == pair2.0,
            _ => false,
        }
    }
    
    pub fn add_constraint(&mut self, constraint: Constraint) {
        self.constraints.push(constraint);
    }
    
    pub fn validate_constraints(&self) -> Vec<ConstraintViolation> {
        let mut violations = Vec::new();
        
        for constraint in &self.constraints {
            if let Some(violation) = self.check_constraint(constraint) {
                violations.push(violation);
            }
        }
        
        violations
    }
    
    fn check_constraint(&self, constraint: &Constraint) -> Option<ConstraintViolation> {
        match constraint.constraint_type {
            ConstraintType::PrimaryKey => self.check_primary_key(constraint),
            ConstraintType::ForeignKey => self.check_foreign_key(constraint),
            ConstraintType::Unique => self.check_unique(constraint),
            ConstraintType::NotNull => self.check_not_null(constraint),
            ConstraintType::Check => self.check_check(constraint),
        }
    }
    
    fn check_primary_key(&self, constraint: &Constraint) -> Option<ConstraintViolation> {
        // 检查主键约束
        None
    }
    
    fn check_foreign_key(&self, constraint: &Constraint) -> Option<ConstraintViolation> {
        // 检查外键约束
        None
    }
    
    fn check_unique(&self, constraint: &Constraint) -> Option<ConstraintViolation> {
        // 检查唯一性约束
        None
    }
    
    fn check_not_null(&self, constraint: &Constraint) -> Option<ConstraintViolation> {
        // 检查非空约束
        None
    }
    
    fn check_check(&self, constraint: &Constraint) -> Option<ConstraintViolation> {
        // 检查检查约束
        None
    }
}

#[derive(Debug, Clone)]
pub struct ConstraintViolation {
    constraint: Constraint,
    description: String,
    severity: String,
}
```

## 4. 交叉引用

- [[00-数学理论体系总论|数学理论体系总论]]
- [[02-代数理论|代数理论]]
- [[03-分析理论|分析理论]]
- [[04-几何理论|几何理论]]
- [[05-概率统计理论|概率统计理论]]

## 导航

- [返回总目录](../README.md)
- [返回数学理论体系](00-数学理论体系总论.md)
- [02-代数理论](02-代数理论.md)
- [03-分析理论](03-分析理论.md)
- [04-几何理论](04-几何理论.md)
- [05-概率统计理论](05-概率统计理论.md)
