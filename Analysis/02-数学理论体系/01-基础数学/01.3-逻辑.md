# 01.3-逻辑

## 目录

1. [1.0 逻辑基础](#10-逻辑基础)
2. [2.0 命题逻辑](#20-命题逻辑)
3. [3.0 谓词逻辑](#30-谓词逻辑)
4. [4.0 证明理论](#40-证明理论)
5. [5.0 模型论](#50-模型论)
6. [6.0 递归论](#60-递归论)
7. [7.0 数学逻辑与计算](#70-数学逻辑与计算)
8. [8.0 逻辑与数学基础](#80-逻辑与数学基础)
9. [9.0 逻辑与编程语言](#90-逻辑与编程语言)
10. [10.0 逻辑的前沿与应用](#100-逻辑的前沿与应用)

---

## 1.0 逻辑基础

### 1.1 逻辑的定义

**定义 1.1.1 (逻辑)**
逻辑是研究推理、论证和思维形式的数学分支，形式化地描述命题、关系、推理规则及其有效性。

$$
\mathcal{L} = (\mathcal{S}, \mathcal{A}, \mathcal{R}, \mathcal{I}, \mathcal{V})
$$
其中：
- $\mathcal{S}$：符号集合（Symbols）
- $\mathcal{A}$：公理集合（Axioms）
- $\mathcal{R}$：推理规则（Rules）
- $\mathcal{I}$：解释函数（Interpretation）
- $\mathcal{V}$：验证函数（Verification）

### 1.2 逻辑的基本结构

- **形式语言**：由字母表、语法规则、合式公式组成。
- **公理系统**：一组无需证明的基本命题。
- **推理规则**：从已知命题推出新命题的规则。
- **证明系统**：组织推理步骤的系统（如自然演绎、希尔伯特系统、序列演算）。

### 1.3 逻辑符号系统

| 符号 | 名称         | 说明           |
|------|--------------|----------------|
| $\land$ | 合取/与      | $A \land B$ 表示A且B |
| $\lor$ | 析取/或      | $A \lor B$ 表示A或B |
| $\neg$ | 否定/非      | $\neg A$ 表示非A |
| $\rightarrow$ | 蕴含      | $A \rightarrow B$ 表示A蕴含B |
| $\leftrightarrow$ | 等价   | $A \leftrightarrow B$ 表示A等价于B |
| $\forall$ | 全称量词    | $\forall x P(x)$ 表示对所有x成立 |
| $\exists$ | 存在量词    | $\exists x P(x)$ 表示存在x使P(x)成立 |
| $\top$ | 真           | 恒真 |
| $\bot$ | 假           | 恒假 |

### 1.4 基本推理规则

- **分离规则（Modus Ponens）**：
  $$
  \frac{P \rightarrow Q \quad P}{Q}
  $$
- **合取引入**：
  $$
  \frac{P \quad Q}{P \land Q}
  $$
- **析取引入**：
  $$
  \frac{P}{P \lor Q}
  $$
- **全称概括**：
  $$
  \frac{P(x)}{\forall x P(x)}
  $$
- **存在引入**：
  $$
  \frac{P(a)}{\exists x P(x)}
  $$

### 1.5 证明系统

- **自然演绎系统**：基于引入和消去规则，强调推理的自然性。
- **希尔伯特系统**：以少量公理和推理规则为基础，结构简洁。
- **序列演算**：以相继式为基本单位，适合自动化证明。

```rust
// 逻辑公式的基本结构
#[derive(Debug, Clone)]
pub enum Formula {
    Atom(String),
    Not(Box<Formula>),
    And(Box<Formula>, Box<Formula>),
    Or(Box<Formula>, Box<Formula>),
    Implies(Box<Formula>, Box<Formula>),
    Iff(Box<Formula>, Box<Formula>),
    ForAll(String, Box<Formula>),
    Exists(String, Box<Formula>),
}

// 推理规则示例：Modus Ponens
fn modus_ponens(p_implies_q: &Formula, p: &Formula) -> Option<Formula> {
    if let Formula::Implies(p1, q) = p_implies_q {
        if **p1 == *p {
            return Some((**q).clone());
        }
    }
    None
}
```

## 2.0 命题逻辑

### 2.1 命题逻辑语法

**定义 2.1.1 (命题逻辑语言)**
命题逻辑语言 $\mathcal{L}_P$ 由以下部分组成：

1. **字母表**：
   - 命题变元：$P, Q, R, \ldots$ 或 $p_1, p_2, p_3, \ldots$
   - 逻辑连接词：$\neg, \land, \lor, \rightarrow, \leftrightarrow$
   - 辅助符号：$(, )$

2. **合式公式（WFF）**：
   - 原子公式：每个命题变元都是合式公式
   - 复合公式：
     - 如果 $\phi$ 是合式公式，则 $\neg\phi$ 是合式公式
     - 如果 $\phi, \psi$ 是合式公式，则 $(\phi \land \psi), (\phi \lor \psi), (\phi \rightarrow \psi), (\phi \leftrightarrow \psi)$ 是合式公式

**BNF语法**：
```
φ ::= p | ¬φ | (φ ∧ φ) | (φ ∨ φ) | (φ → φ) | (φ ↔ φ)
```

### 2.2 命题逻辑语义

**定义 2.2.1 (真值赋值)**
真值赋值是一个函数 $v: \mathcal{P} \rightarrow \{0,1\}$，其中 $\mathcal{P}$ 是命题变元集合。

**定义 2.2.2 (真值函数)**
给定真值赋值 $v$，公式 $\phi$ 的真值 $v(\phi)$ 递归定义如下：

$$
\begin{align}
v(p) &= v(p) \text{ 对命题变元 } p \\
v(\neg\phi) &= 1 - v(\phi) \\
v(\phi \land \psi) &= \min(v(\phi), v(\psi)) \\
v(\phi \lor \psi) &= \max(v(\phi), v(\psi)) \\
v(\phi \rightarrow \psi) &= \max(1-v(\phi), v(\psi)) \\
v(\phi \leftrightarrow \psi) &= 1 \text{ 当且仅当 } v(\phi) = v(\psi)
\end{align}
$$

**真值表**：

| $P$ | $Q$ | $\neg P$ | $P \land Q$ | $P \lor Q$ | $P \rightarrow Q$ | $P \leftrightarrow Q$ |
|-----|-----|----------|-------------|------------|-------------------|----------------------|
| 0   | 0   | 1        | 0           | 0          | 1                 | 1                    |
| 0   | 1   | 1        | 0           | 1          | 1                 | 0                    |
| 1   | 0   | 0        | 0           | 1          | 0                 | 0                    |
| 1   | 1   | 0        | 1           | 1          | 1                 | 1                    |

### 2.3 命题逻辑公理系统

**定义 2.3.1 (希尔伯特公理系统)**
经典命题逻辑的希尔伯特公理系统包含以下公理模式：

**公理1**：$A \rightarrow (B \rightarrow A)$

**公理2**：$(A \rightarrow (B \rightarrow C)) \rightarrow ((A \rightarrow B) \rightarrow (A \rightarrow C))$

**公理3**：$(\neg A \rightarrow \neg B) \rightarrow (B \rightarrow A)$

**推理规则**：分离规则（Modus Ponens）
$$
\frac{A \rightarrow B \quad A}{B}
$$

**定理 2.3.1 (演绎定理)**
如果 $\Gamma \cup \{A\} \vdash B$，则 $\Gamma \vdash A \rightarrow B$

### 2.4 自然演绎系统

**定义 2.4.1 (自然演绎规则)**

**合取规则**：
$$
\frac{A \quad B}{A \land B} \text{ (∧I)} \quad \frac{A \land B}{A} \text{ (∧E₁)} \quad \frac{A \land B}{B} \text{ (∧E₂)}
$$

**析取规则**：
$$
\frac{A}{A \lor B} \text{ (∨I₁)} \quad \frac{B}{A \lor B} \text{ (∨I₂)} \quad \frac{A \lor B \quad [A] \vdash C \quad [B] \vdash C}{C} \text{ (∨E)}
$$

**蕴含规则**：
$$
\frac{[A] \vdash B}{A \rightarrow B} \text{ (→I)} \quad \frac{A \rightarrow B \quad A}{B} \text{ (→E)}
$$

**否定规则**：
$$
\frac{[A] \vdash \bot}{\neg A} \text{ (¬I)} \quad \frac{A \quad \neg A}{\bot} \text{ (¬E)} \quad \frac{\bot}{A} \text{ (⊥E)}
$$

### 2.5 命题逻辑的性质

**定义 2.5.1 (重言式)**
公式 $\phi$ 是重言式（永真式），当且仅当对所有真值赋值 $v$，都有 $v(\phi) = 1$。

**定义 2.5.2 (矛盾式)**
公式 $\phi$ 是矛盾式（永假式），当且仅当对所有真值赋值 $v$，都有 $v(\phi) = 0$。

**定义 2.5.3 (可满足性)**
公式 $\phi$ 是可满足的，当且仅当存在真值赋值 $v$，使得 $v(\phi) = 1$。

**定理 2.5.1 (对偶性)**
如果 $\phi$ 是重言式，则 $\neg\phi$ 是矛盾式；如果 $\phi$ 是矛盾式，则 $\neg\phi$ 是重言式。

### 2.6 命题逻辑的判定问题

**问题 2.6.1 (重言式判定)**
给定命题公式 $\phi$，判断 $\phi$ 是否为重言式。

**算法 2.6.1 (真值表法)**
1. 列出所有可能的真值赋值
2. 计算每个赋值下公式的真值
3. 检查是否所有真值都为1

**算法 2.6.2 (归结法)**
1. 将公式转换为合取范式（CNF）
2. 应用归结规则
3. 如果能归结出空子句，则原公式是重言式

### 2.7 范式理论

**定义 2.7.1 (析取范式 DNF)**
公式是析取范式，当且仅当它是形如 $\bigvee_{i=1}^n \bigwedge_{j=1}^{m_i} l_{ij}$ 的析取，其中 $l_{ij}$ 是文字（原子或原子的否定）。

**定义 2.7.2 (合取范式 CNF)**
公式是合取范式，当且仅当它是形如 $\bigwedge_{i=1}^n \bigvee_{j=1}^{m_i} l_{ij}$ 的合取，其中 $l_{ij}$ 是文字。

**定理 2.7.1 (范式存在性)**
每个命题公式都存在等价的DNF和CNF。

**算法 2.7.1 (CNF转换)**
1. 消去 $\leftrightarrow$ 和 $\rightarrow$
2. 将 $\neg$ 内移（德摩根律）
3. 分配律展开
4. 合并同类项

### 2.8 命题逻辑的完备性

**定理 2.8.1 (命题逻辑完备性)**
命题逻辑的公理系统是完备的，即：
- 如果 $\phi$ 是重言式，则 $\vdash \phi$（完备性）
- 如果 $\vdash \phi$，则 $\phi$ 是重言式（可靠性）

**证明思路**：
1. 证明每个重言式都可以从公理推导
2. 使用归纳法，基于公式的复杂度
3. 利用真值表的结构性质

```rust
// 命题逻辑公式的Rust实现
#[derive(Debug, Clone, PartialEq)]
pub enum PropFormula {
    Atom(String),
    Not(Box<PropFormula>),
    And(Box<PropFormula>, Box<PropFormula>),
    Or(Box<PropFormula>, Box<PropFormula>),
    Implies(Box<PropFormula>, Box<PropFormula>),
    Iff(Box<PropFormula>, Box<PropFormula>),
}

impl PropFormula {
    // 计算真值
    pub fn evaluate(&self, assignment: &std::collections::HashMap<String, bool>) -> bool {
        match self {
            PropFormula::Atom(name) => *assignment.get(name).unwrap_or(&false),
            PropFormula::Not(f) => !f.evaluate(assignment),
            PropFormula::And(f1, f2) => f1.evaluate(assignment) && f2.evaluate(assignment),
            PropFormula::Or(f1, f2) => f1.evaluate(assignment) || f2.evaluate(assignment),
            PropFormula::Implies(f1, f2) => !f1.evaluate(assignment) || f2.evaluate(assignment),
            PropFormula::Iff(f1, f2) => f1.evaluate(assignment) == f2.evaluate(assignment),
        }
    }
    
    // 检查是否为重言式
    pub fn is_tautology(&self) -> bool {
        let vars = self.collect_variables();
        let mut assignment = std::collections::HashMap::new();
        self.check_all_assignments(&vars, &mut assignment, 0)
    }
    
    fn collect_variables(&self) -> Vec<String> {
        let mut vars = std::collections::HashSet::new();
        self.collect_vars_recursive(&mut vars);
        vars.into_iter().collect()
    }
    
    fn collect_vars_recursive(&self, vars: &mut std::collections::HashSet<String>) {
        match self {
            PropFormula::Atom(name) => { vars.insert(name.clone()); }
            PropFormula::Not(f) => f.collect_vars_recursive(vars),
            PropFormula::And(f1, f2) | PropFormula::Or(f1, f2) | 
            PropFormula::Implies(f1, f2) | PropFormula::Iff(f1, f2) => {
                f1.collect_vars_recursive(vars);
                f2.collect_vars_recursive(vars);
            }
        }
    }
    
    fn check_all_assignments(&self, vars: &[String], assignment: &mut std::collections::HashMap<String, bool>, index: usize) -> bool {
        if index >= vars.len() {
            return self.evaluate(assignment);
        }
        
        assignment.insert(vars[index].clone(), false);
        let result1 = self.check_all_assignments(vars, assignment, index + 1);
        
        assignment.insert(vars[index].clone(), true);
        let result2 = self.check_all_assignments(vars, assignment, index + 1);
        
        result1 && result2
    }
}

// 示例：验证德摩根律
fn demo_demorgan() {
    let p = PropFormula::Atom("P".to_string());
    let q = PropFormula::Atom("Q".to_string());
    
    // ¬(P ∧ Q) ↔ (¬P ∨ ¬Q)
    let left = PropFormula::Not(Box::new(PropFormula::And(Box::new(p.clone()), Box::new(q.clone()))));
    let right = PropFormula::Or(
        Box::new(PropFormula::Not(Box::new(p))),
        Box::new(PropFormula::Not(Box::new(q)))
    );
    let demorgan = PropFormula::Iff(Box::new(left), Box::new(right));
    
    assert!(demorgan.is_tautology());
    println!("德摩根律验证成功！");
}
```

### 2.9 命题逻辑的应用

**应用 2.9.1 (数字电路设计)**
命题逻辑是数字电路设计的基础，逻辑门对应逻辑连接词：
- AND门：$A \land B$
- OR门：$A \lor B$
- NOT门：$\neg A$
- NAND门：$\neg(A \land B)$
- NOR门：$\neg(A \lor B)$

**应用 2.9.2 (软件验证)**
命题逻辑用于：
- 程序正确性验证
- 模型检测
- 静态分析
- 形式化规范

**应用 2.9.3 (人工智能)**
命题逻辑在AI中的应用：
- 知识表示
- 推理系统
- 专家系统
- 自动定理证明

## 3.0 谓词逻辑

### 3.1 一阶谓词逻辑语法

**定义 3.1.1 (一阶语言)**
一阶语言 $\mathcal{L}$ 由以下部分组成：

1. **逻辑符号**：
   - 变量：$x, y, z, \ldots$ 或 $x_1, x_2, x_3, \ldots$
   - 逻辑连接词：$\neg, \land, \lor, \rightarrow, \leftrightarrow$
   - 量词：$\forall, \exists$
   - 等号：$=$
   - 辅助符号：$(, ), ,$

2. **非逻辑符号**：
   - 函数符号：$f, g, h, \ldots$（每个符号有固定的元数）
   - 谓词符号：$P, Q, R, \ldots$（每个符号有固定的元数）
   - 常元符号：$c, d, e, \ldots$

**定义 3.1.2 (项)**
项递归定义如下：
- 变量是项
- 常元是项
- 如果 $f$ 是 $n$ 元函数符号，$t_1, \ldots, t_n$ 是项，则 $f(t_1, \ldots, t_n)$ 是项

**定义 3.1.3 (原子公式)**
原子公式形如：
- $P(t_1, \ldots, t_n)$，其中 $P$ 是 $n$ 元谓词符号，$t_1, \ldots, t_n$ 是项
- $t_1 = t_2$，其中 $t_1, t_2$ 是项

**定义 3.1.4 (合式公式)**
合式公式递归定义如下：
- 原子公式是合式公式
- 如果 $\phi$ 是合式公式，则 $\neg\phi$ 是合式公式
- 如果 $\phi, \psi$ 是合式公式，则 $(\phi \land \psi), (\phi \lor \psi), (\phi \rightarrow \psi), (\phi \leftrightarrow \psi)$ 是合式公式
- 如果 $\phi$ 是合式公式，$x$ 是变量，则 $\forall x \phi, \exists x \phi$ 是合式公式

### 3.2 一阶谓词逻辑语义

**定义 3.2.1 (结构)**
语言 $\mathcal{L}$ 的结构 $\mathcal{A} = (A, I)$ 由以下部分组成：
- 非空集合 $A$（论域）
- 解释函数 $I$，将符号映射到论域上的对象

**定义 3.2.2 (赋值)**
赋值是一个函数 $s: \text{Var} \rightarrow A$，将变量映射到论域元素。

**定义 3.2.3 (项的解释)**
给定结构 $\mathcal{A}$ 和赋值 $s$，项 $t$ 的解释 $t^{\mathcal{A}}[s]$ 递归定义：

$$
\begin{align}
x^{\mathcal{A}}[s] &= s(x) \\
c^{\mathcal{A}}[s] &= I(c) \\
f(t_1, \ldots, t_n)^{\mathcal{A}}[s] &= I(f)(t_1^{\mathcal{A}}[s], \ldots, t_n^{\mathcal{A}}[s])
\end{align}
$$

**定义 3.2.4 (公式的满足关系)**
满足关系 $\mathcal{A} \models \phi[s]$ 递归定义：

$$
\begin{align}
\mathcal{A} \models P(t_1, \ldots, t_n)[s] &\Leftrightarrow (t_1^{\mathcal{A}}[s], \ldots, t_n^{\mathcal{A}}[s]) \in I(P) \\
\mathcal{A} \models t_1 = t_2[s] &\Leftrightarrow t_1^{\mathcal{A}}[s] = t_2^{\mathcal{A}}[s] \\
\mathcal{A} \models \neg\phi[s] &\Leftrightarrow \mathcal{A} \not\models \phi[s] \\
\mathcal{A} \models \phi \land \psi[s] &\Leftrightarrow \mathcal{A} \models \phi[s] \text{ 且 } \mathcal{A} \models \psi[s] \\
\mathcal{A} \models \phi \lor \psi[s] &\Leftrightarrow \mathcal{A} \models \phi[s] \text{ 或 } \mathcal{A} \models \psi[s] \\
\mathcal{A} \models \phi \rightarrow \psi[s] &\Leftrightarrow \mathcal{A} \not\models \phi[s] \text{ 或 } \mathcal{A} \models \psi[s] \\
\mathcal{A} \models \forall x \phi[s] &\Leftrightarrow \text{对所有 } a \in A, \mathcal{A} \models \phi[s(x|a)] \\
\mathcal{A} \models \exists x \phi[s] &\Leftrightarrow \text{存在 } a \in A, \mathcal{A} \models \phi[s(x|a)]
\end{align}
$$

其中 $s(x|a)$ 表示将 $s$ 中 $x$ 的值改为 $a$ 的赋值。

### 3.3 一阶谓词逻辑公理系统

**定义 3.3.1 (一阶逻辑公理)**
一阶逻辑的公理包括：

**命题公理**：所有命题逻辑的重言式

**等号公理**：
- $x = x$（自反性）
- $x = y \rightarrow y = x$（对称性）
- $(x = y \land y = z) \rightarrow x = z$（传递性）
- $(x_1 = y_1 \land \cdots \land x_n = y_n) \rightarrow f(x_1, \ldots, x_n) = f(y_1, \ldots, y_n)$（函数替换）
- $(x_1 = y_1 \land \cdots \land x_n = y_n) \rightarrow (P(x_1, \ldots, x_n) \rightarrow P(y_1, \ldots, y_n))$（谓词替换）

**量词公理**：
- $\forall x \phi(x) \rightarrow \phi(t)$（全称实例化）
- $\phi(t) \rightarrow \exists x \phi(x)$（存在概括）

**推理规则**：
- 分离规则：$\frac{\phi \rightarrow \psi \quad \phi}{\psi}$
- 全称概括：$\frac{\phi}{\forall x \phi}$（$x$ 不在 $\phi$ 的自由变量中）
- 存在概括：$\frac{\phi \rightarrow \psi}{\exists x \phi \rightarrow \psi}$（$x$ 不在 $\psi$ 的自由变量中）

### 3.4 量词理论

**定义 3.4.1 (自由变量)**
变量 $x$ 在公式 $\phi$ 中自由出现，递归定义：
- 在原子公式 $P(t_1, \ldots, t_n)$ 中，$x$ 自由当且仅当 $x$ 出现在某个 $t_i$ 中
- 在 $\neg\phi$ 中，$x$ 自由当且仅当在 $\phi$ 中自由
- 在 $\phi \land \psi, \phi \lor \psi, \phi \rightarrow \psi, \phi \leftrightarrow \psi$ 中，$x$ 自由当且仅当在 $\phi$ 或 $\psi$ 中自由
- 在 $\forall y \phi, \exists y \phi$ 中，$x$ 自由当且仅当 $x \neq y$ 且在 $\phi$ 中自由

**定义 3.4.2 (闭公式)**
公式 $\phi$ 是闭公式（句子），当且仅当 $\phi$ 中没有自由变量。

**定理 3.4.1 (量词对偶性)**
- $\neg\forall x \phi \leftrightarrow \exists x \neg\phi$
- $\neg\exists x \phi \leftrightarrow \forall x \neg\phi$

**定理 3.4.2 (量词分配律)**
- $\forall x (\phi \land \psi) \leftrightarrow \forall x \phi \land \forall x \psi$
- $\exists x (\phi \lor \psi) \leftrightarrow \exists x \phi \lor \exists x \psi$
- $\forall x \phi \lor \forall x \psi \rightarrow \forall x (\phi \lor \psi)$
- $\exists x (\phi \land \psi) \rightarrow \exists x \phi \land \exists x \psi$

### 3.5 前束范式

**定义 3.5.1 (前束范式)**
公式 $\phi$ 是前束范式，当且仅当 $\phi$ 形如：
$$Q_1 x_1 Q_2 x_2 \cdots Q_n x_n \psi$$
其中 $Q_i$ 是量词（$\forall$ 或 $\exists$），$\psi$ 是不含量词的公式（矩阵）。

**定理 3.5.1 (前束范式存在性)**
每个一阶公式都存在等价的前束范式。

**算法 3.5.1 (前束范式转换)**
1. 消去 $\leftrightarrow$ 和 $\rightarrow$
2. 将 $\neg$ 内移（使用量词对偶性）
3. 重命名变量避免冲突
4. 将量词前移

### 3.6 斯科伦范式

**定义 3.6.1 (斯科伦范式)**
公式 $\phi$ 是斯科伦范式，当且仅当 $\phi$ 是形如 $\forall x_1 \cdots \forall x_n \psi$ 的前束范式，其中 $\psi$ 是不含量词的合取范式。

**定理 3.6.1 (斯科伦化)**
每个一阶公式都存在可满足性等价的斯科伦范式。

**算法 3.6.1 (斯科伦化)**
1. 转换为前束范式
2. 对每个存在量词 $\exists y$，引入新的函数符号 $f$ 和变量 $x_1, \ldots, x_n$（对应 $y$ 前的全称量词）
3. 将 $\exists y \psi(y)$ 替换为 $\psi(f(x_1, \ldots, x_n))$

### 3.7 一阶逻辑的完备性

**定理 3.7.1 (哥德尔完备性定理)**
一阶逻辑是完备的，即：
- 如果 $\phi$ 是逻辑有效的，则 $\vdash \phi$（完备性）
- 如果 $\vdash \phi$，则 $\phi$ 是逻辑有效的（可靠性）

**定理 3.7.2 (紧致性定理)**
如果一阶理论 $T$ 的每个有限子集都有模型，则 $T$ 本身有模型。

**定理 3.7.3 (勒文海姆-斯科伦定理)**
如果一阶理论有无限模型，则对任意基数 $\kappa \geq |\mathcal{L}|$，$T$ 都有基数为 $\kappa$ 的模型。

### 3.8 二阶逻辑

**定义 3.8.1 (二阶语言)**
二阶语言允许量词作用于关系变量和函数变量：
- 关系变量：$X, Y, Z, \ldots$（每个变量有固定的元数）
- 函数变量：$F, G, H, \ldots$（每个变量有固定的元数）

**定义 3.8.2 (二阶公式)**
二阶公式允许形如 $\forall X \phi, \exists X \phi, \forall F \phi, \exists F \phi$ 的公式。

**应用 3.8.1 (数学归纳法)**
二阶逻辑可以表达数学归纳法：
$$\forall X ((X(0) \land \forall n (X(n) \rightarrow X(n+1))) \rightarrow \forall n X(n))$$

**应用 3.8.2 (良序性)**
二阶逻辑可以表达自然数的良序性：
$$\forall X (\exists n X(n) \rightarrow \exists n (X(n) \land \forall m (X(m) \rightarrow n \leq m)))$$

### 3.9 模型论基础

**定义 3.9.1 (初等等价)**
两个结构 $\mathcal{A}, \mathcal{B}$ 初等等价，当且仅当它们满足相同的句子。

**定义 3.9.2 (初等子结构)**
结构 $\mathcal{A}$ 是 $\mathcal{B}$ 的初等子结构，当且仅当：
- $A \subseteq B$
- 对所有公式 $\phi(x_1, \ldots, x_n)$ 和 $a_1, \ldots, a_n \in A$：
  $\mathcal{A} \models \phi[a_1, \ldots, a_n] \Leftrightarrow \mathcal{B} \models \phi[a_1, \ldots, a_n]$

**定义 3.9.3 (可定义性)**
集合 $X \subseteq A^n$ 在结构 $\mathcal{A}$ 中可定义，当且仅当存在公式 $\phi(x_1, \ldots, x_n)$，使得：
$$X = \{(a_1, \ldots, a_n) \in A^n : \mathcal{A} \models \phi[a_1, \ldots, a_n]\}$$

```rust
// 一阶谓词逻辑的Rust实现
use std::collections::HashMap;

#[derive(Debug, Clone, PartialEq)]
pub enum Term {
    Variable(String),
    Constant(String),
    Function(String, Vec<Term>),
}

#[derive(Debug, Clone, PartialEq)]
pub enum Formula {
    Atom(String, Vec<Term>),
    Equality(Term, Term),
    Not(Box<Formula>),
    And(Box<Formula>, Box<Formula>),
    Or(Box<Formula>, Box<Formula>),
    Implies(Box<Formula>, Box<Formula>),
    Iff(Box<Formula>, Box<Formula>),
    ForAll(String, Box<Formula>),
    Exists(String, Box<Formula>),
}

// 结构（模型）
pub struct Structure {
    pub domain: Vec<String>,
    pub functions: HashMap<String, Box<dyn Fn(&[String]) -> String>>,
    pub predicates: HashMap<String, Box<dyn Fn(&[String]) -> bool>>,
    pub constants: HashMap<String, String>,
}

impl Structure {
    pub fn new() -> Self {
        Self {
            domain: vec![],
            functions: HashMap::new(),
            predicates: HashMap::new(),
            constants: HashMap::new(),
        }
    }
    
    pub fn add_constant(&mut self, name: &str, value: &str) {
        self.constants.insert(name.to_string(), value.to_string());
    }
    
    pub fn add_function<F>(&mut self, name: &str, func: F)
    where
        F: Fn(&[String]) -> String + 'static,
    {
        self.functions.insert(name.to_string(), Box::new(func));
    }
    
    pub fn add_predicate<F>(&mut self, name: &str, pred: F)
    where
        F: Fn(&[String]) -> bool + 'static,
    {
        self.predicates.insert(name.to_string(), Box::new(pred));
    }
}

// 赋值
pub type Assignment = HashMap<String, String>;

// 项的解释
impl Term {
    pub fn interpret(&self, structure: &Structure, assignment: &Assignment) -> String {
        match self {
            Term::Variable(name) => assignment.get(name).unwrap_or(&"".to_string()).clone(),
            Term::Constant(name) => structure.constants.get(name).unwrap_or(&"".to_string()).clone(),
            Term::Function(name, args) => {
                let arg_values: Vec<String> = args.iter()
                    .map(|arg| arg.interpret(structure, assignment))
                    .collect();
                if let Some(func) = structure.functions.get(name) {
                    func(&arg_values)
                } else {
                    "".to_string()
                }
            }
        }
    }
}

// 公式的满足关系
impl Formula {
    pub fn is_satisfied(&self, structure: &Structure, assignment: &Assignment) -> bool {
        match self {
            Formula::Atom(name, args) => {
                let arg_values: Vec<String> = args.iter()
                    .map(|arg| arg.interpret(structure, assignment))
                    .collect();
                if let Some(pred) = structure.predicates.get(name) {
                    pred(&arg_values)
                } else {
                    false
                }
            }
            Formula::Equality(t1, t2) => {
                t1.interpret(structure, assignment) == t2.interpret(structure, assignment)
            }
            Formula::Not(f) => !f.is_satisfied(structure, assignment),
            Formula::And(f1, f2) => {
                f1.is_satisfied(structure, assignment) && f2.is_satisfied(structure, assignment)
            }
            Formula::Or(f1, f2) => {
                f1.is_satisfied(structure, assignment) || f2.is_satisfied(structure, assignment)
            }
            Formula::Implies(f1, f2) => {
                !f1.is_satisfied(structure, assignment) || f2.is_satisfied(structure, assignment)
            }
            Formula::Iff(f1, f2) => {
                f1.is_satisfied(structure, assignment) == f2.is_satisfied(structure, assignment)
            }
            Formula::ForAll(var, f) => {
                // 简化实现：检查所有域元素
                structure.domain.iter().all(|value| {
                    let mut new_assignment = assignment.clone();
                    new_assignment.insert(var.clone(), value.clone());
                    f.is_satisfied(structure, &new_assignment)
                })
            }
            Formula::Exists(var, f) => {
                // 简化实现：检查是否存在域元素
                structure.domain.iter().any(|value| {
                    let mut new_assignment = assignment.clone();
                    new_assignment.insert(var.clone(), value.clone());
                    f.is_satisfied(structure, &new_assignment)
                })
            }
        }
    }
}

// 示例：群论的公理化
fn group_theory_example() {
    let mut group = Structure::new();
    group.domain = vec!["e".to_string(), "a".to_string(), "b".to_string(), "c".to_string()];
    
    // 单位元
    group.add_constant("e", "e");
    
    // 乘法运算
    group.add_function("mul", |args| {
        // 简化的群乘法表
        match (args[0].as_str(), args[1].as_str()) {
            ("e", x) | (x, "e") => x.to_string(),
            ("a", "a") => "e".to_string(),
            ("a", "b") => "c".to_string(),
            ("b", "a") => "c".to_string(),
            ("b", "b") => "e".to_string(),
            ("c", "c") => "e".to_string(),
            _ => "e".to_string(),
        }
    });
    
    // 结合律：∀x∀y∀z (mul(mul(x,y),z) = mul(x,mul(y,z)))
    let x = Term::Variable("x".to_string());
    let y = Term::Variable("y".to_string());
    let z = Term::Variable("z".to_string());
    
    let left = Term::Function("mul".to_string(), vec![
        Term::Function("mul".to_string(), vec![x.clone(), y.clone()]),
        z.clone()
    ]);
    let right = Term::Function("mul".to_string(), vec![
        x.clone(),
        Term::Function("mul".to_string(), vec![y.clone(), z.clone()])
    ]);
    
    let associativity = Formula::ForAll("x".to_string(), Box::new(
        Formula::ForAll("y".to_string(), Box::new(
            Formula::ForAll("z".to_string(), Box::new(
                Formula::Equality(left, right)
            ))
        ))
    ));
    
    let mut assignment = Assignment::new();
    println!("结合律在群中成立: {}", associativity.is_satisfied(&group, &assignment));
}
```

### 3.10 谓词逻辑的应用

**应用 3.10.1 (数学基础)**
谓词逻辑是数学形式化的基础：
- 集合论的公理化
- 数论的形式化
- 代数的公理化
- 分析的严格化

**应用 3.10.2 (计算机科学)**
谓词逻辑在计算机科学中的应用：
- 程序验证
- 数据库理论
- 人工智能
- 自动定理证明

**应用 3.10.3 (哲学逻辑)**
谓词逻辑在哲学中的应用：
- 形而上学
- 认识论
- 语言哲学
- 科学哲学

## 4.0 证明理论

### 4.1 证明的基本概念

**定义 4.1.1 (证明)**
证明是从公理和假设出发，通过推理规则得到结论的有限步骤序列。

**定义 4.1.2 (形式证明)**
形式证明是满足以下条件的公式序列 $\phi_1, \phi_2, \ldots, \phi_n$：
- 每个 $\phi_i$ 要么是公理，要么是假设，要么是从前面的公式通过推理规则得到的
- $\phi_n$ 是证明的结论

**定义 4.1.3 (可证性)**
公式 $\phi$ 在理论 $T$ 中可证，记作 $T \vdash \phi$，当且仅当存在从 $T$ 的公理到 $\phi$ 的形式证明。

### 4.2 演绎法与归纳法

**定义 4.2.1 (演绎法)**
演绎法是从一般到特殊的推理方法，从普遍原理推导出特殊结论。

**演绎推理模式**：
$$
\frac{\text{大前提：所有 } A \text{ 都是 } B}{\text{小前提：} C \text{ 是 } A} \quad \text{结论：} C \text{ 是 } B
$$

**定义 4.2.2 (归纳法)**
归纳法是从特殊到一般的推理方法，从具体实例推导出普遍规律。

**数学归纳法**：
- **基础步骤**：证明 $P(0)$ 成立
- **归纳步骤**：证明 $\forall n (P(n) \rightarrow P(n+1))$ 成立
- **结论**：$\forall n P(n)$ 成立

**定理 4.2.1 (数学归纳法原理)**
如果 $P$ 是自然数上的谓词，满足：
1. $P(0)$ 成立
2. $\forall n (P(n) \rightarrow P(n+1))$ 成立

则 $\forall n P(n)$ 成立。

### 4.3 自然演绎系统

**定义 4.3.1 (自然演绎)**
自然演绎系统是基于引入和消去规则的证明系统，强调推理的自然性和直观性。

**命题逻辑自然演绎规则**：

**合取规则**：
$$
\frac{A \quad B}{A \land B} \text{ (∧I)} \quad \frac{A \land B}{A} \text{ (∧E₁)} \quad \frac{A \land B}{B} \text{ (∧E₂)}
$$

**析取规则**：
$$
\frac{A}{A \lor B} \text{ (∨I₁)} \quad \frac{B}{A \lor B} \text{ (∨I₂)} \quad \frac{A \lor B \quad [A] \vdash C \quad [B] \vdash C}{C} \text{ (∨E)}
$$

**蕴含规则**：
$$
\frac{[A] \vdash B}{A \rightarrow B} \text{ (→I)} \quad \frac{A \rightarrow B \quad A}{B} \text{ (→E)}
$$

**否定规则**：
$$
\frac{[A] \vdash \bot}{\neg A} \text{ (¬I)} \quad \frac{A \quad \neg A}{\bot} \text{ (¬E)} \quad \frac{\bot}{A} \text{ (⊥E)}
$$

**谓词逻辑自然演绎规则**：

**全称量词规则**：
$$
\frac{\phi(x)}{\forall x \phi(x)} \text{ (∀I)} \quad \frac{\forall x \phi(x)}{\phi(t)} \text{ (∀E)}
$$

**存在量词规则**：
$$
\frac{\phi(t)}{\exists x \phi(x)} \text{ (∃I)} \quad \frac{\exists x \phi(x) \quad [\phi(x)] \vdash \psi}{\psi} \text{ (∃E)}
$$

### 4.4 序列演算

**定义 4.4.1 (相继式)**
相继式是形如 $\Gamma \vdash \Delta$ 的表达式，其中 $\Gamma, \Delta$ 是公式的有限集合。

**定义 4.4.2 (相继式的语义)**
相继式 $\Gamma \vdash \Delta$ 为真，当且仅当 $\bigwedge \Gamma \rightarrow \bigvee \Delta$ 为重言式。

**序列演算规则**：

**结构规则**：
$$
\frac{\Gamma \vdash \Delta}{\Gamma, A \vdash \Delta} \text{ (WL)} \quad \frac{\Gamma \vdash \Delta}{\Gamma \vdash \Delta, A} \text{ (WR)}
$$

**逻辑规则**：

**左规则**：
$$
\frac{\Gamma, A, B \vdash \Delta}{\Gamma, A \land B \vdash \Delta} \text{ (∧L)} \quad \frac{\Gamma, A \vdash \Delta \quad \Gamma, B \vdash \Delta}{\Gamma, A \lor B \vdash \Delta} \text{ (∨L)}
$$

$$
\frac{\Gamma \vdash A, \Delta \quad \Gamma, B \vdash \Delta}{\Gamma, A \rightarrow B \vdash \Delta} \text{ (→L)} \quad \frac{\Gamma \vdash \Delta}{\Gamma, \neg A \vdash \Delta} \text{ (¬L)}
$$

**右规则**：
$$
\frac{\Gamma \vdash A, \Delta \quad \Gamma \vdash B, \Delta}{\Gamma \vdash A \land B, \Delta} \text{ (∧R)} \quad \frac{\Gamma \vdash A, B, \Delta}{\Gamma \vdash A \lor B, \Delta} \text{ (∨R)}
$$

$$
\frac{\Gamma, A \vdash B, \Delta}{\Gamma \vdash A \rightarrow B, \Delta} \text{ (→R)} \quad \frac{\Gamma, A \vdash \Delta}{\Gamma \vdash \neg A, \Delta} \text{ (¬R)}
$$

**量词规则**：

**左规则**：
$$
\frac{\Gamma, \phi(t) \vdash \Delta}{\Gamma, \forall x \phi(x) \vdash \Delta} \text{ (∀L)} \quad \frac{\Gamma, \phi(x) \vdash \Delta}{\Gamma, \exists x \phi(x) \vdash \Delta} \text{ (∃L)}
$$

**右规则**：
$$
\frac{\Gamma \vdash \phi(x), \Delta}{\Gamma \vdash \forall x \phi(x), \Delta} \text{ (∀R)} \quad \frac{\Gamma \vdash \phi(t), \Delta}{\Gamma \vdash \exists x \phi(x), \Delta} \text{ (∃R)}
$$

### 4.5 证明策略

**策略 4.5.1 (直接证明)**
直接证明是通过逻辑推理直接从前提得到结论的方法。

**策略 4.5.2 (反证法)**
反证法是通过假设结论的否定，推导出矛盾来证明原结论的方法。

**反证法步骤**：
1. 假设 $\neg \phi$ 为真
2. 从 $\neg \phi$ 和已知条件推导出矛盾
3. 得出 $\phi$ 为真

**策略 4.5.3 (构造性证明)**
构造性证明是通过实际构造对象来证明存在性的方法。

**策略 4.5.4 (案例分析)**
案例分析是通过分析所有可能的情况来证明结论的方法。

### 4.6 证明的复杂性

**定义 4.6.1 (证明长度)**
证明的长度是证明中公式的数量。

**定义 4.6.2 (证明深度)**
证明的深度是证明树的最大高度。

**定理 4.6.1 (证明压缩)**
对于任何证明，都存在一个长度不超过原证明平方的证明。

**定义 4.6.3 (证明复杂性)**
证明的复杂性可以通过以下指标衡量：
- 证明长度
- 证明深度
- 使用的公理数量
- 推理规则的复杂度

### 4.7 自动定理证明

**定义 4.7.1 (自动定理证明)**
自动定理证明是使用计算机程序自动寻找数学定理证明的过程。

**算法 4.7.1 (归结法)**
归结法是自动定理证明的基本方法：

1. **转换为子句形式**：
   - 消去蕴含和等价
   - 将否定内移
   - 标准化变量
   - 转换为前束范式
   - 斯科伦化
   - 转换为合取范式

2. **归结推理**：
   - 选择两个子句
   - 找到互补文字
   - 应用归结规则
   - 得到新的子句

3. **终止条件**：
   - 得到空子句（证明完成）
   - 无法产生新的子句（证明失败）

**算法 4.7.2 (表方法)**
表方法是基于语义的证明方法：

1. 构造公式的语义表
2. 检查所有分支
3. 如果所有分支都关闭，则公式是重言式

### 4.8 证明验证

**定义 4.8.1 (证明验证)**
证明验证是检查证明正确性的过程。

**验证方法 4.8.1 (形式验证)**
形式验证是通过计算机程序检查证明的形式正确性。

**验证方法 4.8.2 (人工验证)**
人工验证是通过人工检查证明的逻辑正确性。

**定义 4.8.2 (证明助手)**
证明助手是帮助构造和验证证明的计算机程序。

### 4.9 证明理论的应用

**应用 4.9.1 (程序验证)**
证明理论在程序验证中的应用：
- 程序正确性证明
- 程序等价性证明
- 程序终止性证明

**应用 4.9.2 (人工智能)**
证明理论在人工智能中的应用：
- 自动推理系统
- 专家系统
- 知识表示

**应用 4.9.3 (数学教育)**
证明理论在数学教育中的应用：
- 证明技巧教学
- 逻辑思维训练
- 数学素养培养

### 4.10 证明理论的发展趋势

**趋势 4.10.1 (交互式证明)**
交互式证明系统结合人工指导和自动推理，提高证明效率。

**趋势 4.10.2 (机器学习辅助)**
机器学习技术用于：
- 证明策略选择
- 引理生成
- 证明模式识别

**趋势 4.10.3 (形式化数学)**
形式化数学的发展趋势：
- 数学库的构建
- 定理的机器验证
- 数学知识的数字化

## 5.0 模型论

### 5.1 模型论基础

**定义 5.1.1 (模型)**
语言 $\mathcal{L}$ 的模型 $\mathcal{M} = (M, I)$ 由以下部分组成：
- 非空集合 $M$（论域）
- 解释函数 $I$，将 $\mathcal{L}$ 的符号映射到 $M$ 上的对象

**定义 5.1.2 (解释函数)**
解释函数 $I$ 满足：
- 对每个常元 $c$，$I(c) \in M$
- 对每个 $n$ 元函数符号 $f$，$I(f): M^n \rightarrow M$
- 对每个 $n$ 元谓词符号 $P$，$I(P) \subseteq M^n$

**定义 5.1.3 (赋值)**
赋值是函数 $s: \text{Var} \rightarrow M$，将变量映射到论域元素。

**定义 5.1.4 (满足关系)**
满足关系 $\mathcal{M} \models \phi[s]$ 递归定义：
- $\mathcal{M} \models P(t_1, \ldots, t_n)[s] \Leftrightarrow (t_1^{\mathcal{M}}[s], \ldots, t_n^{\mathcal{M}}[s]) \in I(P)$
- $\mathcal{M} \models t_1 = t_2[s] \Leftrightarrow t_1^{\mathcal{M}}[s] = t_2^{\mathcal{M}}[s]$
- $\mathcal{M} \models \neg\phi[s] \Leftrightarrow \mathcal{M} \not\models \phi[s]$
- $\mathcal{M} \models \phi \land \psi[s] \Leftrightarrow \mathcal{M} \models \phi[s] \text{ 且 } \mathcal{M} \models \psi[s]$
- $\mathcal{M} \models \phi \lor \psi[s] \Leftrightarrow \mathcal{M} \models \phi[s] \text{ 或 } \mathcal{M} \models \psi[s]$
- $\mathcal{M} \models \phi \rightarrow \psi[s] \Leftrightarrow \mathcal{M} \not\models \phi[s] \text{ 或 } \mathcal{M} \models \psi[s]$
- $\mathcal{M} \models \forall x \phi[s] \Leftrightarrow \text{对所有 } a \in M, \mathcal{M} \models \phi[s(x|a)]$
- $\mathcal{M} \models \exists x \phi[s] \Leftrightarrow \text{存在 } a \in M, \mathcal{M} \models \phi[s(x|a)]$

### 5.2 真值与可满足性

**定义 5.2.1 (真值)**
公式 $\phi$ 在模型 $\mathcal{M}$ 中为真，记作 $\mathcal{M} \models \phi$，当且仅当对所有赋值 $s$，$\mathcal{M} \models \phi[s]$。

**定义 5.2.2 (可满足性)**
公式 $\phi$ 是可满足的，当且仅当存在模型 $\mathcal{M}$ 和赋值 $s$，使得 $\mathcal{M} \models \phi[s]$。

**定义 5.2.3 (逻辑有效性)**
公式 $\phi$ 是逻辑有效的，当且仅当对所有模型 $\mathcal{M}$ 和赋值 $s$，都有 $\mathcal{M} \models \phi[s]$。

**定义 5.2.4 (逻辑矛盾)**
公式 $\phi$ 是逻辑矛盾，当且仅当对所有模型 $\mathcal{M}$ 和赋值 $s$，都有 $\mathcal{M} \not\models \phi[s]$。

**定理 5.2.1 (真值等价性)**
- $\phi$ 是逻辑有效的 $\Leftrightarrow \neg\phi$ 是不可满足的
- $\phi$ 是可满足的 $\Leftrightarrow \neg\phi$ 不是逻辑有效的

### 5.3 理论模型

**定义 5.3.1 (理论)**
理论 $T$ 是句子的集合。

**定义 5.3.2 (模型)**
模型 $\mathcal{M}$ 是理论 $T$ 的模型，当且仅当对所有 $\phi \in T$，$\mathcal{M} \models \phi$。

**定义 5.3.3 (理论的可满足性)**
理论 $T$ 是可满足的，当且仅当存在 $T$ 的模型。

**定义 5.3.4 (理论的完全性)**
理论 $T$ 是完全的，当且仅当对每个句子 $\phi$，要么 $T \models \phi$，要么 $T \models \neg\phi$。

**定理 5.3.1 (紧致性定理)**
理论 $T$ 是可满足的，当且仅当 $T$ 的每个有限子集都是可满足的。

### 5.4 初等等价与初等嵌入

**定义 5.4.1 (初等等价)**
两个模型 $\mathcal{M}, \mathcal{N}$ 初等等价，记作 $\mathcal{M} \equiv \mathcal{N}$，当且仅当它们满足相同的句子。

**定义 5.4.2 (初等嵌入)**
函数 $f: M \rightarrow N$ 是初等嵌入，当且仅当对所有公式 $\phi(x_1, \ldots, x_n)$ 和 $a_1, \ldots, a_n \in M$：
$$\mathcal{M} \models \phi[a_1, \ldots, a_n] \Leftrightarrow \mathcal{N} \models \phi[f(a_1), \ldots, f(a_n)]$$

**定义 5.4.3 (初等子模型)**
模型 $\mathcal{M}$ 是 $\mathcal{N}$ 的初等子模型，当且仅当 $M \subseteq N$ 且包含映射是初等嵌入。

**定理 5.4.1 (初等嵌入的性质)**
如果 $f: \mathcal{M} \rightarrow \mathcal{N}$ 是初等嵌入，则：
- $f$ 是单射
- $f$ 保持所有可定义的集合和关系
- $\mathcal{M} \equiv \mathcal{N}$

### 5.5 勒文海姆-斯科伦定理

**定理 5.5.1 (向下勒文海姆-斯科伦定理)**
如果理论 $T$ 有无限模型，则对任意基数 $\kappa \geq |\mathcal{L}|$，$T$ 都有基数为 $\kappa$ 的模型。

**定理 5.5.2 (向上勒文海姆-斯科伦定理)**
如果理论 $T$ 有无限模型，则对任意基数 $\kappa \geq \max(|T|, |\mathcal{L}|)$，$T$ 都有基数为 $\kappa$ 的模型。

**推论 5.5.1 (范畴性)**
如果理论 $T$ 是 $\kappa$-范畴的（所有基数为 $\kappa$ 的模型都同构），则 $T$ 是完全的。

### 5.6 可定义性理论

**定义 5.6.1 (可定义集合)**
集合 $X \subseteq M^n$ 在模型 $\mathcal{M}$ 中可定义，当且仅当存在公式 $\phi(x_1, \ldots, x_n)$，使得：
$$X = \{(a_1, \ldots, a_n) \in M^n : \mathcal{M} \models \phi[a_1, \ldots, a_n]\}$$

**定义 5.6.2 (可定义函数)**
函数 $f: M^n \rightarrow M$ 在模型 $\mathcal{M}$ 中可定义，当且仅当存在公式 $\phi(x_1, \ldots, x_n, y)$，使得：
$$f(a_1, \ldots, a_n) = b \Leftrightarrow \mathcal{M} \models \phi[a_1, \ldots, a_n, b]$$

**定义 5.6.3 (可定义关系)**
关系 $R \subseteq M^n$ 在模型 $\mathcal{M}$ 中可定义，当且仅当存在公式 $\phi(x_1, \ldots, x_n)$，使得：
$$R = \{(a_1, \ldots, a_n) \in M^n : \mathcal{M} \models \phi[a_1, \ldots, a_n]\}$$

**定理 5.6.1 (可定义性的保持)**
如果 $f: \mathcal{M} \rightarrow \mathcal{N}$ 是初等嵌入，则：
- $\mathcal{M}$ 中的可定义集合在 $\mathcal{N}$ 中也可定义
- 可定义性在初等等价下保持不变

### 5.7 饱和模型

**定义 5.7.1 (类型)**
$n$ 型是公式集合 $p(x_1, \ldots, x_n)$，满足：
- 对有限子集 $\{\phi_1, \ldots, \phi_k\} \subseteq p$，存在模型 $\mathcal{M}$ 和元素 $a_1, \ldots, a_n \in M$，使得 $\mathcal{M} \models \phi_i[a_1, \ldots, a_n]$ 对所有 $i$

**定义 5.7.2 (类型的实现)**
类型 $p(x_1, \ldots, x_n)$ 在模型 $\mathcal{M}$ 中实现，当且仅当存在元素 $a_1, \ldots, a_n \in M$，使得对所有 $\phi \in p$，$\mathcal{M} \models \phi[a_1, \ldots, a_n]$。

**定义 5.7.3 (饱和模型)**
模型 $\mathcal{M}$ 是 $\kappa$-饱和的，当且仅当对所有基数 $\lambda < \kappa$ 和所有 $\lambda$-型 $p$，如果 $p$ 在 $\mathcal{M}$ 的某个初等扩展中实现，则 $p$ 在 $\mathcal{M}$ 中实现。

**定理 5.7.1 (饱和模型的性质)**
如果 $\mathcal{M}, \mathcal{N}$ 都是 $\kappa$-饱和的且 $|M|, |N| \leq \kappa$，则 $\mathcal{M} \equiv \mathcal{N}$ 当且仅当 $\mathcal{M} \cong \mathcal{N}$。

### 5.8 稳定性理论

**定义 5.8.1 (稳定性)**
理论 $T$ 是 $\lambda$-稳定的，当且仅当对每个模型 $\mathcal{M} \models T$ 和每个基数 $\kappa \leq \lambda$，$\mathcal{M}$ 中最多有 $\kappa$ 个不同的 $1$-型。

**定义 5.8.2 (超稳定性)**
理论 $T$ 是超稳定的，当且仅当对所有无限基数 $\lambda$，$T$ 都是 $\lambda$-稳定的。

**定义 5.8.3 ($\omega$-稳定性)**
理论 $T$ 是 $\omega$-稳定的，当且仅当 $T$ 是 $\aleph_0$-稳定的。

**定理 5.8.1 (稳定性与范畴性)**
如果理论 $T$ 是 $\omega$-稳定的，则 $T$ 在某个无限基数上是范畴的。

### 5.9 模型论的应用

**应用 5.9.1 (代数)**
模型论在代数中的应用：
- 域论
- 群论
- 环论
- 线性代数

**应用 5.9.2 (分析)**
模型论在分析中的应用：
- 实数理论
- 复数理论
- 函数论
- 测度论

**应用 5.9.3 (数论)**
模型论在数论中的应用：
- 代数数论
- 解析数论
- 算术几何
- 模型论数论

### 5.10 模型论的现代发展

**发展 5.10.1 (分类理论)**
分类理论是模型论的现代分支，研究理论的结构和分类。

**发展 5.10.2 (几何稳定性理论)**
几何稳定性理论结合几何和稳定性理论，研究代数几何中的模型论问题。

**发展 5.10.3 (模型论代数几何)**
模型论代数几何将模型论方法应用于代数几何，研究代数簇的模型论性质。

```rust
// 模型论的Rust实现
use std::collections::{HashMap, HashSet};

#[derive(Debug, Clone)]
pub struct Model {
    pub domain: Vec<String>,
    pub constants: HashMap<String, String>,
    pub functions: HashMap<String, Box<dyn Fn(&[String]) -> String>>,
    pub predicates: HashMap<String, Box<dyn Fn(&[String]) -> bool>>,
}

impl Model {
    pub fn new() -> Self {
        Self {
            domain: vec![],
            constants: HashMap::new(),
            functions: HashMap::new(),
            predicates: HashMap::new(),
        }
    }
    
    pub fn add_element(&mut self, element: &str) {
        if !self.domain.contains(&element.to_string()) {
            self.domain.push(element.to_string());
        }
    }
    
    pub fn add_constant(&mut self, name: &str, value: &str) {
        self.constants.insert(name.to_string(), value.to_string());
        self.add_element(value);
    }
    
    pub fn add_function<F>(&mut self, name: &str, func: F)
    where
        F: Fn(&[String]) -> String + 'static,
    {
        self.functions.insert(name.to_string(), Box::new(func));
    }
    
    pub fn add_predicate<F>(&mut self, name: &str, pred: F)
    where
        F: Fn(&[String]) -> bool + 'static,
    {
        self.predicates.insert(name.to_string(), Box::new(pred));
    }
    
    pub fn interpret_term(&self, term: &Term, assignment: &HashMap<String, String>) -> String {
        match term {
            Term::Variable(name) => assignment.get(name).unwrap_or(&"".to_string()).clone(),
            Term::Constant(name) => self.constants.get(name).unwrap_or(&"".to_string()).clone(),
            Term::Function(name, args) => {
                let arg_values: Vec<String> = args.iter()
                    .map(|arg| self.interpret_term(arg, assignment))
                    .collect();
                if let Some(func) = self.functions.get(name) {
                    func(&arg_values)
                } else {
                    "".to_string()
                }
            }
        }
    }
    
    pub fn satisfies(&self, formula: &Formula, assignment: &HashMap<String, String>) -> bool {
        match formula {
            Formula::Atom(name, args) => {
                let arg_values: Vec<String> = args.iter()
                    .map(|arg| self.interpret_term(arg, assignment))
                    .collect();
                if let Some(pred) = self.predicates.get(name) {
                    pred(&arg_values)
                } else {
                    false
                }
            }
            Formula::Equality(t1, t2) => {
                self.interpret_term(t1, assignment) == self.interpret_term(t2, assignment)
            }
            Formula::Not(f) => !self.satisfies(f, assignment),
            Formula::And(f1, f2) => {
                self.satisfies(f1, assignment) && self.satisfies(f2, assignment)
            }
            Formula::Or(f1, f2) => {
                self.satisfies(f1, assignment) || self.satisfies(f2, assignment)
            }
            Formula::Implies(f1, f2) => {
                !self.satisfies(f1, assignment) || self.satisfies(f2, assignment)
            }
            Formula::Iff(f1, f2) => {
                self.satisfies(f1, assignment) == self.satisfies(f2, assignment)
            }
            Formula::ForAll(var, f) => {
                self.domain.iter().all(|value| {
                    let mut new_assignment = assignment.clone();
                    new_assignment.insert(var.clone(), value.clone());
                    self.satisfies(f, &new_assignment)
                })
            }
            Formula::Exists(var, f) => {
                self.domain.iter().any(|value| {
                    let mut new_assignment = assignment.clone();
                    new_assignment.insert(var.clone(), value.clone());
                    self.satisfies(f, &new_assignment)
                })
            }
        }
    }
    
    pub fn is_model_of(&self, theory: &Theory) -> bool {
        theory.sentences.iter().all(|sentence| {
            let mut assignment = HashMap::new();
            self.satisfies(sentence, &assignment)
        })
    }
}

#[derive(Debug, Clone)]
pub struct Theory {
    pub sentences: Vec<Formula>,
}

impl Theory {
    pub fn new() -> Self {
        Self { sentences: vec![] }
    }
    
    pub fn add_sentence(&mut self, sentence: Formula) {
        self.sentences.push(sentence);
    }
    
    pub fn is_satisfiable(&self) -> bool {
        // 简化实现：检查是否存在模型
        // 实际实现需要更复杂的算法
        true
    }
    
    pub fn is_complete(&self) -> bool {
        // 简化实现：检查理论是否完全
        // 实际实现需要检查所有句子
        false
    }
}

// 初等等价检查
pub fn are_elementarily_equivalent(model1: &Model, model2: &Model) -> bool {
    // 简化实现：检查两个模型是否满足相同的句子
    // 实际实现需要更复杂的算法
    model1.domain.len() == model2.domain.len()
}

// 可定义性检查
pub fn is_definable_set(model: &Model, set: &HashSet<Vec<String>>, arity: usize) -> bool {
    // 简化实现：检查集合是否可定义
    // 实际实现需要构造定义公式
    true
}

// 示例：群论模型
fn group_model_example() {
    let mut group = Model::new();
    
    // 添加群元素
    group.add_element("e");
    group.add_element("a");
    group.add_element("b");
    group.add_element("c");
    
    // 单位元
    group.add_constant("e", "e");
    
    // 乘法运算
    group.add_function("mul", |args| {
        // 简化的群乘法表
        match (args[0].as_str(), args[1].as_str()) {
            ("e", x) | (x, "e") => x.to_string(),
            ("a", "a") => "e".to_string(),
            ("a", "b") => "c".to_string(),
            ("b", "a") => "c".to_string(),
            ("b", "b") => "e".to_string(),
            ("c", "c") => "e".to_string(),
            _ => "e".to_string(),
        }
    });
    
    // 群论公理
    let mut group_theory = Theory::new();
    
    // 结合律：∀x∀y∀z (mul(mul(x,y),z) = mul(x,mul(y,z)))
    let x = Term::Variable("x".to_string());
    let y = Term::Variable("y".to_string());
    let z = Term::Variable("z".to_string());
    
    let left = Term::Function("mul".to_string(), vec![
        Term::Function("mul".to_string(), vec![x.clone(), y.clone()]),
        z.clone()
    ]);
    let right = Term::Function("mul".to_string(), vec![
        x.clone(),
        Term::Function("mul".to_string(), vec![y.clone(), z.clone()])
    ]);
    
    let associativity = Formula::ForAll("x".to_string(), Box::new(
        Formula::ForAll("y".to_string(), Box::new(
            Formula::ForAll("z".to_string(), Box::new(
                Formula::Equality(left, right)
            ))
        ))
    ));
    
    group_theory.add_sentence(associativity);
    
    // 检查模型是否满足理论
    println!("群模型满足群论公理: {}", group.is_model_of(&group_theory));
}

// 类型系统
#[derive(Debug, Clone)]
pub struct Type {
    pub formulas: Vec<Formula>,
    pub variables: Vec<String>,
}

impl Type {
    pub fn new(variables: Vec<String>) -> Self {
        Self {
            formulas: vec![],
            variables,
        }
    }
    
    pub fn add_formula(&mut self, formula: Formula) {
        self.formulas.push(formula);
    }
    
    pub fn is_consistent(&self) -> bool {
        // 简化实现：检查类型是否一致
        // 实际实现需要检查有限子集的可满足性
        true
    }
    
    pub fn is_realized_in(&self, model: &Model) -> bool {
        // 简化实现：检查类型是否在模型中实现
        // 实际实现需要找到满足所有公式的元素
        true
    }
}

// 饱和模型检查
pub fn is_saturated(model: &Model, cardinality: usize) -> bool {
    // 简化实现：检查模型是否饱和
    // 实际实现需要检查所有类型的实现
    model.domain.len() >= cardinality
}
```

### 5.11 模型论的未来方向

**方向 5.11.1 (计算模型论)**
计算模型论研究模型论问题的计算复杂性和算法。

**方向 5.11.2 (几何模型论)**
几何模型论将几何方法应用于模型论，研究代数几何中的模型论问题。

**方向 5.11.3 (模型论组合学)**
模型论组合学将组合学方法应用于模型论，研究有限模型论和组合结构。

## 6.0 递归论

### 6.1 可计算性基础

**定义 6.1.1 (可计算函数)**
函数 $f: \mathbb{N}^n \rightarrow \mathbb{N}$ 是可计算的，当且仅当存在算法（有效过程）来计算 $f$ 的值。

**定义 6.1.2 (部分可计算函数)**
函数 $f: \mathbb{N}^n \rightharpoonup \mathbb{N}$ 是部分可计算的，当且仅当存在算法，当 $f(x_1, \ldots, x_n)$ 有定义时计算其值，否则不终止。

**定义 6.1.3 (可判定集合)**
集合 $A \subseteq \mathbb{N}^n$ 是可判定的，当且仅当其特征函数 $\chi_A$ 是可计算的。

**定义 6.1.4 (可枚举集合)**
集合 $A \subseteq \mathbb{N}^n$ 是可枚举的，当且仅当存在可计算函数 $f: \mathbb{N} \rightarrow \mathbb{N}^n$，使得 $A = \text{range}(f)$。

### 6.2 递归函数

**定义 6.2.1 (基本递归函数)**
基本递归函数包括：
- **零函数**：$Z(x) = 0$
- **后继函数**：$S(x) = x + 1$
- **投影函数**：$P_i^n(x_1, \ldots, x_n) = x_i$

**定义 6.2.2 (复合)**
如果 $g: \mathbb{N}^m \rightarrow \mathbb{N}$ 和 $h_1, \ldots, h_m: \mathbb{N}^n \rightarrow \mathbb{N}$ 都是递归函数，则复合函数 $f: \mathbb{N}^n \rightarrow \mathbb{N}$ 定义为：
$$f(x_1, \ldots, x_n) = g(h_1(x_1, \ldots, x_n), \ldots, h_m(x_1, \ldots, x_n))$$

**定义 6.2.3 (原始递归)**
如果 $g: \mathbb{N}^n \rightarrow \mathbb{N}$ 和 $h: \mathbb{N}^{n+2} \rightarrow \mathbb{N}$ 都是递归函数，则原始递归函数 $f: \mathbb{N}^{n+1} \rightarrow \mathbb{N}$ 定义为：
$$f(0, x_1, \ldots, x_n) = g(x_1, \ldots, x_n)$$
$$f(y+1, x_1, \ldots, x_n) = h(y, f(y, x_1, \ldots, x_n), x_1, \ldots, x_n)$$

**定义 6.2.4 (μ-递归)**
如果 $g: \mathbb{N}^{n+1} \rightarrow \mathbb{N}$ 是递归函数，则 μ-递归函数 $f: \mathbb{N}^n \rightarrow \mathbb{N}$ 定义为：
$$f(x_1, \ldots, x_n) = \mu y[g(y, x_1, \ldots, x_n) = 0]$$
其中 $\mu y$ 表示最小的 $y$ 使得 $g(y, x_1, \ldots, x_n) = 0$。

**定理 6.2.1 (递归函数类)**
递归函数类是包含基本函数且在复合、原始递归和μ-递归下封闭的最小函数类。

### 6.3 图灵机

**定义 6.3.1 (图灵机)**
图灵机 $M = (Q, \Sigma, \Gamma, \delta, q_0, q_{\text{accept}}, q_{\text{reject}})$ 由以下部分组成：
- $Q$：有限状态集
- $\Sigma$：输入字母表
- $\Gamma$：磁带字母表（$\Sigma \subseteq \Gamma$）
- $\delta: Q \times \Gamma \rightarrow Q \times \Gamma \times \{L, R\}$：转移函数
- $q_0 \in Q$：初始状态
- $q_{\text{accept}} \in Q$：接受状态
- $q_{\text{reject}} \in Q$：拒绝状态

**定义 6.3.2 (图灵机配置)**
图灵机的配置是三元组 $(q, w, i)$，其中：
- $q \in Q$：当前状态
- $w \in \Gamma^*$：磁带内容
- $i \in \mathbb{N}$：读写头位置

**定义 6.3.3 (图灵机计算)**
图灵机 $M$ 在输入 $x$ 上的计算是配置序列 $C_0, C_1, C_2, \ldots$，其中：
- $C_0 = (q_0, x, 0)$
- $C_{i+1}$ 由 $C_i$ 根据转移函数 $\delta$ 得到

**定义 6.3.4 (图灵可计算性)**
函数 $f: \mathbb{N}^n \rightarrow \mathbb{N}$ 是图灵可计算的，当且仅当存在图灵机 $M$，使得对任意输入 $(x_1, \ldots, x_n)$，$M$ 输出 $f(x_1, \ldots, x_n)$。

### 6.4 丘奇-图灵论题

**论题 6.4.1 (丘奇-图灵论题)**
所有可计算函数都是图灵可计算的。

**等价形式**：
- 所有算法可计算的函数都是图灵可计算的
- 所有有效可计算的函数都是图灵可计算的
- 所有机械可计算的函数都是图灵可计算的

**支持证据**：
1. 所有已知的计算模型都与图灵机等价
2. 图灵机能够模拟所有已知的计算过程
3. 没有发现图灵机无法计算的可计算函数

### 6.5 通用图灵机

**定义 6.5.1 (通用图灵机)**
通用图灵机 $U$ 是能够模拟任意图灵机的图灵机。

**定理 6.5.1 (通用图灵机存在性)**
存在通用图灵机 $U$，使得对任意图灵机 $M$ 和输入 $x$：
$$U(\langle M \rangle, x) = M(x)$$
其中 $\langle M \rangle$ 是图灵机 $M$ 的编码。

**构造方法**：
1. 将图灵机编码为字符串
2. 设计能够解释和执行编码的通用图灵机
3. 通用图灵机模拟被编码图灵机的行为

### 6.6 停机问题

**问题 6.6.1 (停机问题)**
给定图灵机 $M$ 和输入 $x$，判断 $M$ 在输入 $x$ 上是否停机。

**定理 6.6.1 (停机问题不可判定)**
停机问题是不可判定的，即不存在图灵机能够解决停机问题。

**证明**：
1. 假设存在图灵机 $H$ 能够解决停机问题
2. 构造图灵机 $D$，使得 $D(\langle M \rangle) = \text{not } H(\langle M \rangle, \langle M \rangle)$
3. 考虑 $D(\langle D \rangle)$ 的情况，得到矛盾

**推论 6.6.1 (其他不可判定问题)**
以下问题都是不可判定的：
- 空性问题：判断图灵机是否接受空语言
- 等价性问题：判断两个图灵机是否等价
- 完全性问题：判断图灵机是否接受所有输入

### 6.7 递归可枚举集

**定义 6.7.1 (递归可枚举集)**
集合 $A \subseteq \mathbb{N}^n$ 是递归可枚举的，当且仅当存在图灵机 $M$，使得 $A = L(M)$。

**定理 6.7.1 (递归可枚举集的性质)**
1. 可判定集是递归可枚举的
2. 递归可枚举集在并集和交集下封闭
3. 递归可枚举集在投影下封闭

**定理 6.7.2 (递归可枚举集的判定)**
集合 $A$ 是可判定的，当且仅当 $A$ 和 $\overline{A}$ 都是递归可枚举的。

### 6.8 哥德尔不完备性定理

**定理 6.8.1 (第一不完备性定理)**
任何包含算术的一致形式系统都是不完备的，即存在真但不可证的句子。

**证明思路**：
1. 构造自指句子 $G$："$G$ 不可证"
2. 如果 $G$ 可证，则 $G$ 为假，系统不一致
3. 如果 $G$ 不可证，则 $G$ 为真，但不可证

**定理 6.8.2 (第二不完备性定理)**
任何包含算术的一致形式系统都无法证明自身的一致性。

**证明思路**：
1. 将一致性陈述形式化
2. 证明一致性陈述等价于 $G$ 的不可证性
3. 如果系统能证明自身一致性，则能证明 $G$，矛盾

**推论 6.8.1 (形式系统的局限性)**
1. 任何足够强的形式系统都无法证明所有真命题
2. 任何足够强的形式系统都无法证明自身的一致性
3. 数学真理不能完全形式化

### 6.9 计算复杂性

**定义 6.9.1 (时间复杂度)**
图灵机 $M$ 在输入 $x$ 上的时间复杂度是 $M$ 在 $x$ 上计算的步数。

**定义 6.9.2 (空间复杂度)**
图灵机 $M$ 在输入 $x$ 上的空间复杂度是 $M$ 在 $x$ 上使用的磁带格子数。

**定义 6.9.3 (复杂性类)**
- **P**：多项式时间可判定的问题
- **NP**：非确定性多项式时间可判定的问题
- **PSPACE**：多项式空间可判定的问题
- **EXPTIME**：指数时间可判定的问题

**问题 6.9.1 (P vs NP问题)**
P = NP 是否成立？

**重要性**：
- 如果 P = NP，则许多困难问题都有高效算法
- 如果 P ≠ NP，则某些问题本质上是困难的
- 这是计算机科学中最重要的未解决问题之一

### 6.10 递归论的应用

**应用 6.10.1 (计算机科学)**
递归论在计算机科学中的应用：
- 算法设计
- 程序验证
- 编译器理论
- 人工智能

**应用 6.10.2 (数学基础)**
递归论在数学基础中的应用：
- 集合论
- 数论
- 代数
- 分析

**应用 6.10.3 (哲学)**
递归论在哲学中的应用：
- 心灵哲学
- 认识论
- 形而上学
- 科学哲学

### 6.11 递归论的现代发展

**发展 6.11.1 (计算理论)**
现代计算理论的发展：
- 量子计算
- 生物计算
- 神经网络计算
- 并行计算

**发展 6.11.2 (复杂性理论)**
复杂性理论的发展：
- 平均复杂性
- 参数化复杂性
- 近似算法
- 随机算法

**发展 6.11.3 (可计算性理论)**
可计算性理论的发展：
- 相对可计算性
- 可计算分析
- 可计算代数
- 可计算几何

## 7.0 数学逻辑与计算

### 7.1 逻辑与计算理论

**定义 7.1.1 (计算逻辑)**
计算逻辑是研究逻辑系统计算性质的数学分支，包括可判定性、复杂性、算法等。

**定义 7.1.2 (逻辑系统)**
逻辑系统 $\mathcal{L} = (\mathcal{S}, \mathcal{A}, \mathcal{R}, \mathcal{I})$ 由以下部分组成：
- $\mathcal{S}$：语法系统
- $\mathcal{A}$：公理系统
- $\mathcal{R}$：推理规则
- $\mathcal{I}$：解释系统

**定义 7.1.3 (逻辑计算)**
逻辑计算是在逻辑系统中进行的符号操作和推理过程。

**定理 7.1.1 (逻辑与计算的对应)**
每个逻辑系统都对应一个计算模型，每个计算模型都可以用逻辑系统描述。

### 7.2 自动机理论

**定义 7.2.1 (有限自动机)**
有限自动机 $M = (Q, \Sigma, \delta, q_0, F)$ 由以下部分组成：
- $Q$：有限状态集
- $\Sigma$：输入字母表
- $\delta: Q \times \Sigma \rightarrow Q$：转移函数
- $q_0 \in Q$：初始状态
- $F \subseteq Q$：接受状态集

**定义 7.2.2 (下推自动机)**
下推自动机 $M = (Q, \Sigma, \Gamma, \delta, q_0, Z_0, F)$ 由以下部分组成：
- $Q$：有限状态集
- $\Sigma$：输入字母表
- $\Gamma$：栈字母表
- $\delta: Q \times \Sigma \times \Gamma \rightarrow \mathcal{P}(Q \times \Gamma^*)$：转移函数
- $q_0 \in Q$：初始状态
- $Z_0 \in \Gamma$：初始栈符号
- $F \subseteq Q$：接受状态集

**定义 7.2.3 (线性有界自动机)**
线性有界自动机是图灵机的受限版本，读写头只能在输入字符串的范围内移动。

**定理 7.2.1 (自动机层次)**
1. 有限自动机识别正则语言
2. 下推自动机识别上下文无关语言
3. 线性有界自动机识别上下文相关语言
4. 图灵机识别递归可枚举语言

### 7.3 形式语言理论

**定义 7.3.1 (形式语言)**
形式语言是字母表 $\Sigma$ 上字符串的集合 $L \subseteq \Sigma^*$。

**定义 7.3.2 (乔姆斯基层次)**
乔姆斯基层次包括：
- **类型0**：递归可枚举语言
- **类型1**：上下文相关语言
- **类型2**：上下文无关语言
- **类型3**：正则语言

**定义 7.3.3 (语法)**
语法 $G = (V, T, P, S)$ 由以下部分组成：
- $V$：非终结符集合
- $T$：终结符集合
- $P$：产生式规则集合
- $S \in V$：起始符号

**定理 7.3.1 (语法与自动机的对应)**
1. 正则语法对应有限自动机
2. 上下文无关语法对应下推自动机
3. 上下文相关语法对应线性有界自动机
4. 无限制语法对应图灵机

### 7.4 可判定性理论

**定义 7.4.1 (可判定问题)**
问题 $P$ 是可判定的，当且仅当存在算法能够解决 $P$。

**定义 7.4.2 (半可判定问题)**
问题 $P$ 是半可判定的，当且仅当存在算法，当答案为"是"时能够给出答案，当答案为"否"时可能不终止。

**定理 7.4.1 (可判定性问题)**
以下问题是可判定的：
- 有限自动机的等价性
- 上下文无关语法的空性问题
- 命题逻辑的可满足性

**定理 7.4.2 (不可判定性问题)**
以下问题是不可判定的：
- 图灵机的停机问题
- 上下文无关语法的歧义性
- 一阶逻辑的有效性

### 7.5 计算复杂性

**定义 7.5.1 (时间复杂度)**
算法的时间复杂度是算法执行所需的时间与输入大小的关系。

**定义 7.5.2 (空间复杂度)**
算法的空间复杂度是算法执行所需的存储空间与输入大小的关系。

**定义 7.5.3 (复杂性类)**
- **DTIME(f(n))**：确定性图灵机在时间 $O(f(n))$ 内可判定的问题
- **NTIME(f(n))**：非确定性图灵机在时间 $O(f(n))$ 内可判定的问题
- **DSPACE(f(n))**：确定性图灵机在空间 $O(f(n))$ 内可判定的问题
- **NSPACE(f(n))**：非确定性图灵机在空间 $O(f(n))$ 内可判定的问题

**定理 7.5.1 (复杂性类关系)**
1. $P = \bigcup_{k \geq 0} \text{DTIME}(n^k)$
2. $NP = \bigcup_{k \geq 0} \text{NTIME}(n^k)$
3. $PSPACE = \bigcup_{k \geq 0} \text{DSPACE}(n^k)$
4. $P \subseteq NP \subseteq PSPACE \subseteq EXPTIME$

### 7.6 逻辑编程

**定义 7.6.1 (逻辑程序)**
逻辑程序是形如 $A \leftarrow B_1, \ldots, B_n$ 的规则集合，其中 $A$ 是原子，$B_i$ 是原子或否定原子。

**定义 7.6.2 (Horn子句)**
Horn子句是至多包含一个正文字的析取式。

**定义 7.6.3 (SLD归结)**
SLD归结是逻辑编程中的推理规则：
$$\frac{A \leftarrow B_1, \ldots, B_n \quad B_i \leftarrow C_1, \ldots, C_m}{A \leftarrow B_1, \ldots, B_{i-1}, C_1, \ldots, C_m, B_{i+1}, \ldots, B_n}$$

**定理 7.6.1 (逻辑编程的完备性)**
SLD归结对于Horn子句程序是完备的。

### 7.7 约束满足问题

**定义 7.7.1 (约束满足问题)**
约束满足问题 $(X, D, C)$ 由以下部分组成：
- $X = \{x_1, \ldots, x_n\}$：变量集合
- $D = \{D_1, \ldots, D_n\}$：域集合
- $C = \{C_1, \ldots, C_m\}$：约束集合

**定义 7.7.2 (约束)**
约束 $C_i$ 是变量子集上的关系，限制这些变量的取值。

**定义 7.7.3 (解)**
解是满足所有约束的变量赋值。

**算法 7.7.1 (回溯搜索)**
1. 选择未赋值的变量
2. 尝试为该变量赋值
3. 检查约束一致性
4. 如果不一致，回溯到上一步
5. 如果所有变量都已赋值，找到解

### 7.8 模型检测

**定义 7.8.1 (模型检测)**
模型检测是自动验证系统是否满足规范的技术。

**定义 7.8.2 (时态逻辑)**
时态逻辑是描述系统行为随时间变化的逻辑。

**定义 7.8.3 (CTL)**
计算树逻辑（CTL）的语法：
- 原子命题：$p \in AP$
- 逻辑连接词：$\neg, \land, \lor, \rightarrow$
- 时态算子：$AX, EX, AG, EG, AF, EF, AU, EU$

**算法 7.8.1 (模型检测算法)**
1. 构造系统的状态转换图
2. 将规范转换为自动机
3. 计算状态转换图和自动机的乘积
4. 检查是否接受空语言

### 7.9 程序验证

**定义 7.9.1 (程序验证)**
程序验证是证明程序满足规范的过程。

**定义 7.9.2 (霍尔逻辑)**
霍尔逻辑用于程序验证的三元组 $\{P\} C \{Q\}$：
- $P$：前置条件
- $C$：程序
- $Q$：后置条件

**定义 7.9.3 (最弱前置条件)**
最弱前置条件 $wp(C, Q)$ 是使得执行 $C$ 后满足 $Q$ 的最弱条件。

**定理 7.9.1 (霍尔逻辑规则)**
1. **赋值规则**：$\{P[E/x]\} x := E \{P\}$
2. **序列规则**：$\frac{\{P\} C_1 \{R\} \quad \{R\} C_2 \{Q\}}{\{P\} C_1; C_2 \{Q\}}$
3. **条件规则**：$\frac{\{P \land B\} C_1 \{Q\} \quad \{P \land \neg B\} C_2 \{Q\}}{\{P\} \text{if } B \text{ then } C_1 \text{ else } C_2 \{Q\}}$
4. **循环规则**：$\frac{\{P \land B\} C \{P\}}{\{P\} \text{while } B \text{ do } C \{P \land \neg B\}}$

### 7.10 类型系统

**定义 7.10.1 (类型系统)**
类型系统是程序语言中用于类型检查和类型推断的规则集合。

**定义 7.10.2 (简单类型)**
简单类型包括：
- 基本类型：$int, bool, char, unit$
- 函数类型：$A \rightarrow B$
- 积类型：$A \times B$
- 和类型：$A + B$

**定义 7.10.3 (多态类型)**
多态类型允许类型变量，如 $\forall \alpha. \alpha \rightarrow \alpha$。

**定理 7.10.1 (类型安全)**
类型安全的程序不会在运行时出现类型错误。

### 7.11 逻辑与人工智能

**应用 7.11.1 (知识表示)**
逻辑在人工智能中的应用：
- 谓词逻辑表示知识
- 描述逻辑表示概念
- 模态逻辑表示信念和知识

**应用 7.11.2 (推理系统)**
逻辑推理系统：
- 前向推理
- 后向推理
- 混合推理

**应用 7.11.3 (专家系统)**
专家系统基于逻辑规则：
- 知识库
- 推理引擎
- 用户界面

```rust
// 数学逻辑与计算的Rust实现
use std::collections::{HashMap, HashSet};

// 有限自动机
#[derive(Debug, Clone)]
pub struct FiniteAutomaton {
    pub states: HashSet<String>,
    pub alphabet: HashSet<char>,
    pub transitions: HashMap<(String, char), String>,
    pub initial_state: String,
    pub accept_states: HashSet<String>,
}

impl FiniteAutomaton {
    pub fn new() -> Self {
        Self {
            states: HashSet::new(),
            alphabet: HashSet::new(),
            transitions: HashMap::new(),
            initial_state: "".to_string(),
            accept_states: HashSet::new(),
        }
    }
    
    pub fn add_state(&mut self, state: &str) {
        self.states.insert(state.to_string());
    }
    
    pub fn add_transition(&mut self, from: &str, symbol: char, to: &str) {
        self.transitions.insert((from.to_string(), symbol), to.to_string());
        self.alphabet.insert(symbol);
    }
    
    pub fn accept(&self, input: &str) -> bool {
        let mut current_state = self.initial_state.clone();
        
        for symbol in input.chars() {
            if let Some(next_state) = self.transitions.get(&(current_state.clone(), symbol)) {
                current_state = next_state.clone();
            } else {
                return false;
            }
        }
        
        self.accept_states.contains(&current_state)
    }
}

// 下推自动机
#[derive(Debug, Clone)]
pub struct PushdownAutomaton {
    pub states: HashSet<String>,
    pub input_alphabet: HashSet<char>,
    pub stack_alphabet: HashSet<char>,
    pub transitions: HashMap<(String, char, char), Vec<(String, String)>>,
    pub initial_state: String,
    pub initial_stack: char,
    pub accept_states: HashSet<String>,
}

impl PushdownAutomaton {
    pub fn new() -> Self {
        Self {
            states: HashSet::new(),
            input_alphabet: HashSet::new(),
            stack_alphabet: HashSet::new(),
            transitions: HashMap::new(),
            initial_state: "".to_string(),
            initial_stack: 'Z',
            accept_states: HashSet::new(),
        }
    }
    
    pub fn add_transition(&mut self, from: &str, input: char, stack_top: char, 
                         to: &str, stack_push: &str) {
        let key = (from.to_string(), input, stack_top);
        let value = (to.to_string(), stack_push.to_string());
        
        self.transitions.entry(key).or_insert_with(Vec::new).push(value);
    }
    
    pub fn accept(&self, input: &str) -> bool {
        let mut configurations = vec![(self.initial_state.clone(), input.to_string(), vec![self.initial_stack])];
        
        while !configurations.is_empty() {
            let mut new_configurations = vec![];
            
            for (state, remaining_input, stack) in configurations {
                if remaining_input.is_empty() && self.accept_states.contains(&state) {
                    return true;
                }
                
                let input_symbol = remaining_input.chars().next().unwrap_or('\0');
                let stack_top = stack.last().unwrap_or(&'Z');
                
                if let Some(transitions) = self.transitions.get(&(state.clone(), input_symbol, *stack_top)) {
                    for (next_state, stack_push) in transitions {
                        let mut new_stack = stack.clone();
                        new_stack.pop(); // 移除栈顶
                        
                        // 压入新符号（从右到左）
                        for symbol in stack_push.chars().rev() {
                            new_stack.push(symbol);
                        }
                        
                        let new_remaining = if input_symbol != '\0' {
                            remaining_input[1..].to_string()
                        } else {
                            remaining_input.clone()
                        };
                        
                        new_configurations.push((next_state.clone(), new_remaining, new_stack));
                    }
                }
            }
            
            configurations = new_configurations;
        }
        
        false
    }
}

// 约束满足问题
#[derive(Debug, Clone)]
pub struct ConstraintSatisfactionProblem {
    pub variables: Vec<String>,
    pub domains: HashMap<String, Vec<i32>>,
    pub constraints: Vec<Constraint>,
}

#[derive(Debug, Clone)]
pub struct Constraint {
    pub variables: Vec<String>,
    pub relation: Box<dyn Fn(&[i32]) -> bool>,
}

impl ConstraintSatisfactionProblem {
    pub fn new() -> Self {
        Self {
            variables: vec![],
            domains: HashMap::new(),
            constraints: vec![],
        }
    }
    
    pub fn add_variable(&mut self, name: &str, domain: Vec<i32>) {
        self.variables.push(name.to_string());
        self.domains.insert(name.to_string(), domain);
    }
    
    pub fn add_constraint<F>(&mut self, variables: Vec<String>, relation: F)
    where
        F: Fn(&[i32]) -> bool + 'static,
    {
        self.constraints.push(Constraint {
            variables,
            relation: Box::new(relation),
        });
    }
    
    pub fn solve(&self) -> Option<HashMap<String, i32>> {
        let mut assignment = HashMap::new();
        self.backtrack_search(&mut assignment)
    }
    
    fn backtrack_search(&self, assignment: &mut HashMap<String, i32>) -> Option<HashMap<String, i32>> {
        if assignment.len() == self.variables.len() {
            return Some(assignment.clone());
        }
        
        let unassigned = self.variables.iter()
            .find(|v| !assignment.contains_key(*v))
            .unwrap();
        
        for &value in &self.domains[unassigned] {
            assignment.insert(unassigned.clone(), value);
            
            if self.is_consistent(assignment) {
                if let Some(solution) = self.backtrack_search(assignment) {
                    return Some(solution);
                }
            }
            
            assignment.remove(unassigned);
        }
        
        None
    }
    
    fn is_consistent(&self, assignment: &HashMap<String, i32>) -> bool {
        for constraint in &self.constraints {
            let values: Vec<i32> = constraint.variables.iter()
                .map(|v| assignment.get(v).unwrap_or(&0))
                .cloned()
                .collect();
            
            if !(constraint.relation)(&values) {
                return false;
            }
        }
        true
    }
}

// 霍尔逻辑验证器
#[derive(Debug, Clone)]
pub struct HoareLogic {
    pub rules: Vec<HoareRule>,
}

#[derive(Debug, Clone)]
pub struct HoareRule {
    pub precondition: String,
    pub program: String,
    pub postcondition: String,
}

impl HoareLogic {
    pub fn new() -> Self {
        Self { rules: vec![] }
    }
    
    pub fn add_rule(&mut self, precondition: &str, program: &str, postcondition: &str) {
        self.rules.push(HoareRule {
            precondition: precondition.to_string(),
            program: program.to_string(),
            postcondition: postcondition.to_string(),
        });
    }
    
    pub fn verify_assignment(&self, variable: &str, expression: &str, postcondition: &str) -> String {
        // 计算最弱前置条件
        postcondition.replace(variable, expression)
    }
    
    pub fn verify_sequence(&self, precondition: &str, program1: &str, program2: &str, postcondition: &str) -> bool {
        // 简化实现：检查序列规则
        // 实际实现需要更复杂的推理
        true
    }
    
    pub fn verify_conditional(&self, precondition: &str, condition: &str, 
                            then_program: &str, else_program: &str, postcondition: &str) -> bool {
        // 简化实现：检查条件规则
        true
    }
}

// 类型系统
#[derive(Debug, Clone, PartialEq)]
pub enum Type {
    Basic(String),
    Function(Box<Type>, Box<Type>),
    Product(Box<Type>, Box<Type>),
    Sum(Box<Type>, Box<Type>),
    Variable(String),
    ForAll(String, Box<Type>),
}

impl Type {
    pub fn is_basic(&self) -> bool {
        matches!(self, Type::Basic(_))
    }
    
    pub fn is_function(&self) -> bool {
        matches!(self, Type::Function(_, _))
    }
    
    pub fn substitute(&self, var: &str, replacement: &Type) -> Type {
        match self {
            Type::Variable(v) if v == var => replacement.clone(),
            Type::Variable(_) => self.clone(),
            Type::Basic(_) => self.clone(),
            Type::Function(t1, t2) => Type::Function(
                Box::new(t1.substitute(var, replacement)),
                Box::new(t2.substitute(var, replacement))
            ),
            Type::Product(t1, t2) => Type::Product(
                Box::new(t1.substitute(var, replacement)),
                Box::new(t2.substitute(var, replacement))
            ),
            Type::Sum(t1, t2) => Type::Sum(
                Box::new(t1.substitute(var, replacement)),
                Box::new(t2.substitute(var, replacement))
            ),
            Type::ForAll(v, t) if v == var => self.clone(),
            Type::ForAll(v, t) => Type::ForAll(v.clone(), Box::new(t.substitute(var, replacement))),
        }
    }
}

// 类型检查器
pub struct TypeChecker {
    pub environment: HashMap<String, Type>,
}

impl TypeChecker {
    pub fn new() -> Self {
        Self {
            environment: HashMap::new(),
        }
    }
    
    pub fn add_binding(&mut self, name: &str, typ: Type) {
        self.environment.insert(name.to_string(), typ);
    }
    
    pub fn type_check(&self, expression: &str) -> Option<Type> {
        // 简化实现：基本的类型检查
        // 实际实现需要解析表达式并递归检查
        match expression {
            "true" | "false" => Some(Type::Basic("bool".to_string())),
            _ if expression.parse::<i32>().is_ok() => Some(Type::Basic("int".to_string())),
            _ => self.environment.get(expression).cloned(),
        }
    }
}

// 示例：有限自动机识别偶数个a的字符串
fn finite_automaton_example() {
    let mut fa = FiniteAutomaton::new();
    
    fa.add_state("q0");
    fa.add_state("q1");
    
    fa.initial_state = "q0".to_string();
    fa.accept_states.insert("q0".to_string());
    
    fa.add_transition("q0", 'a', "q1");
    fa.add_transition("q0", 'b', "q0");
    fa.add_transition("q1", 'a', "q0");
    fa.add_transition("q1", 'b', "q1");
    
    println!("'aab' 被接受: {}", fa.accept("aab"));
    println!("'aaa' 被接受: {}", fa.accept("aaa"));
}

// 示例：约束满足问题（数独简化版）
fn csp_example() {
    let mut csp = ConstraintSatisfactionProblem::new();
    
    csp.add_variable("x", vec![1, 2, 3]);
    csp.add_variable("y", vec![1, 2, 3]);
    csp.add_variable("z", vec![1, 2, 3]);
    
    // 约束：x != y, y != z, x != z
    csp.add_constraint(vec!["x".to_string(), "y".to_string()], |values| values[0] != values[1]);
    csp.add_constraint(vec!["y".to_string(), "z".to_string()], |values| values[0] != values[1]);
    csp.add_constraint(vec!["x".to_string(), "z".to_string()], |values| values[0] != values[1]);
    
    if let Some(solution) = csp.solve() {
        println!("CSP解: {:?}", solution);
    } else {
        println!("CSP无解");
    }
}

// 示例：霍尔逻辑验证
fn hoare_logic_example() {
    let mut hoare = HoareLogic::new();
    
    // 验证赋值语句 {x > 0} x := x + 1 {x > 1}
    let wp = hoare.verify_assignment("x", "x + 1", "x > 1");
    println!("最弱前置条件: {}", wp);
    
    // 验证序列 {x > 0} x := x + 1; y := x * 2 {y > 2}
    let valid = hoare.verify_sequence("x > 0", "x := x + 1", "y := x * 2", "y > 2");
    println!("序列验证: {}", valid);
}

// 示例：类型检查
fn type_checking_example() {
    let mut checker = TypeChecker::new();
    
    checker.add_binding("x", Type::Basic("int".to_string()));
    checker.add_binding("f", Type::Function(
        Box::new(Type::Basic("int".to_string())),
        Box::new(Type::Basic("bool".to_string()))
    ));
    
    println!("x 的类型: {:?}", checker.type_check("x"));
    println!("f 的类型: {:?}", checker.type_check("f"));
    println!("42 的类型: {:?}", checker.type_check("42"));
    println!("true 的类型: {:?}", checker.type_check("true"));
}
```

### 7.12 逻辑与计算的未来发展

**发展 7.12.1 (量子逻辑)**
量子逻辑将量子力学原理应用于逻辑系统，研究量子计算中的逻辑问题。

**发展 7.12.2 (模糊逻辑)**
模糊逻辑处理不确定性和模糊性，在人工智能和控制系统中广泛应用。

**发展 7.12.3 (概率逻辑)**
概率逻辑将概率论与逻辑结合，处理不确定推理和机器学习中的逻辑问题。

## 8.0 逻辑与数学基础

### 8.1 逻辑与集合论

**定义 8.1.1 (集合论基础)**
集合论是数学的基础理论，研究集合及其性质，为其他数学分支提供基础。

**定义 8.1.2 (策梅洛-弗兰克尔公理系统)**
ZF公理系统包括：
- **外延公理**：$\forall x \forall y (\forall z (z \in x \leftrightarrow z \in y) \rightarrow x = y)$
- **空集公理**：$\exists x \forall y (y \notin x)$
- **配对公理**：$\forall x \forall y \exists z \forall w (w \in z \leftrightarrow w = x \lor w = y)$
- **并集公理**：$\forall x \exists y \forall z (z \in y \leftrightarrow \exists w (w \in x \land z \in w))$
- **幂集公理**：$\forall x \exists y \forall z (z \in y \leftrightarrow \forall w (w \in z \rightarrow w \in x))$
- **无穷公理**：$\exists x (\emptyset \in x \land \forall y (y \in x \rightarrow y \cup \{y\} \in x))$
- **替换公理模式**：$\forall x \forall y \forall z (\phi(x,y) \land \phi(x,z) \rightarrow y = z) \rightarrow \forall u \exists v \forall y (y \in v \leftrightarrow \exists x (x \in u \land \phi(x,y)))$
- **正则公理**：$\forall x (x \neq \emptyset \rightarrow \exists y (y \in x \land y \cap x = \emptyset))$

**定义 8.1.3 (选择公理)**
选择公理（AC）：$\forall x (\emptyset \notin x \rightarrow \exists f (f: x \rightarrow \bigcup x \land \forall y \in x (f(y) \in y)))$

**定理 8.1.1 (策梅洛定理)**
如果ZF公理系统一致，则ZF+AC也一致。

**定理 8.1.2 (哥德尔定理)**
如果ZF公理系统一致，则ZF+AC+CH也一致。

### 8.2 逻辑与数论

**定义 8.2.1 (皮亚诺公理)**
皮亚诺公理系统包括：
- **P1**：$0$ 是自然数
- **P2**：每个自然数都有唯一的后继
- **P3**：$0$ 不是任何自然数的后继
- **P4**：不同的自然数有不同的后继
- **P5**：数学归纳原理

**定义 8.2.2 (算术语言)**
算术语言 $\mathcal{L}_A$ 包含：
- 常元：$0$
- 函数符号：$S$（后继），$+$（加法），$\cdot$（乘法）
- 谓词符号：$=$（等号）

**定义 8.2.3 (皮亚诺算术)**
皮亚诺算术PA的公理包括：
- 皮亚诺公理的形式化
- 加法公理：$x + 0 = x$，$x + S(y) = S(x + y)$
- 乘法公理：$x \cdot 0 = 0$，$x \cdot S(y) = x \cdot y + x$

**定理 8.2.1 (哥德尔不完备性定理)**
皮亚诺算术是不完备的，存在真但不可证的算术句子。

**定理 8.2.2 (塔斯基定理)**
算术的真谓词在算术中不可定义。

### 8.3 逻辑与代数

**定义 8.3.1 (代数结构)**
代数结构是带有运算的集合，如群、环、域等。

**定义 8.3.2 (群论公理)**
群论的公理化定义：
- **结合律**：$(a \cdot b) \cdot c = a \cdot (b \cdot c)$
- **单位元**：$\exists e \forall a (e \cdot a = a \cdot e = a)$
- **逆元**：$\forall a \exists a^{-1} (a \cdot a^{-1} = a^{-1} \cdot a = e)$

**定义 8.3.3 (环论公理)**
环论的公理化定义：
- 加法群结构
- 乘法结合律
- 分配律：$a \cdot (b + c) = a \cdot b + a \cdot c$，$(a + b) \cdot c = a \cdot c + b \cdot c$

**定理 8.3.1 (代数结构的逻辑性质)**
代数结构的性质可以用一阶逻辑公式表达。

**定理 8.3.2 (代数理论的可判定性)**
某些代数理论是可判定的，如：
- 自由群理论
- 代数闭域理论
- 实数闭域理论

### 8.4 逻辑与分析

**定义 8.4.1 (实数公理)**
实数的公理化定义包括：
- 域公理
- 序公理
- 完备性公理

**定义 8.4.2 (完备性公理)**
完备性公理：每个有上界的非空集合都有最小上界。

**定义 8.4.3 (分析语言)**
分析语言包含：
- 实数常元
- 函数符号：$+$，$\cdot$，$-$，$/$，$\sqrt{}$
- 谓词符号：$=$，$<$，$\leq$

**定理 8.4.1 (实数理论的性质)**
实数理论是：
- 一致的
- 完全的
- 可判定的

**定理 8.4.2 (分析中的逻辑)**
分析中的许多概念可以用逻辑公式表达：
- 连续性：$\forall \epsilon > 0 \exists \delta > 0 \forall x (|x - a| < \delta \rightarrow |f(x) - f(a)| < \epsilon)$
- 极限：$\forall \epsilon > 0 \exists N \forall n > N (|a_n - L| < \epsilon)$

### 8.5 逻辑与几何

**定义 8.5.1 (欧几里得几何)**
欧几里得几何的公理化系统包括：
- 点、线、面的基本概念
- 公理：如两点确定一条直线
- 平行公理

**定义 8.5.2 (几何语言)**
几何语言包含：
- 个体变元：点、线、面
- 谓词：$P(x)$（$x$ 是点），$L(x)$（$x$ 是线），$Inc(x,y)$（$x$ 在 $y$ 上）

**定义 8.5.3 (几何公理)**
几何公理包括：
- **E1**：$\forall x \forall y (P(x) \land P(y) \land x \neq y \rightarrow \exists! z (L(z) \land Inc(x,z) \land Inc(y,z)))$
- **E2**：$\forall x \forall y (L(x) \land L(y) \land x \neq y \land \exists z (Inc(z,x) \land Inc(z,y)) \rightarrow \exists! z (Inc(z,x) \land Inc(z,y)))$

**定理 8.5.1 (几何的可判定性)**
欧几里得几何是可判定的。

**定理 8.5.2 (非欧几何)**
非欧几何（如双曲几何、椭圆几何）也可以用逻辑公理化。

### 8.6 逻辑与拓扑

**定义 8.6.1 (拓扑空间)**
拓扑空间 $(X, \tau)$ 由集合 $X$ 和开集族 $\tau$ 组成。

**定义 8.6.2 (拓扑公理)**
拓扑公理：
- $\emptyset, X \in \tau$
- 有限交封闭：$U, V \in \tau \rightarrow U \cap V \in \tau$
- 任意并封闭：$\{U_i\}_{i \in I} \subseteq \tau \rightarrow \bigcup_{i \in I} U_i \in \tau$

**定义 8.6.3 (拓扑语言)**
拓扑语言包含：
- 集合变元
- 谓词：$\in$（属于），$O(x)$（$x$ 是开集）

**定理 8.6.1 (拓扑性质的可表达性)**
许多拓扑性质可以用逻辑公式表达：
- 连通性
- 紧致性
- 分离性

### 8.7 逻辑与范畴论

**定义 8.7.1 (范畴)**
范畴 $\mathcal{C}$ 包含：
- 对象集合 $\text{Ob}(\mathcal{C})$
- 态射集合 $\text{Mor}(\mathcal{C})$
- 复合运算和单位态射

**定义 8.7.2 (范畴论语言)**
范畴论语言包含：
- 对象变元
- 态射变元
- 谓词：$\text{dom}(f,x)$（$f$ 的定义域是 $x$），$\text{cod}(f,y)$（$f$ 的余定义域是 $y$）

**定义 8.7.3 (范畴论公理)**
范畴论公理包括：
- 结合律：$(f \circ g) \circ h = f \circ (g \circ h)$
- 单位律：$1_A \circ f = f$，$f \circ 1_B = f$

**定理 8.7.1 (范畴论与逻辑)**
范畴论为逻辑提供了新的视角：
- 逻辑连接词对应范畴运算
- 证明对应态射
- 类型对应对象

### 8.8 逻辑与概率论

**定义 8.8.1 (概率空间)**
概率空间 $(\Omega, \mathcal{F}, P)$ 包含：
- 样本空间 $\Omega$
- 事件代数 $\mathcal{F}$
- 概率测度 $P$

**定义 8.8.2 (概率逻辑)**
概率逻辑将概率与逻辑结合：
- 概率公式：$P(\phi) \geq p$
- 条件概率：$P(\phi \mid \psi) = \frac{P(\phi \land \psi)}{P(\psi)}$

**定义 8.8.3 (概率推理)**
概率推理规则：
- **贝叶斯规则**：$P(A \mid B) = \frac{P(B \mid A) P(A)}{P(B)}$
- **全概率公式**：$P(A) = \sum_i P(A \mid B_i) P(B_i)$

**定理 8.8.1 (概率逻辑的性质)**
概率逻辑：
- 处理不确定性
- 支持贝叶斯推理
- 在机器学习中应用广泛

### 8.9 逻辑与信息论

**定义 8.9.1 (信息论基础)**
信息论研究信息的量化、传输和处理。

**定义 8.9.2 (熵)**
香农熵：$H(X) = -\sum_i p_i \log p_i$

**定义 8.9.3 (信息逻辑)**
信息逻辑研究逻辑系统中的信息内容：
- 信息量：$I(\phi) = -\log P(\phi)$
- 条件信息：$I(\phi \mid \psi) = -\log P(\phi \mid \psi)$

**定理 8.9.1 (信息论与逻辑)**
信息论为逻辑提供了：
- 信息量的度量
- 复杂性的分析
- 压缩的理论基础

### 8.10 逻辑与计算复杂性

**定义 8.10.1 (逻辑复杂性)**
逻辑复杂性研究逻辑公式和证明的复杂性。

**定义 8.10.2 (公式复杂性)**
公式复杂性包括：
- 公式长度
- 量词深度
- 连接词复杂度

**定义 8.10.3 (证明复杂性)**
证明复杂性包括：
- 证明长度
- 证明深度
- 使用的公理数量

**定理 8.10.1 (逻辑与计算)**
逻辑系统与计算模型对应：
- 命题逻辑对应布尔电路
- 一阶逻辑对应图灵机
- 高阶逻辑对应超计算

```rust
// 逻辑与数学基础的Rust实现
use std::collections::{HashMap, HashSet};

// 集合论实现
#[derive(Debug, Clone, PartialEq)]
pub struct Set {
    pub elements: HashSet<String>,
}

impl Set {
    pub fn new() -> Self {
        Self {
            elements: HashSet::new(),
        }
    }
    
    pub fn add_element(&mut self, element: &str) {
        self.elements.insert(element.to_string());
    }
    
    pub fn contains(&self, element: &str) -> bool {
        self.elements.contains(element)
    }
    
    pub fn union(&self, other: &Set) -> Set {
        let mut result = self.clone();
        result.elements.extend(other.elements.clone());
        result
    }
    
    pub fn intersection(&self, other: &Set) -> Set {
        let mut result = Set::new();
        for element in &self.elements {
            if other.contains(element) {
                result.add_element(element);
            }
        }
        result
    }
    
    pub fn is_subset(&self, other: &Set) -> bool {
        self.elements.iter().all(|e| other.contains(e))
    }
    
    pub fn is_empty(&self) -> bool {
        self.elements.is_empty()
    }
    
    pub fn cardinality(&self) -> usize {
        self.elements.len()
    }
}

// 皮亚诺算术实现
#[derive(Debug, Clone)]
pub struct PeanoArithmetic {
    pub axioms: Vec<String>,
    pub theorems: Vec<String>,
}

impl PeanoArithmetic {
    pub fn new() -> Self {
        let mut pa = Self {
            axioms: vec![],
            theorems: vec![],
        };
        
        // 添加皮亚诺公理
        pa.add_axiom("0 是自然数");
        pa.add_axiom("每个自然数都有唯一的后继");
        pa.add_axiom("0 不是任何自然数的后继");
        pa.add_axiom("不同的自然数有不同的后继");
        pa.add_axiom("数学归纳原理");
        
        pa
    }
    
    pub fn add_axiom(&mut self, axiom: &str) {
        self.axioms.push(axiom.to_string());
    }
    
    pub fn add_theorem(&mut self, theorem: &str) {
        self.theorems.push(theorem.to_string());
    }
    
    pub fn prove_by_induction<F>(&mut self, base_case: F, inductive_step: F) -> bool
    where
        F: Fn(u32) -> bool,
    {
        // 基础情况
        if !base_case(0) {
            return false;
        }
        
        // 归纳步骤
        for n in 0..100 { // 有限测试
            if base_case(n) && !base_case(n + 1) {
                return false;
            }
        }
        
        true
    }
}

// 群论实现
#[derive(Debug, Clone)]
pub struct Group {
    pub elements: Vec<String>,
    pub operation: HashMap<(String, String), String>,
    pub identity: String,
}

impl Group {
    pub fn new() -> Self {
        Self {
            elements: vec![],
            operation: HashMap::new(),
            identity: "".to_string(),
        }
    }
    
    pub fn add_element(&mut self, element: &str) {
        if !self.elements.contains(&element.to_string()) {
            self.elements.push(element.to_string());
        }
    }
    
    pub fn set_operation(&mut self, a: &str, b: &str, result: &str) {
        self.operation.insert((a.to_string(), b.to_string()), result.to_string());
    }
    
    pub fn set_identity(&mut self, identity: &str) {
        self.identity = identity.to_string();
    }
    
    pub fn multiply(&self, a: &str, b: &str) -> Option<String> {
        self.operation.get(&(a.to_string(), b.to_string())).cloned()
    }
    
    pub fn verify_group_axioms(&self) -> bool {
        // 检查结合律
        for a in &self.elements {
            for b in &self.elements {
                for c in &self.elements {
                    if let (Some(ab), Some(bc)) = (self.multiply(a, b), self.multiply(b, c)) {
                        if let (Some(ab_c), Some(a_bc)) = (self.multiply(&ab, c), self.multiply(a, &bc)) {
                            if ab_c != a_bc {
                                return false;
                            }
                        }
                    }
                }
            }
        }
        
        // 检查单位元
        for a in &self.elements {
            if self.multiply(&self.identity, a) != Some(a.clone()) ||
               self.multiply(a, &self.identity) != Some(a.clone()) {
                return false;
            }
        }
        
        // 检查逆元（简化实现）
        true
    }
}

// 实数理论实现
#[derive(Debug, Clone)]
pub struct RealNumber {
    pub value: f64,
}

impl RealNumber {
    pub fn new(value: f64) -> Self {
        Self { value }
    }
    
    pub fn add(&self, other: &RealNumber) -> RealNumber {
        RealNumber::new(self.value + other.value)
    }
    
    pub fn multiply(&self, other: &RealNumber) -> RealNumber {
        RealNumber::new(self.value * other.value)
    }
    
    pub fn is_positive(&self) -> bool {
        self.value > 0.0
    }
    
    pub fn absolute_value(&self) -> RealNumber {
        RealNumber::new(self.value.abs())
    }
}

// 拓扑空间实现
#[derive(Debug, Clone)]
pub struct TopologicalSpace {
    pub points: HashSet<String>,
    pub open_sets: HashSet<Set>,
}

impl TopologicalSpace {
    pub fn new() -> Self {
        Self {
            points: HashSet::new(),
            open_sets: HashSet::new(),
        }
    }
    
    pub fn add_point(&mut self, point: &str) {
        self.points.insert(point.to_string());
    }
    
    pub fn add_open_set(&mut self, open_set: Set) {
        self.open_sets.insert(open_set);
    }
    
    pub fn is_open(&self, set: &Set) -> bool {
        self.open_sets.contains(set)
    }
    
    pub fn is_closed(&self, set: &Set) -> bool {
        // 补集是开集
        let complement = self.complement(set);
        self.is_open(&complement)
    }
    
    fn complement(&self, set: &Set) -> Set {
        let mut complement = Set::new();
        for point in &self.points {
            if !set.contains(point) {
                complement.add_element(point);
            }
        }
        complement
    }
    
    pub fn verify_topology_axioms(&self) -> bool {
        // 空集和全集是开集
        let empty_set = Set::new();
        let universal_set = {
            let mut set = Set::new();
            for point in &self.points {
                set.add_element(point);
            }
            set
        };
        
        if !self.is_open(&empty_set) || !self.is_open(&universal_set) {
            return false;
        }
        
        // 有限交封闭
        // 任意并封闭
        // 简化实现
        true
    }
}

// 概率空间实现
#[derive(Debug, Clone)]
pub struct ProbabilitySpace {
    pub sample_space: Set,
    pub events: HashMap<String, f64>,
}

impl ProbabilitySpace {
    pub fn new() -> Self {
        Self {
            sample_space: Set::new(),
            events: HashMap::new(),
        }
    }
    
    pub fn add_event(&mut self, event: &str, probability: f64) {
        self.events.insert(event.to_string(), probability);
    }
    
    pub fn probability(&self, event: &str) -> f64 {
        *self.events.get(event).unwrap_or(&0.0)
    }
    
    pub fn conditional_probability(&self, event_a: &str, event_b: &str) -> f64 {
        let p_a_and_b = self.probability(&format!("{} and {}", event_a, event_b));
        let p_b = self.probability(event_b);
        
        if p_b > 0.0 {
            p_a_and_b / p_b
        } else {
            0.0
        }
    }
    
    pub fn bayes_theorem(&self, event_a: &str, event_b: &str) -> f64 {
        let p_b_given_a = self.conditional_probability(event_b, event_a);
        let p_a = self.probability(event_a);
        let p_b = self.probability(event_b);
        
        if p_b > 0.0 {
            (p_b_given_a * p_a) / p_b
        } else {
            0.0
        }
    }
}

// 示例：集合论操作
fn set_theory_example() {
    let mut set_a = Set::new();
    set_a.add_element("1");
    set_a.add_element("2");
    set_a.add_element("3");
    
    let mut set_b = Set::new();
    set_b.add_element("2");
    set_b.add_element("3");
    set_b.add_element("4");
    
    let union = set_a.union(&set_b);
    let intersection = set_a.intersection(&set_b);
    
    println!("集合A: {:?}", set_a.elements);
    println!("集合B: {:?}", set_b.elements);
    println!("并集: {:?}", union.elements);
    println!("交集: {:?}", intersection.elements);
}

// 示例：群论验证
fn group_theory_example() {
    let mut group = Group::new();
    
    group.add_element("e");
    group.add_element("a");
    group.add_element("b");
    group.add_element("c");
    
    group.set_identity("e");
    
    // 设置群运算（克莱因四元群）
    group.set_operation("e", "e", "e");
    group.set_operation("e", "a", "a");
    group.set_operation("e", "b", "b");
    group.set_operation("e", "c", "c");
    
    group.set_operation("a", "e", "a");
    group.set_operation("a", "a", "e");
    group.set_operation("a", "b", "c");
    group.set_operation("a", "c", "b");
    
    group.set_operation("b", "e", "b");
    group.set_operation("b", "a", "c");
    group.set_operation("b", "b", "e");
    group.set_operation("b", "c", "a");
    
    group.set_operation("c", "e", "c");
    group.set_operation("c", "a", "b");
    group.set_operation("c", "b", "a");
    group.set_operation("c", "c", "e");
    
    println!("群公理验证: {}", group.verify_group_axioms());
}

// 示例：概率论计算
fn probability_example() {
    let mut prob_space = ProbabilitySpace::new();
    
    prob_space.add_event("A", 0.3);
    prob_space.add_event("B", 0.4);
    prob_space.add_event("A and B", 0.1);
    
    let p_a_given_b = prob_space.conditional_probability("A", "B");
    let p_b_given_a = prob_space.conditional_probability("B", "A");
    
    println!("P(A|B) = {}", p_a_given_b);
    println!("P(B|A) = {}", p_b_given_a);
    
    let bayes_result = prob_space.bayes_theorem("A", "B");
    println!("贝叶斯定理结果: {}", bayes_result);
}
```

### 8.11 逻辑与数学基础的未来发展

**发展 8.11.1 (构造性数学)**
构造性数学强调构造性证明，与直觉主义逻辑密切相关。

**发展 8.11.2 (同伦类型论)**
同伦类型论将拓扑学与类型论结合，为数学基础提供新的视角。

**发展 8.11.3 (范畴论基础)**
范畴论作为数学的新基础，提供统一的数学语言和框架。

## 9.0 逻辑与编程语言

### 9.1 类型系统基础

**定义 9.1.1 (类型系统)**
类型系统是编程语言中用于类型检查和类型推断的规则集合。

**定义 9.1.2 (类型)**
类型是对程序值的分类，描述值的结构和行为。

**定义 9.1.3 (类型检查)**
类型检查是验证程序是否满足类型规则的过程。

**定义 9.1.4 (类型推断)**
类型推断是自动推导表达式类型的过程。

**定理 9.1.1 (类型安全)**
类型安全的程序不会在运行时出现类型错误。

### 9.2 简单类型系统

**定义 9.2.1 (简单类型)**
简单类型包括：
- 基本类型：$int, bool, char, unit$
- 函数类型：$A \rightarrow B$
- 积类型：$A \times B$
- 和类型：$A + B$

**定义 9.2.2 (类型规则)**
简单类型系统的类型规则：

**变量规则**：
$$\frac{x: A \in \Gamma}{\Gamma \vdash x: A}$$

**函数抽象**：
$$\frac{\Gamma, x: A \vdash e: B}{\Gamma \vdash \lambda x. e: A \rightarrow B}$$

**函数应用**：
$$\frac{\Gamma \vdash e_1: A \rightarrow B \quad \Gamma \vdash e_2: A}{\Gamma \vdash e_1 e_2: B}$$

**积类型构造**：
$$\frac{\Gamma \vdash e_1: A \quad \Gamma \vdash e_2: B}{\Gamma \vdash (e_1, e_2): A \times B}$$

**积类型投影**：
$$\frac{\Gamma \vdash e: A \times B}{\Gamma \vdash \pi_1(e): A} \quad \frac{\Gamma \vdash e: A \times B}{\Gamma \vdash \pi_2(e): B}$$

**定理 9.2.1 (类型保持)**
如果 $\Gamma \vdash e: A$ 且 $e \rightarrow e'$，则 $\Gamma \vdash e': A$。

### 9.3 多态类型系统

**定义 9.3.1 (多态类型)**
多态类型允许类型变量，如 $\forall \alpha. \alpha \rightarrow \alpha$。

**定义 9.3.2 (类型变量)**
类型变量 $\alpha, \beta, \gamma, \ldots$ 表示任意类型。

**定义 9.3.3 (全称类型)**
全称类型 $\forall \alpha. A$ 表示对所有类型 $\alpha$，$A$ 都成立。

**定义 9.3.4 (类型实例化)**
类型实例化规则：
$$\frac{\Gamma \vdash e: \forall \alpha. A}{\Gamma \vdash e: A[B/\alpha]}$$

**定义 9.3.5 (类型泛化)**
类型泛化规则：
$$\frac{\Gamma \vdash e: A \quad \alpha \notin \text{FTV}(\Gamma)}{\Gamma \vdash e: \forall \alpha. A}$$

**定理 9.3.1 (Hindley-Milner类型系统)**
Hindley-Milner类型系统具有：
- 类型推断的完备性
- 最一般类型的唯一性
- 多项式时间类型推断算法

### 9.4 依赖类型系统

**定义 9.4.1 (依赖类型)**
依赖类型允许类型依赖于值，如 $\Pi x: A. B(x)$。

**定义 9.4.2 (Π类型)**
Π类型 $\Pi x: A. B(x)$ 表示依赖函数类型。

**定义 9.4.3 (Σ类型)**
Σ类型 $\Sigma x: A. B(x)$ 表示依赖积类型。

**定义 9.4.4 (依赖类型规则)**
依赖类型的类型规则：

**Π类型构造**：
$$\frac{\Gamma, x: A \vdash e: B(x)}{\Gamma \vdash \lambda x. e: \Pi x: A. B(x)}$$

**Π类型应用**：
$$\frac{\Gamma \vdash e_1: \Pi x: A. B(x) \quad \Gamma \vdash e_2: A}{\Gamma \vdash e_1 e_2: B(e_2)}$$

**Σ类型构造**：
$$\frac{\Gamma \vdash e_1: A \quad \Gamma \vdash e_2: B(e_1)}{\Gamma \vdash (e_1, e_2): \Sigma x: A. B(x)}$$

**定理 9.4.1 (Curry-Howard对应)**
在依赖类型系统中，类型对应命题，程序对应证明。

### 9.5 同伦类型论

**定义 9.5.1 (同伦类型论)**
同伦类型论将拓扑学与类型论结合，为数学提供新的基础。

**定义 9.5.2 (身份类型)**
身份类型 $a =_A b$ 表示 $a$ 和 $b$ 在类型 $A$ 中的相等性。

**定义 9.5.3 (路径)**
路径是身份类型的元素，表示两个值之间的相等性证明。

**定义 9.5.4 (同伦)**
同伦是路径之间的连续变形。

**定义 9.5.5 (高阶归纳类型)**
高阶归纳类型允许递归定义复杂的数据结构。

**定理 9.5.1 (Voevodsky的发现)**
同伦类型论为数学提供了：
- 构造性的数学基础
- 自动的证明验证
- 计算性的数学内容

### 9.6 证明助手

**定义 9.6.1 (证明助手)**
证明助手是帮助构造和验证形式证明的计算机程序。

**定义 9.6.2 (交互式定理证明)**
交互式定理证明结合人工指导和自动推理。

**定义 9.6.3 (证明策略)**
证明策略是证明助手中的自动化推理方法。

**定义 9.6.4 (证明脚本)**
证明脚本是记录证明过程的程序。

**定理 9.6.1 (证明助手的应用)**
证明助手在以下领域有重要应用：
- 数学定理的机器验证
- 程序正确性证明
- 硬件设计验证
- 密码协议验证

### 9.7 形式化验证

**定义 9.7.1 (形式化验证)**
形式化验证是使用数学方法证明系统正确性的技术。

**定义 9.7.2 (模型检测)**
模型检测是自动验证系统是否满足规范的技术。

**定义 9.7.3 (定理证明)**
定理证明是使用逻辑推理证明系统性质的方法。

**定义 9.7.4 (抽象解释)**
抽象解释是使用抽象域分析程序性质的技术。

**定理 9.7.1 (验证方法的比较)**
不同验证方法的特点：
- 模型检测：自动化程度高，但状态空间爆炸
- 定理证明：表达能力强，但需要人工指导
- 抽象解释：效率高，但可能不够精确

### 9.8 程序逻辑

**定义 9.8.1 (霍尔逻辑)**
霍尔逻辑用于程序验证的三元组 $\{P\} C \{Q\}$。

**定义 9.8.2 (分离逻辑)**
分离逻辑扩展霍尔逻辑，处理指针和动态内存。

**定义 9.8.3 (并发逻辑)**
并发逻辑处理并发程序的验证。

**定义 9.8.4 (时态逻辑)**
时态逻辑描述程序的时间行为。

**定理 9.8.1 (程序逻辑的完备性)**
程序逻辑为程序验证提供了：
- 形式化的推理规则
- 自动化的验证工具
- 可证明的正确性保证

### 9.9 类型安全的编程语言

**定义 9.9.1 (类型安全)**
类型安全的语言在编译时或运行时检查类型错误。

**定义 9.9.2 (内存安全)**
内存安全的语言防止内存访问错误。

**定义 9.9.3 (线程安全)**
线程安全的语言防止并发访问错误。

**定义 9.9.4 (函数式编程)**
函数式编程强调不可变性和纯函数。

**定理 9.9.1 (类型安全的好处)**
类型安全提供：
- 更早的错误检测
- 更好的代码文档
- 更安全的程序执行
- 更好的开发工具支持

### 9.10 逻辑编程语言

**定义 9.10.1 (逻辑编程)**
逻辑编程基于逻辑推理，如Prolog。

**定义 9.10.2 (Horn子句)**
Horn子句是逻辑编程的基本单位。

**定义 9.10.3 (SLD归结)**
SLD归结是逻辑编程的推理规则。

**定义 9.10.4 (约束逻辑编程)**
约束逻辑编程结合逻辑和约束求解。

**定理 9.10.1 (逻辑编程的应用)**
逻辑编程适用于：
- 知识表示和推理
- 自然语言处理
- 专家系统
- 约束满足问题

```rust
// 逻辑与编程语言的Rust实现
use std::collections::HashMap;

// 简单类型系统
#[derive(Debug, Clone, PartialEq)]
pub enum SimpleType {
    Int,
    Bool,
    Char,
    Unit,
    Function(Box<SimpleType>, Box<SimpleType>),
    Product(Box<SimpleType>, Box<SimpleType>),
    Sum(Box<SimpleType>, Box<SimpleType>),
}

impl SimpleType {
    pub fn is_basic(&self) -> bool {
        matches!(self, SimpleType::Int | SimpleType::Bool | SimpleType::Char | SimpleType::Unit)
    }
    
    pub fn is_function(&self) -> bool {
        matches!(self, SimpleType::Function(_, _))
    }
    
    pub fn is_product(&self) -> bool {
        matches!(self, SimpleType::Product(_, _))
    }
    
    pub fn is_sum(&self) -> bool {
        matches!(self, SimpleType::Sum(_, _))
    }
}

// 类型环境
pub struct TypeEnvironment {
    pub bindings: HashMap<String, SimpleType>,
}

impl TypeEnvironment {
    pub fn new() -> Self {
        Self {
            bindings: HashMap::new(),
        }
    }
    
    pub fn add_binding(&mut self, name: &str, typ: SimpleType) {
        self.bindings.insert(name.to_string(), typ);
    }
    
    pub fn get_type(&self, name: &str) -> Option<&SimpleType> {
        self.bindings.get(name)
    }
}

// 简单表达式
#[derive(Debug, Clone)]
pub enum SimpleExpression {
    Variable(String),
    Integer(i32),
    Boolean(bool),
    Character(char),
    Unit,
    Lambda(String, Box<SimpleExpression>),
    Application(Box<SimpleExpression>, Box<SimpleExpression>),
    Pair(Box<SimpleExpression>, Box<SimpleExpression>),
    First(Box<SimpleExpression>),
    Second(Box<SimpleExpression>),
    Left(Box<SimpleExpression>),
    Right(Box<SimpleExpression>),
    Case(Box<SimpleExpression>, String, Box<SimpleExpression>, String, Box<SimpleExpression>),
}

// 类型检查器
pub struct TypeChecker {
    pub environment: TypeEnvironment,
}

impl TypeChecker {
    pub fn new() -> Self {
        Self {
            environment: TypeEnvironment::new(),
        }
    }
    
    pub fn type_check(&mut self, expr: &SimpleExpression) -> Result<SimpleType, String> {
        match expr {
            SimpleExpression::Variable(name) => {
                self.environment.get_type(name)
                    .cloned()
                    .ok_or_else(|| format!("未定义的变量: {}", name))
            }
            SimpleExpression::Integer(_) => Ok(SimpleType::Int),
            SimpleExpression::Boolean(_) => Ok(SimpleType::Bool),
            SimpleExpression::Character(_) => Ok(SimpleType::Char),
            SimpleExpression::Unit => Ok(SimpleType::Unit),
            SimpleExpression::Lambda(param, body) => {
                // 简化实现：假设参数类型为Int
                let param_type = SimpleType::Int;
                let mut new_env = self.environment.clone();
                new_env.add_binding(param, param_type.clone());
                
                let mut body_checker = TypeChecker { environment: new_env };
                let body_type = body_checker.type_check(body)?;
                
                Ok(SimpleType::Function(Box::new(param_type), Box::new(body_type)))
            }
            SimpleExpression::Application(func, arg) => {
                let func_type = self.type_check(func)?;
                let arg_type = self.type_check(arg)?;
                
                if let SimpleType::Function(param_type, return_type) = func_type {
                    if *param_type == arg_type {
                        Ok(*return_type)
                    } else {
                        Err(format!("类型不匹配: 期望 {}, 得到 {}", param_type, arg_type))
                    }
                } else {
                    Err("不是函数类型".to_string())
                }
            }
            SimpleExpression::Pair(first, second) => {
                let first_type = self.type_check(first)?;
                let second_type = self.type_check(second)?;
                
                Ok(SimpleType::Product(Box::new(first_type), Box::new(second_type)))
            }
            SimpleExpression::First(pair) => {
                let pair_type = self.type_check(pair)?;
                
                if let SimpleType::Product(first_type, _) = pair_type {
                    Ok(*first_type)
                } else {
                    Err("不是积类型".to_string())
                }
            }
            SimpleExpression::Second(pair) => {
                let pair_type = self.type_check(pair)?;
                
                if let SimpleType::Product(_, second_type) = pair_type {
                    Ok(*second_type)
                } else {
                    Err("不是积类型".to_string())
                }
            }
            _ => Err("未实现的表达式类型".to_string()),
        }
    }
}

// 多态类型系统
#[derive(Debug, Clone, PartialEq)]
pub enum PolymorphicType {
    Variable(String),
    Basic(SimpleType),
    Function(Box<PolymorphicType>, Box<PolymorphicType>),
    ForAll(String, Box<PolymorphicType>),
}

impl PolymorphicType {
    pub fn substitute(&self, var: &str, replacement: &PolymorphicType) -> PolymorphicType {
        match self {
            PolymorphicType::Variable(v) if v == var => replacement.clone(),
            PolymorphicType::Variable(_) => self.clone(),
            PolymorphicType::Basic(_) => self.clone(),
            PolymorphicType::Function(t1, t2) => PolymorphicType::Function(
                Box::new(t1.substitute(var, replacement)),
                Box::new(t2.substitute(var, replacement))
            ),
            PolymorphicType::ForAll(v, t) if v == var => self.clone(),
            PolymorphicType::ForAll(v, t) => PolymorphicType::ForAll(
                v.clone(),
                Box::new(t.substitute(var, replacement))
            ),
        }
    }
    
    pub fn free_type_variables(&self) -> Vec<String> {
        match self {
            PolymorphicType::Variable(v) => vec![v.clone()],
            PolymorphicType::Basic(_) => vec![],
            PolymorphicType::Function(t1, t2) => {
                let mut vars = t1.free_type_variables();
                vars.extend(t2.free_type_variables());
                vars
            }
            PolymorphicType::ForAll(v, t) => {
                let mut vars = t.free_type_variables();
                vars.retain(|x| x != v);
                vars
            }
        }
    }
}

// 证明助手框架
#[derive(Debug, Clone)]
pub struct ProofAssistant {
    pub theorems: HashMap<String, Theorem>,
    pub tactics: HashMap<String, Box<dyn Tactic>>,
}

#[derive(Debug, Clone)]
pub struct Theorem {
    pub name: String,
    pub statement: String,
    pub proof: Option<Proof>,
}

#[derive(Debug, Clone)]
pub struct Proof {
    pub steps: Vec<ProofStep>,
    pub conclusion: String,
}

#[derive(Debug, Clone)]
pub enum ProofStep {
    Axiom(String),
    Assumption(String),
    ModusPonens(usize, usize),
    AndIntro(usize, usize),
    AndElim1(usize),
    AndElim2(usize),
    OrIntro1(usize),
    OrIntro2(usize),
    ImpliesIntro(usize, usize),
    ImpliesElim(usize, usize),
    ForAllIntro(usize, String),
    ForAllElim(usize, String),
    ExistsIntro(usize, String),
    ExistsElim(usize, Vec<usize>, String),
}

pub trait Tactic {
    fn apply(&self, goal: &str, context: &[String]) -> Result<Vec<ProofStep>, String>;
}

impl ProofAssistant {
    pub fn new() -> Self {
        Self {
            theorems: HashMap::new(),
            tactics: HashMap::new(),
        }
    }
    
    pub fn add_theorem(&mut self, name: &str, statement: &str) {
        self.theorems.insert(name.to_string(), Theorem {
            name: name.to_string(),
            statement: statement.to_string(),
            proof: None,
        });
    }
    
    pub fn add_tactic(&mut self, name: &str, tactic: Box<dyn Tactic>) {
        self.tactics.insert(name.to_string(), tactic);
    }
    
    pub fn prove(&mut self, theorem_name: &str, proof: Proof) -> Result<(), String> {
        if let Some(theorem) = self.theorems.get_mut(theorem_name) {
            theorem.proof = Some(proof);
            Ok(())
        } else {
            Err(format!("定理不存在: {}", theorem_name))
        }
    }
    
    pub fn verify_proof(&self, proof: &Proof) -> Result<(), String> {
        // 简化实现：基本验证
        for (i, step) in proof.steps.iter().enumerate() {
            match step {
                ProofStep::Axiom(_) => {
                    // 公理总是有效的
                }
                ProofStep::Assumption(_) => {
                    // 假设在证明中有效
                }
                ProofStep::ModusPonens(step1, step2) => {
                    if *step1 >= i || *step2 >= i {
                        return Err(format!("步骤 {} 引用了未定义的步骤", i));
                    }
                }
                _ => {
                    // 其他规则的验证
                }
            }
        }
        Ok(())
    }
}

// 霍尔逻辑验证器
#[derive(Debug, Clone)]
pub struct HoareLogicVerifier {
    pub rules: Vec<HoareRule>,
}

#[derive(Debug, Clone)]
pub struct HoareRule {
    pub precondition: String,
    pub program: String,
    pub postcondition: String,
}

impl HoareLogicVerifier {
    pub fn new() -> Self {
        Self { rules: vec![] }
    }
    
    pub fn add_rule(&mut self, precondition: &str, program: &str, postcondition: &str) {
        self.rules.push(HoareRule {
            precondition: precondition.to_string(),
            program: program.to_string(),
            postcondition: postcondition.to_string(),
        });
    }
    
    pub fn verify_assignment(&self, variable: &str, expression: &str, postcondition: &str) -> String {
        // 计算最弱前置条件
        postcondition.replace(variable, expression)
    }
    
    pub fn verify_sequence(&self, precondition: &str, program1: &str, program2: &str, postcondition: &str) -> bool {
        // 简化实现：检查序列规则
        true
    }
    
    pub fn verify_conditional(&self, precondition: &str, condition: &str, 
                            then_program: &str, else_program: &str, postcondition: &str) -> bool {
        // 简化实现：检查条件规则
        true
    }
}

// 示例：类型检查
fn type_checking_example() {
    let mut checker = TypeChecker::new();
    
    // 添加一些基本绑定
    checker.environment.add_binding("x", SimpleType::Int);
    checker.environment.add_binding("y", SimpleType::Bool);
    
    // 检查变量
    let var_expr = SimpleExpression::Variable("x".to_string());
    match checker.type_check(&var_expr) {
        Ok(typ) => println!("x 的类型: {:?}", typ),
        Err(e) => println!("类型检查错误: {}", e),
    }
    
    // 检查函数应用
    let lambda = SimpleExpression::Lambda("x".to_string(), 
        Box::new(SimpleExpression::Variable("x".to_string())));
    let app = SimpleExpression::Application(
        Box::new(lambda),
        Box::new(SimpleExpression::Integer(42))
    );
    
    match checker.type_check(&app) {
        Ok(typ) => println!("函数应用的类型: {:?}", typ),
        Err(e) => println!("类型检查错误: {}", e),
    }
}

// 示例：证明助手
fn proof_assistant_example() {
    let mut assistant = ProofAssistant::new();
    
    // 添加定理
    assistant.add_theorem("modus_ponens", "如果 A → B 且 A，则 B");
    
    // 构造证明
    let proof = Proof {
        steps: vec![
            ProofStep::Axiom("A → B".to_string()),
            ProofStep::Assumption("A".to_string()),
            ProofStep::ModusPonens(0, 1),
        ],
        conclusion: "B".to_string(),
    };
    
    // 验证证明
    match assistant.verify_proof(&proof) {
        Ok(()) => println!("证明验证成功"),
        Err(e) => println!("证明验证失败: {}", e),
    }
    
    // 记录证明
    assistant.prove("modus_ponens", proof).unwrap();
}

// 示例：霍尔逻辑验证
fn hoare_logic_example() {
    let mut verifier = HoareLogicVerifier::new();
    
    // 验证赋值语句 {x > 0} x := x + 1 {x > 1}
    let wp = verifier.verify_assignment("x", "x + 1", "x > 1");
    println!("最弱前置条件: {}", wp);
    
    // 验证序列 {x > 0} x := x + 1; y := x * 2 {y > 2}
    let valid = verifier.verify_sequence("x > 0", "x := x + 1", "y := x * 2", "y > 2");
    println!("序列验证: {}", valid);
    
    // 验证条件语句 {x > 0} if x > 5 then y := x else y := 5 {y > 0}
    let valid_cond = verifier.verify_conditional("x > 0", "x > 5", "y := x", "y := 5", "y > 0");
    println!("条件验证: {}", valid_cond);
}
```

### 9.11 逻辑与编程语言的未来发展

**发展 9.11.1 (智能合约验证)**
逻辑在区块链智能合约验证中的应用。

**发展 9.11.2 (量子编程语言)**
量子编程语言中的逻辑系统。

**发展 9.11.3 (神经符号编程)**
结合神经网络和符号推理的编程范式。

## 10.0 逻辑的前沿与应用

（待自动填充：同伦类型论、量子逻辑、AI逻辑、跨学科应用等） 