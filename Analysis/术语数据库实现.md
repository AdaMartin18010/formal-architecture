# 术语数据库实现

## 概述

本文档实现了术语数据库的具体结构，用于统一项目中的术语使用，确保与国际Wiki和学术标准的一致性。

## 1. 核心数据结构

### 1.1 术语定义结构

```rust
use std::collections::HashMap;
use serde::{Deserialize, Serialize};

/// 术语定义
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TermDefinition {
    /// 术语名称
    pub name: String,
    /// 英文标准名称
    pub english_name: String,
    /// 定义描述
    pub definition: String,
    /// 术语类别
    pub category: TermCategory,
    /// 来源标准
    pub source: TermSource,
    /// 同义词列表
    pub synonyms: Vec<String>,
    /// 上下文信息
    pub context: String,
    /// 使用示例
    pub examples: Vec<String>,
    /// 相关术语
    pub related_terms: Vec<String>,
    /// 置信度 (0.0-1.0)
    pub confidence: f64,
}

/// 术语类别
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum TermCategory {
    FormalMethods,      // 形式化方法
    ProgrammingLanguage, // 编程语言
    SoftwareArchitecture, // 软件架构
    Concurrency,        // 并发理论
    Verification,       // 形式化验证
    Mathematics,        // 数学理论
    Philosophy,         // 哲学基础
    Other,              // 其他
}

/// 术语来源
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum TermSource {
    Wikipedia,          // Wikipedia
    AcademicPaper,      // 学术论文
    OfficialDocument,   // 官方文档
    IndustryStandard,   // 行业标准
    ProjectInternal,    // 项目内部
}

/// 标准术语引用
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StandardReference {
    /// 标准名称
    pub standard_name: String,
    /// 标准版本
    pub version: String,
    /// 引用链接
    pub url: Option<String>,
    /// 定义内容
    pub definition: String,
    /// 发布日期
    pub publication_date: Option<String>,
}
```

### 1.2 术语数据库结构

```rust
/// 术语数据库
#[derive(Debug, Clone)]
pub struct TerminologyDatabase {
    /// 术语定义映射
    terms: HashMap<String, TermDefinition>,
    /// 同义词映射
    synonyms: HashMap<String, Vec<String>>,
    /// 上下文定义
    contexts: HashMap<String, ContextDefinition>,
    /// 标准引用
    standards: HashMap<String, StandardReference>,
    /// 类别索引
    category_index: HashMap<TermCategory, Vec<String>>,
    /// 来源索引
    source_index: HashMap<TermSource, Vec<String>>,
}

/// 上下文定义
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ContextDefinition {
    /// 上下文名称
    pub name: String,
    /// 上下文描述
    pub description: String,
    /// 适用术语列表
    pub applicable_terms: Vec<String>,
    /// 使用规则
    pub usage_rules: Vec<String>,
}

impl TerminologyDatabase {
    /// 创建新的术语数据库
    pub fn new() -> Self {
        Self {
            terms: HashMap::new(),
            synonyms: HashMap::new(),
            contexts: HashMap::new(),
            standards: HashMap::new(),
            category_index: HashMap::new(),
            source_index: HashMap::new(),
        }
    }

    /// 添加术语定义
    pub fn add_term(&mut self, term: TermDefinition) -> Result<(), String> {
        let name = term.name.clone();
        
        // 验证术语定义
        self.validate_term(&term)?;
        
        // 添加到主映射
        self.terms.insert(name.clone(), term.clone());
        
        // 更新同义词映射
        for synonym in &term.synonyms {
            self.synonyms
                .entry(synonym.clone())
                .or_insert_with(Vec::new)
                .push(name.clone());
        }
        
        // 更新类别索引
        self.category_index
            .entry(term.category.clone())
            .or_insert_with(Vec::new)
            .push(name.clone());
        
        // 更新来源索引
        self.source_index
            .entry(term.source.clone())
            .or_insert_with(Vec::new)
            .push(name.clone());
        
        Ok(())
    }

    /// 验证术语定义
    fn validate_term(&self, term: &TermDefinition) -> Result<(), String> {
        if term.name.is_empty() {
            return Err("术语名称不能为空".to_string());
        }
        
        if term.definition.is_empty() {
            return Err("术语定义不能为空".to_string());
        }
        
        if term.confidence < 0.0 || term.confidence > 1.0 {
            return Err("置信度必须在0.0到1.0之间".to_string());
        }
        
        Ok(())
    }

    /// 查找术语定义
    pub fn find_term(&self, name: &str) -> Option<&TermDefinition> {
        self.terms.get(name)
    }

    /// 通过同义词查找术语
    pub fn find_by_synonym(&self, synonym: &str) -> Option<&TermDefinition> {
        if let Some(terms) = self.synonyms.get(synonym) {
            if let Some(first_term) = terms.first() {
                return self.terms.get(first_term);
            }
        }
        None
    }

    /// 查找标准等价术语
    pub fn find_standard_equivalent(&self, term: &str) -> Option<&StandardReference> {
        self.standards.get(term)
    }

    /// 按类别查找术语
    pub fn find_by_category(&self, category: &TermCategory) -> Vec<&TermDefinition> {
        if let Some(term_names) = self.category_index.get(category) {
            term_names
                .iter()
                .filter_map(|name| self.terms.get(name))
                .collect()
        } else {
            Vec::new()
        }
    }

    /// 按来源查找术语
    pub fn find_by_source(&self, source: &TermSource) -> Vec<&TermDefinition> {
        if let Some(term_names) = self.source_index.get(source) {
            term_names
                .iter()
                .filter_map(|name| self.terms.get(name))
                .collect()
        } else {
            Vec::new()
        }
    }

    /// 搜索术语
    pub fn search_terms(&self, query: &str) -> Vec<&TermDefinition> {
        let query_lower = query.to_lowercase();
        let mut results = Vec::new();
        
        for term in self.terms.values() {
            if term.name.to_lowercase().contains(&query_lower) ||
               term.english_name.to_lowercase().contains(&query_lower) ||
               term.definition.to_lowercase().contains(&query_lower) ||
               term.synonyms.iter().any(|s| s.to_lowercase().contains(&query_lower)) {
                results.push(term);
            }
        }
        
        results
    }

    /// 获取所有术语
    pub fn get_all_terms(&self) -> Vec<&TermDefinition> {
        self.terms.values().collect()
    }

    /// 获取术语总数
    pub fn term_count(&self) -> usize {
        self.terms.len()
    }
}
```

## 2. 标准术语导入

### 2.1 Wikipedia术语导入

```rust
/// Wikipedia术语导入器
pub struct WikipediaTermImporter {
    /// API基础URL
    base_url: String,
    /// 请求客户端
    client: reqwest::Client,
}

impl WikipediaTermImporter {
    pub fn new() -> Self {
        Self {
            base_url: "https://en.wikipedia.org/api/rest_v1".to_string(),
            client: reqwest::Client::new(),
        }
    }

    /// 导入形式化方法相关术语
    pub async fn import_formal_methods_terms(&self) -> Result<Vec<TermDefinition>, Box<dyn std::error::Error>> {
        let terms = vec![
            self.create_formal_methods_term("Formal Methods", "形式化方法"),
            self.create_formal_methods_term("Formal Specification", "形式化规范"),
            self.create_formal_methods_term("Formal Verification", "形式化验证"),
            self.create_formal_methods_term("Model Checking", "模型检查"),
            self.create_formal_methods_term("Theorem Proving", "定理证明"),
        ];

        let mut results = Vec::new();
        for term in terms {
            if let Ok(definition) = self.fetch_wikipedia_definition(&term.english_name).await {
                results.push(definition);
            }
        }

        Ok(results)
    }

    /// 创建形式化方法术语
    fn create_formal_methods_term(&self, english_name: &str, chinese_name: &str) -> TermDefinition {
        TermDefinition {
            name: chinese_name.to_string(),
            english_name: english_name.to_string(),
            definition: format!("{} - 需要从Wikipedia获取定义", english_name),
            category: TermCategory::FormalMethods,
            source: TermSource::Wikipedia,
            synonyms: vec![english_name.to_string()],
            context: "Software Engineering".to_string(),
            examples: Vec::new(),
            related_terms: Vec::new(),
            confidence: 0.9,
        }
    }

    /// 从Wikipedia获取定义
    async fn fetch_wikipedia_definition(&self, term: &str) -> Result<TermDefinition, Box<dyn std::error::Error>> {
        let url = format!("{}/page/summary/{}", self.base_url, term);
        let response = self.client.get(&url).send().await?;
        
        if response.status().is_success() {
            let summary: serde_json::Value = response.json().await?;
            
            if let Some(extract) = summary["extract"].as_str() {
                return Ok(TermDefinition {
                    name: term.to_string(),
                    english_name: term.to_string(),
                    definition: extract.to_string(),
                    category: TermCategory::FormalMethods,
                    source: TermSource::Wikipedia,
                    synonyms: vec![term.to_string()],
                    context: "Software Engineering".to_string(),
                    examples: Vec::new(),
                    related_terms: Vec::new(),
                    confidence: 0.8,
                });
            }
        }
        
        Err("Failed to fetch Wikipedia definition".into())
    }
}
```

### 2.2 编程语言术语导入

```rust
/// 编程语言术语导入器
pub struct ProgrammingLanguageTermImporter;

impl ProgrammingLanguageTermImporter {
    /// 导入Rust相关术语
    pub fn import_rust_terms() -> Vec<TermDefinition> {
        vec![
            TermDefinition {
                name: "所有权系统".to_string(),
                english_name: "Ownership System".to_string(),
                definition: "管理内存分配和释放的机制，确保内存安全".to_string(),
                category: TermCategory::ProgrammingLanguage,
                source: TermSource::OfficialDocument,
                synonyms: vec!["Ownership".to_string(), "内存管理".to_string()],
                context: "Rust Programming Language".to_string(),
                examples: vec![
                    "let x = String::from(\"hello\");".to_string(),
                    "let y = x; // x的所有权移动到y".to_string(),
                ],
                related_terms: vec!["借用检查".to_string(), "生命周期".to_string()],
                confidence: 0.95,
            },
            TermDefinition {
                name: "借用检查".to_string(),
                english_name: "Borrow Checking".to_string(),
                definition: "在编译时检查引用的有效性和安全性的机制".to_string(),
                category: TermCategory::ProgrammingLanguage,
                source: TermSource::OfficialDocument,
                synonyms: vec!["Borrow Checker".to_string(), "引用检查".to_string()],
                context: "Rust Programming Language".to_string(),
                examples: vec![
                    "let mut v = vec![1, 2, 3];".to_string(),
                    "let first = &v[0];".to_string(),
                    "v.push(4); // 编译错误：借用检查失败".to_string(),
                ],
                related_terms: vec!["所有权系统".to_string(), "生命周期".to_string()],
                confidence: 0.95,
            },
            TermDefinition {
                name: "生命周期".to_string(),
                english_name: "Lifetime".to_string(),
                definition: "引用在程序中有效的持续时间".to_string(),
                category: TermCategory::ProgrammingLanguage,
                source: TermSource::OfficialDocument,
                synonyms: vec!["引用生命周期".to_string(), "作用域".to_string()],
                context: "Rust Programming Language".to_string(),
                examples: vec![
                    "fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {{".to_string(),
                    "    if x.len() > y.len() {{ x }} else {{ y }}".to_string(),
                    "}}".to_string(),
                ],
                related_terms: vec!["所有权系统".to_string(), "借用检查".to_string()],
                confidence: 0.95,
            },
        ]
    }

    /// 导入Go相关术语
    pub fn import_go_terms() -> Vec<TermDefinition> {
        vec![
            TermDefinition {
                name: "Goroutine".to_string(),
                english_name: "Goroutine".to_string(),
                definition: "Go语言中的轻量级线程，由Go运行时管理".to_string(),
                category: TermCategory::ProgrammingLanguage,
                source: TermSource::OfficialDocument,
                synonyms: vec!["协程".to_string(), "轻量级线程".to_string()],
                context: "Go Programming Language".to_string(),
                examples: vec![
                    "go func() {{".to_string(),
                    "    fmt.Println(\"Hello from goroutine\")".to_string(),
                    "}}()".to_string(),
                ],
                related_terms: vec!["Channel".to_string(), "并发".to_string()],
                confidence: 0.95,
            },
            TermDefinition {
                name: "Channel".to_string(),
                english_name: "Channel".to_string(),
                definition: "Go语言中用于goroutine间通信的机制".to_string(),
                category: TermCategory::ProgrammingLanguage,
                source: TermSource::OfficialDocument,
                synonyms: vec!["通道".to_string(), "通信通道".to_string()],
                context: "Go Programming Language".to_string(),
                examples: vec![
                    "ch := make(chan int)".to_string(),
                    "ch <- 42 // 发送数据".to_string(),
                    "value := <-ch // 接收数据".to_string(),
                ],
                related_terms: vec!["Goroutine".to_string(), "并发".to_string()],
                confidence: 0.95,
            },
        ]
    }
}
```

### 2.3 软件架构术语导入

```rust
/// 软件架构术语导入器
pub struct SoftwareArchitectureTermImporter;

impl SoftwareArchitectureTermImporter {
    /// 导入IEEE标准术语
    pub fn import_ieee_terms() -> Vec<TermDefinition> {
        vec![
            TermDefinition {
                name: "软件架构".to_string(),
                english_name: "Software Architecture".to_string(),
                definition: "系统的基本组织，体现在其组件、组件间关系以及指导其设计和演化的原则中".to_string(),
                category: TermCategory::SoftwareArchitecture,
                source: TermSource::IndustryStandard,
                synonyms: vec!["系统架构".to_string(), "架构设计".to_string()],
                context: "IEEE 1471".to_string(),
                examples: vec![
                    "分层架构".to_string(),
                    "微服务架构".to_string(),
                    "事件驱动架构".to_string(),
                ],
                related_terms: vec!["架构组件".to_string(), "架构关系".to_string()],
                confidence: 0.95,
            },
            TermDefinition {
                name: "架构组件".to_string(),
                english_name: "Architecture Component".to_string(),
                definition: "架构中的基本构建块".to_string(),
                category: TermCategory::SoftwareArchitecture,
                source: TermSource::IndustryStandard,
                synonyms: vec!["组件".to_string(), "构建块".to_string()],
                context: "IEEE 1471".to_string(),
                examples: vec![
                    "服务组件".to_string(),
                    "数据组件".to_string(),
                    "接口组件".to_string(),
                ],
                related_terms: vec!["软件架构".to_string(), "架构关系".to_string()],
                confidence: 0.95,
            },
            TermDefinition {
                name: "架构关系".to_string(),
                english_name: "Architecture Relationship".to_string(),
                definition: "组件之间的连接和依赖关系".to_string(),
                category: TermCategory::SoftwareArchitecture,
                source: TermSource::IndustryStandard,
                synonyms: vec!["关系".to_string(), "依赖关系".to_string()],
                context: "IEEE 1471".to_string(),
                examples: vec![
                    "调用关系".to_string(),
                    "依赖关系".to_string(),
                    "组合关系".to_string(),
                ],
                related_terms: vec!["软件架构".to_string(), "架构组件".to_string()],
                confidence: 0.95,
            },
        ]
    }

    /// 导入TOGAF术语
    pub fn import_togaf_terms() -> Vec<TermDefinition> {
        vec![
            TermDefinition {
                name: "业务架构".to_string(),
                english_name: "Business Architecture".to_string(),
                definition: "描述业务战略、治理、组织和关键业务流程".to_string(),
                category: TermCategory::SoftwareArchitecture,
                source: TermSource::IndustryStandard,
                synonyms: vec!["企业架构".to_string()],
                context: "TOGAF".to_string(),
                examples: vec![
                    "业务流程建模".to_string(),
                    "组织架构".to_string(),
                ],
                related_terms: vec!["数据架构".to_string(), "应用架构".to_string()],
                confidence: 0.9,
            },
            TermDefinition {
                name: "数据架构".to_string(),
                english_name: "Data Architecture".to_string(),
                definition: "描述组织的逻辑和物理数据资产以及数据管理资源".to_string(),
                category: TermCategory::SoftwareArchitecture,
                source: TermSource::IndustryStandard,
                synonyms: vec!["信息架构".to_string()],
                context: "TOGAF".to_string(),
                examples: vec![
                    "数据模型".to_string(),
                    "数据字典".to_string(),
                ],
                related_terms: vec!["业务架构".to_string(), "应用架构".to_string()],
                confidence: 0.9,
            },
        ]
    }
}
```

## 3. 术语映射关系

### 3.1 映射关系结构

```rust
/// 术语映射关系
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TermMapping {
    /// 项目术语
    pub project_term: String,
    /// 标准术语
    pub standard_term: String,
    /// 置信度
    pub confidence: f64,
    /// 上下文
    pub context: String,
    /// 映射理由
    pub justification: String,
    /// 映射类型
    pub mapping_type: MappingType,
    /// 创建时间
    pub created_at: chrono::DateTime<chrono::Utc>,
}

/// 映射类型
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum MappingType {
    Exact,      // 精确匹配
    Synonym,    // 同义词
    Related,    // 相关术语
    Partial,    // 部分匹配
    Custom,     // 自定义映射
}

/// 术语映射管理器
pub struct TermMappingManager {
    /// 映射关系列表
    mappings: Vec<TermMapping>,
    /// 映射索引
    mapping_index: HashMap<String, Vec<TermMapping>>,
}

impl TermMappingManager {
    pub fn new() -> Self {
        Self {
            mappings: Vec::new(),
            mapping_index: HashMap::new(),
        }
    }

    /// 添加映射关系
    pub fn add_mapping(&mut self, mapping: TermMapping) -> Result<(), String> {
        // 验证映射关系
        self.validate_mapping(&mapping)?;
        
        // 添加到映射列表
        self.mappings.push(mapping.clone());
        
        // 更新索引
        self.mapping_index
            .entry(mapping.project_term.clone())
            .or_insert_with(Vec::new)
            .push(mapping.clone());
        
        self.mapping_index
            .entry(mapping.standard_term.clone())
            .or_insert_with(Vec::new)
            .push(mapping);
        
        Ok(())
    }

    /// 验证映射关系
    fn validate_mapping(&self, mapping: &TermMapping) -> Result<(), String> {
        if mapping.project_term.is_empty() {
            return Err("项目术语不能为空".to_string());
        }
        
        if mapping.standard_term.is_empty() {
            return Err("标准术语不能为空".to_string());
        }
        
        if mapping.confidence < 0.0 || mapping.confidence > 1.0 {
            return Err("置信度必须在0.0到1.0之间".to_string());
        }
        
        Ok(())
    }

    /// 查找项目术语的映射
    pub fn find_project_mappings(&self, project_term: &str) -> Vec<&TermMapping> {
        self.mapping_index
            .get(project_term)
            .map(|mappings| mappings.iter().collect())
            .unwrap_or_default()
    }

    /// 查找标准术语的映射
    pub fn find_standard_mappings(&self, standard_term: &str) -> Vec<&TermMapping> {
        self.mapping_index
            .get(standard_term)
            .map(|mappings| mappings.iter().collect())
            .unwrap_or_default()
    }

    /// 获取所有映射关系
    pub fn get_all_mappings(&self) -> &[TermMapping] {
        &self.mappings
    }

    /// 按置信度过滤映射
    pub fn filter_by_confidence(&self, min_confidence: f64) -> Vec<&TermMapping> {
        self.mappings
            .iter()
            .filter(|mapping| mapping.confidence >= min_confidence)
            .collect()
    }

    /// 按映射类型过滤
    pub fn filter_by_type(&self, mapping_type: &MappingType) -> Vec<&TermMapping> {
        self.mappings
            .iter()
            .filter(|mapping| std::mem::discriminant(&mapping.mapping_type) == std::mem::discriminant(mapping_type))
            .collect()
    }
}
```

## 4. 使用示例

### 4.1 创建和填充术语数据库

```rust
#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // 创建术语数据库
    let mut database = TerminologyDatabase::new();
    
    // 导入编程语言术语
    let rust_terms = ProgrammingLanguageTermImporter::import_rust_terms();
    for term in rust_terms {
        database.add_term(term)?;
    }
    
    let go_terms = ProgrammingLanguageTermImporter::import_go_terms();
    for term in go_terms {
        database.add_term(term)?;
    }
    
    // 导入软件架构术语
    let ieee_terms = SoftwareArchitectureTermImporter::import_ieee_terms();
    for term in ieee_terms {
        database.add_term(term)?;
    }
    
    let togaf_terms = SoftwareArchitectureTermImporter::import_togaf_terms();
    for term in togaf_terms {
        database.add_term(term)?;
    }
    
    // 尝试导入Wikipedia术语
    let wiki_importer = WikipediaTermImporter::new();
    if let Ok(wiki_terms) = wiki_importer.import_formal_methods_terms().await {
        for term in wiki_terms {
            if let Err(e) = database.add_term(term) {
                eprintln!("Failed to add Wikipedia term: {}", e);
            }
        }
    }
    
    // 创建映射管理器
    let mut mapping_manager = TermMappingManager::new();
    
    // 添加一些映射关系
    let mappings = vec![
        TermMapping {
            project_term: "所有权系统".to_string(),
            standard_term: "Ownership System".to_string(),
            confidence: 0.95,
            context: "Rust Programming".to_string(),
            justification: "直接对应Rust官方文档中的概念".to_string(),
            mapping_type: MappingType::Exact,
            created_at: chrono::Utc::now(),
        },
        TermMapping {
            project_term: "借用检查".to_string(),
            standard_term: "Borrow Checking".to_string(),
            confidence: 0.95,
            context: "Rust Programming".to_string(),
            justification: "直接对应Rust官方文档中的概念".to_string(),
            mapping_type: MappingType::Exact,
            created_at: chrono::Utc::now(),
        },
    ];
    
    for mapping in mappings {
        mapping_manager.add_mapping(mapping)?;
    }
    
    // 输出统计信息
    println!("术语数据库统计:");
    println!("- 总术语数: {}", database.term_count());
    println!("- 映射关系数: {}", mapping_manager.get_all_mappings().len());
    
    // 搜索示例
    println!("\n搜索'所有权'的结果:");
    let search_results = database.search_terms("所有权");
    for term in search_results {
        println!("- {} ({})", term.name, term.english_name);
    }
    
    // 按类别查找示例
    println!("\n编程语言类别术语:");
    let programming_terms = database.find_by_category(&TermCategory::ProgrammingLanguage);
    for term in programming_terms {
        println!("- {} ({})", term.name, term.english_name);
    }
    
    Ok(())
}
```

### 4.2 术语一致性检查

```rust
/// 术语一致性检查器
pub struct TerminologyConsistencyChecker {
    database: TerminologyDatabase,
    mapping_manager: TermMappingManager,
}

impl TerminologyConsistencyChecker {
    pub fn new(database: TerminologyDatabase, mapping_manager: TermMappingManager) -> Self {
        Self {
            database,
            mapping_manager,
        }
    }

    /// 检查文档中的术语一致性
    pub fn check_document(&self, document: &str) -> ConsistencyReport {
        let mut report = ConsistencyReport::new();
        
        // 提取文档中的术语
        let extracted_terms = self.extract_terms_from_document(document);
        
        for term in extracted_terms {
            if let Some(issue) = self.check_term(&term) {
                report.add_issue(issue);
            }
        }
        
        report
    }

    /// 从文档中提取术语
    fn extract_terms_from_document(&self, document: &str) -> Vec<String> {
        // 简单的术语提取逻辑
        let mut terms = Vec::new();
        
        // 查找数据库中的所有术语
        for term_def in self.database.get_all_terms() {
            if document.contains(&term_def.name) {
                terms.push(term_def.name.clone());
            }
            
            // 检查英文名称
            if document.contains(&term_def.english_name) {
                terms.push(term_def.english_name.clone());
            }
            
            // 检查同义词
            for synonym in &term_def.synonyms {
                if document.contains(synonym) {
                    terms.push(synonym.clone());
                }
            }
        }
        
        terms
    }

    /// 检查单个术语
    fn check_term(&self, term: &str) -> Option<ConsistencyIssue> {
        // 检查术语是否在数据库中存在
        if self.database.find_term(term).is_none() {
            return Some(ConsistencyIssue::UnknownTerm(term.to_string()));
        }
        
        // 检查是否有标准映射
        let mappings = self.mapping_manager.find_project_mappings(term);
        if mappings.is_empty() {
            return Some(ConsistencyIssue::MissingStandardMapping(term.to_string()));
        }
        
        // 检查映射的置信度
        for mapping in mappings {
            if mapping.confidence < 0.8 {
                return Some(ConsistencyIssue::LowConfidenceMapping(
                    term.to_string(),
                    mapping.confidence,
                ));
            }
        }
        
        None
    }
}

/// 一致性报告
#[derive(Debug)]
pub struct ConsistencyReport {
    issues: Vec<ConsistencyIssue>,
}

impl ConsistencyReport {
    pub fn new() -> Self {
        Self { issues: Vec::new() }
    }

    pub fn add_issue(&mut self, issue: ConsistencyIssue) {
        self.issues.push(issue);
    }

    pub fn get_issues(&self) -> &[ConsistencyIssue] {
        &self.issues
    }

    pub fn is_consistent(&self) -> bool {
        self.issues.is_empty()
    }
}

/// 一致性问题
#[derive(Debug)]
pub enum ConsistencyIssue {
    UnknownTerm(String),
    MissingStandardMapping(String),
    LowConfidenceMapping(String, f64),
    InconsistentDefinition(String, String),
}
```

## 5. 总结

本文档实现了完整的术语数据库系统，包括：

1. **核心数据结构**：术语定义、数据库结构、标准引用等
2. **术语导入器**：支持从Wikipedia、官方文档、行业标准导入术语
3. **映射关系管理**：建立项目术语与标准术语的映射关系
4. **一致性检查**：自动检查文档中的术语使用一致性

这个实现为项目的术语统一工作提供了坚实的基础，确保所有概念定义、解释论证和语义都与国际Wiki和学术标准保持一致。
