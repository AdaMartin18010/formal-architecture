# 02-状态机理论

## 目录

1. [1.0 状态机基础](#10-状态机基础)
2. [2.0 有限状态机](#20-有限状态机)
3. [3.0 下推自动机](#30-下推自动机)
4. [4.0 图灵机](#40-图灵机)
5. [5.0 状态机验证](#50-状态机验证)
6. [6.0 实践应用](#60-实践应用)

## 1.0 状态机基础

### 1.1 状态机定义

**定义 1.1.1 (状态机)**
状态机是一个五元组 $\mathcal{SM} = (Q, \Sigma, \delta, q_0, F)$，其中：

- $Q$ 是状态集合
- $\Sigma$ 是输入字母表
- $\delta: Q \times \Sigma \to Q$ 是转移函数
- $q_0 \in Q$ 是初始状态
- $F \subseteq Q$ 是接受状态集合

**定义 1.1.2 (配置)**
状态机配置是一个二元组 $(q, w)$，其中 $q \in Q$ 是当前状态，$w \in \Sigma^*$ 是剩余输入。

### 1.2 计算关系

**定义 1.2.1 (一步计算)**
一步计算关系 $\vdash$ 定义为：

$$(q, aw) \vdash (q', w) \text{ 当且仅当 } \delta(q, a) = q'$$

**定义 1.2.2 (多步计算)**
多步计算关系 $\vdash^*$ 是 $\vdash$ 的自反传递闭包。

## 2.0 有限状态机

### 2.1 确定性有限状态机

**定义 2.1.1 (DFA)**
确定性有限自动机是一个五元组 $M = (Q, \Sigma, \delta, q_0, F)$，其中：

- $\delta: Q \times \Sigma \to Q$ 是确定性转移函数

**定理 2.1.1 (DFA等价性)**
对于任意正则语言 $L$，存在DFA $M$ 使得 $L(M) = L$。

### 2.2 非确定性有限状态机

**定义 2.2.1 (NFA)**
非确定性有限自动机是一个五元组 $M = (Q, \Sigma, \delta, q_0, F)$，其中：

- $\delta: Q \times \Sigma \to 2^Q$ 是非确定性转移函数

**定理 2.2.1 (NFA到DFA转换)**
对于任意NFA $N$，存在DFA $D$ 使得 $L(N) = L(D)$。

### 2.3 实现示例

```rust
pub struct FiniteStateMachine {
    states: Vec<State>,
    alphabet: Vec<char>,
    transitions: HashMap<(State, char), State>,
    initial_state: State,
    accepting_states: HashSet<State>,
}

impl FiniteStateMachine {
    pub fn new() -> Self {
        Self {
            states: Vec::new(),
            alphabet: Vec::new(),
            transitions: HashMap::new(),
            initial_state: 0,
            accepting_states: HashSet::new(),
        }
    }
    
    pub fn add_state(&mut self, state: State) {
        self.states.push(state);
    }
    
    pub fn add_transition(&mut self, from: State, input: char, to: State) {
        self.transitions.insert((from, input), to);
    }
    
    pub fn set_accepting(&mut self, state: State) {
        self.accepting_states.insert(state);
    }
    
    pub fn accepts(&self, input: &str) -> bool {
        let mut current_state = self.initial_state;
        
        for c in input.chars() {
            if let Some(&next_state) = self.transitions.get(&(current_state, c)) {
                current_state = next_state;
            } else {
                return false;
            }
        }
        
        self.accepting_states.contains(&current_state)
    }
    
    pub fn minimize(&self) -> FiniteStateMachine {
        // Hopcroft算法实现最小化
        let mut partitions = self.initial_partition();
        
        loop {
            let new_partitions = self.refine_partitions(&partitions);
            if new_partitions.len() == partitions.len() {
                break;
            }
            partitions = new_partitions;
        }
        
        self.build_minimized_machine(&partitions)
    }
    
    fn initial_partition(&self) -> Vec<HashSet<State>> {
        let mut accepting = HashSet::new();
        let mut non_accepting = HashSet::new();
        
        for state in &self.states {
            if self.accepting_states.contains(state) {
                accepting.insert(*state);
            } else {
                non_accepting.insert(*state);
            }
        }
        
        vec![accepting, non_accepting]
    }
    
    fn refine_partitions(&self, partitions: &[HashSet<State>]) -> Vec<HashSet<State>> {
        let mut new_partitions = Vec::new();
        
        for partition in partitions {
            if partition.len() <= 1 {
                new_partitions.push(partition.clone());
                continue;
            }
            
            let mut refined = self.refine_partition(partition);
            new_partitions.extend(refined);
        }
        
        new_partitions
    }
    
    fn refine_partition(&self, partition: &HashSet<State>) -> Vec<HashSet<State>> {
        let mut groups = HashMap::new();
        
        for &state in partition {
            let signature = self.get_state_signature(state);
            groups.entry(signature).or_insert_with(HashSet::new).insert(state);
        }
        
        groups.into_values().collect()
    }
    
    fn get_state_signature(&self, state: State) -> Vec<Option<usize>> {
        let mut signature = Vec::new();
        
        for c in &self.alphabet {
            if let Some(&next_state) = self.transitions.get(&(state, *c)) {
                let partition_index = self.get_partition_index(next_state);
                signature.push(Some(partition_index));
            } else {
                signature.push(None);
            }
        }
        
        signature
    }
}
```

## 3.0 下推自动机

### 3.1 下推自动机定义

**定义 3.1.1 (PDA)**
下推自动机是一个七元组 $M = (Q, \Sigma, \Gamma, \delta, q_0, Z_0, F)$，其中：

- $Q$ 是状态集合
- $\Sigma$ 是输入字母表
- $\Gamma$ 是栈字母表
- $\delta: Q \times \Sigma \times \Gamma \to 2^{Q \times \Gamma^*}$ 是转移函数
- $q_0 \in Q$ 是初始状态
- $Z_0 \in \Gamma$ 是初始栈符号
- $F \subseteq Q$ 是接受状态集合

### 3.2 PDA配置

**定义 3.2.1 (PDA配置)**
PDA配置是一个三元组 $(q, w, \gamma)$，其中：

- $q \in Q$ 是当前状态
- $w \in \Sigma^*$ 是剩余输入
- $\gamma \in \Gamma^*$ 是栈内容

### 3.3 实现示例

```rust
pub struct PushdownAutomaton {
    states: Vec<State>,
    input_alphabet: Vec<char>,
    stack_alphabet: Vec<char>,
    transitions: HashMap<(State, char, char), Vec<(State, String)>>,
    initial_state: State,
    initial_stack_symbol: char,
    accepting_states: HashSet<State>,
}

impl PushdownAutomaton {
    pub fn new() -> Self {
        Self {
            states: Vec::new(),
            input_alphabet: Vec::new(),
            stack_alphabet: Vec::new(),
            transitions: HashMap::new(),
            initial_state: 0,
            initial_stack_symbol: 'Z',
            accepting_states: HashSet::new(),
        }
    }
    
    pub fn add_transition(&mut self, from: State, input: char, stack_top: char, 
                         to: State, stack_push: String) {
        let key = (from, input, stack_top);
        self.transitions.entry(key)
            .or_insert_with(Vec::new)
            .push((to, stack_push));
    }
    
    pub fn accepts(&self, input: &str) -> bool {
        let initial_config = Configuration {
            state: self.initial_state,
            input: input.chars().collect(),
            stack: vec![self.initial_stack_symbol],
        };
        
        self.accepts_from_config(initial_config)
    }
    
    fn accepts_from_config(&self, config: Configuration) -> bool {
        if config.input.is_empty() {
            return self.accepting_states.contains(&config.state);
        }
        
        let current_input = config.input[0];
        let current_stack_top = config.stack.last().unwrap_or(&'Z');
        
        let key = (config.state, current_input, *current_stack_top);
        
        if let Some(transitions) = self.transitions.get(&key) {
            for (next_state, stack_push) in transitions {
                let mut new_stack = config.stack.clone();
                new_stack.pop(); // 移除栈顶
                
                // 压入新符号
                for c in stack_push.chars().rev() {
                    new_stack.push(c);
                }
                
                let new_config = Configuration {
                    state: *next_state,
                    input: config.input[1..].to_vec(),
                    stack: new_stack,
                };
                
                if self.accepts_from_config(new_config) {
                    return true;
                }
            }
        }
        
        false
    }
}

pub struct Configuration {
    state: State,
    input: Vec<char>,
    stack: Vec<char>,
}
```

## 4.0 图灵机

### 4.1 图灵机定义

**定义 4.1.1 (图灵机)**
图灵机是一个七元组 $M = (Q, \Sigma, \Gamma, \delta, q_0, B, F)$，其中：

- $Q$ 是状态集合
- $\Sigma$ 是输入字母表
- $\Gamma$ 是磁带字母表
- $\delta: Q \times \Gamma \to Q \times \Gamma \times \{L, R\}$ 是转移函数
- $q_0 \in Q$ 是初始状态
- $B \in \Gamma$ 是空白符号
- $F \subseteq Q$ 是接受状态集合

### 4.2 图灵机配置

**定义 4.2.1 (图灵机配置)**
图灵机配置是一个三元组 $(q, w, i)$，其中：

- $q \in Q$ 是当前状态
- $w \in \Gamma^*$ 是磁带内容
- $i \in \mathbb{N}$ 是读写头位置

### 4.3 实现示例

```rust
pub struct TuringMachine {
    states: Vec<State>,
    input_alphabet: Vec<char>,
    tape_alphabet: Vec<char>,
    transitions: HashMap<(State, char), (State, char, Direction)>,
    initial_state: State,
    blank_symbol: char,
    accepting_states: HashSet<State>,
}

impl TuringMachine {
    pub fn new() -> Self {
        Self {
            states: Vec::new(),
            input_alphabet: Vec::new(),
            tape_alphabet: Vec::new(),
            transitions: HashMap::new(),
            initial_state: 0,
            blank_symbol: 'B',
            accepting_states: HashSet::new(),
        }
    }
    
    pub fn add_transition(&mut self, from: State, read: char, 
                         to: State, write: char, direction: Direction) {
        self.transitions.insert((from, read), (to, write, direction));
    }
    
    pub fn run(&self, input: &str) -> Option<String> {
        let mut tape = input.chars().collect::<Vec<char>>();
        let mut state = self.initial_state;
        let mut head = 0;
        
        let mut steps = 0;
        let max_steps = 10000; // 防止无限循环
        
        while steps < max_steps {
            if self.accepting_states.contains(&state) {
                return Some(tape.iter().collect());
            }
            
            let current_symbol = if head < tape.len() {
                tape[head]
            } else {
                self.blank_symbol
            };
            
            let key = (state, current_symbol);
            if let Some(&(next_state, write_symbol, direction)) = self.transitions.get(&key) {
                // 写入符号
                if head < tape.len() {
                    tape[head] = write_symbol;
                } else {
                    tape.push(write_symbol);
                }
                
                // 移动读写头
                match direction {
                    Direction::Left => {
                        if head > 0 {
                            head -= 1;
                        }
                    }
                    Direction::Right => {
                        head += 1;
                        if head >= tape.len() {
                            tape.push(self.blank_symbol);
                        }
                    }
                }
                
                state = next_state;
            } else {
                // 停机
                break;
            }
            
            steps += 1;
        }
        
        None
    }
}

pub enum Direction {
    Left,
    Right,
}
```

## 5.0 状态机验证

### 5.1 等价性检查

**算法 5.1.1 (状态机等价性检查)**:

```rust
pub struct StateMachineVerifier {
    machine1: FiniteStateMachine,
    machine2: FiniteStateMachine,
}

impl StateMachineVerifier {
    pub fn new(machine1: FiniteStateMachine, machine2: FiniteStateMachine) -> Self {
        Self { machine1, machine2 }
    }
    
    pub fn are_equivalent(&self) -> bool {
        // 使用双模拟检查等价性
        let mut visited = HashSet::new();
        let mut queue = VecDeque::new();
        
        let initial_pair = (self.machine1.initial_state, self.machine2.initial_state);
        queue.push_back(initial_pair);
        visited.insert(initial_pair);
        
        while let Some((state1, state2)) = queue.pop_front() {
            // 检查接受状态一致性
            let accepting1 = self.machine1.accepting_states.contains(&state1);
            let accepting2 = self.machine2.accepting_states.contains(&state2);
            
            if accepting1 != accepting2 {
                return false;
            }
            
            // 检查转移一致性
            for c in &self.machine1.alphabet {
                let next1 = self.machine1.transitions.get(&(state1, *c));
                let next2 = self.machine2.transitions.get(&(state2, *c));
                
                if let (Some(&next_state1), Some(&next_state2)) = (next1, next2) {
                    let next_pair = (next_state1, next_state2);
                    if !visited.contains(&next_pair) {
                        visited.insert(next_pair);
                        queue.push_back(next_pair);
                    }
                } else if next1.is_some() != next2.is_some() {
                    return false;
                }
            }
        }
        
        true
    }
}
```

### 5.2 可达性分析

**算法 5.2.1 (可达性分析)**:

```rust
pub struct ReachabilityAnalyzer {
    machine: FiniteStateMachine,
}

impl ReachabilityAnalyzer {
    pub fn new(machine: FiniteStateMachine) -> Self {
        Self { machine }
    }
    
    pub fn analyze_reachability(&self) -> ReachabilityResult {
        let mut reachable_states = HashSet::new();
        let mut queue = VecDeque::new();
        
        queue.push_back(self.machine.initial_state);
        reachable_states.insert(self.machine.initial_state);
        
        while let Some(state) = queue.pop_front() {
            for c in &self.machine.alphabet {
                if let Some(&next_state) = self.machine.transitions.get(&(state, *c)) {
                    if !reachable_states.contains(&next_state) {
                        reachable_states.insert(next_state);
                        queue.push_back(next_state);
                    }
                }
            }
        }
        
        let unreachable_states: Vec<_> = self.machine.states.iter()
            .filter(|s| !reachable_states.contains(s))
            .cloned()
            .collect();
        
        ReachabilityResult {
            reachable_states,
            unreachable_states,
        }
    }
    
    pub fn find_dead_states(&self) -> Vec<State> {
        let mut dead_states = Vec::new();
        
        for &state in &self.machine.states {
            if !self.can_reach_accepting_state(state) {
                dead_states.push(state);
            }
        }
        
        dead_states
    }
    
    fn can_reach_accepting_state(&self, start_state: State) -> bool {
        let mut visited = HashSet::new();
        let mut stack = vec![start_state];
        
        while let Some(state) = stack.pop() {
            if self.machine.accepting_states.contains(&state) {
                return true;
            }
            
            if visited.contains(&state) {
                continue;
            }
            
            visited.insert(state);
            
            for c in &self.machine.alphabet {
                if let Some(&next_state) = self.machine.transitions.get(&(state, *c)) {
                    stack.push(next_state);
                }
            }
        }
        
        false
    }
}
```

## 6.0 实践应用

### 6.1 词法分析器

```rust
pub struct LexicalAnalyzer {
    automaton: FiniteStateMachine,
    token_patterns: HashMap<String, TokenType>,
}

impl LexicalAnalyzer {
    pub fn new() -> Self {
        let mut analyzer = Self {
            automaton: FiniteStateMachine::new(),
            token_patterns: HashMap::new(),
        };
        
        analyzer.build_automaton();
        analyzer
    }
    
    fn build_automaton(&mut self) {
        // 构建识别各种token的自动机
        self.add_identifier_pattern();
        self.add_number_pattern();
        self.add_string_pattern();
        self.add_operator_pattern();
    }
    
    fn add_identifier_pattern(&mut self) {
        // 标识符模式：字母开头，后跟字母或数字
        let start_state = self.automaton.add_state();
        let letter_state = self.automaton.add_state();
        let final_state = self.automaton.add_state();
        
        // 转移
        for c in 'a'..='z' {
            self.automaton.add_transition(start_state, c, letter_state);
            self.automaton.add_transition(letter_state, c, letter_state);
        }
        
        for c in '0'..='9' {
            self.automaton.add_transition(letter_state, c, letter_state);
        }
        
        self.automaton.set_accepting(letter_state);
        self.token_patterns.insert("identifier".to_string(), TokenType::Identifier);
    }
    
    pub fn tokenize(&self, input: &str) -> Vec<Token> {
        let mut tokens = Vec::new();
        let mut current_pos = 0;
        
        while current_pos < input.len() {
            let (token, length) = self.scan_token(&input[current_pos..]);
            tokens.push(token);
            current_pos += length;
        }
        
        tokens
    }
    
    fn scan_token(&self, input: &str) -> (Token, usize) {
        let mut current_state = self.automaton.initial_state;
        let mut last_accepting_state = None;
        let mut last_accepting_pos = 0;
        let mut current_pos = 0;
        
        for (i, c) in input.chars().enumerate() {
            if let Some(&next_state) = self.automaton.transitions.get(&(current_state, c)) {
                current_state = next_state;
                current_pos = i + 1;
                
                if self.automaton.accepting_states.contains(&current_state) {
                    last_accepting_state = Some(current_state);
                    last_accepting_pos = current_pos;
                }
            } else {
                break;
            }
        }
        
        if let Some(accepting_state) = last_accepting_state {
            let lexeme = &input[..last_accepting_pos];
            let token_type = self.get_token_type(accepting_state);
            (Token::new(token_type, lexeme.to_string()), last_accepting_pos)
        } else {
            // 错误处理
            (Token::new(TokenType::Error, input[..1].to_string()), 1)
        }
    }
}

pub enum TokenType {
    Identifier,
    Number,
    String,
    Operator,
    Error,
}

pub struct Token {
    token_type: TokenType,
    lexeme: String,
}
```

### 6.2 协议验证器

```rust
pub struct ProtocolVerifier {
    protocol: StateMachine,
    properties: Vec<Property>,
}

impl ProtocolVerifier {
    pub fn new(protocol: StateMachine) -> Self {
        Self {
            protocol,
            properties: Vec::new(),
        }
    }
    
    pub fn add_property(&mut self, property: Property) {
        self.properties.push(property);
    }
    
    pub fn verify_protocol(&self) -> VerificationResult {
        let mut results = Vec::new();
        
        for property in &self.properties {
            let result = self.verify_property(property);
            results.push(result);
        }
        
        VerificationResult { results }
    }
    
    fn verify_property(&self, property: &Property) -> PropertyResult {
        match property {
            Property::Safety(safety_prop) => self.verify_safety_property(safety_prop),
            Property::Liveness(liveness_prop) => self.verify_liveness_property(liveness_prop),
            Property::Invariant(invariant) => self.verify_invariant(invariant),
        }
    }
    
    fn verify_safety_property(&self, property: &SafetyProperty) -> PropertyResult {
        let mut visited = HashSet::new();
        let mut stack = vec![self.protocol.initial_state];
        
        while let Some(state) = stack.pop() {
            if !visited.contains(&state) {
                visited.insert(state);
                
                if !property.check(&state) {
                    return PropertyResult::Violated {
                        property: Property::Safety(property.clone()),
                        counterexample: self.generate_counterexample(&state),
                    };
                }
                
                for next_state in self.protocol.get_successors(&state) {
                    stack.push(next_state);
                }
            }
        }
        
        PropertyResult::Satisfied {
            property: Property::Safety(property.clone()),
        }
    }
}
```

## 总结

本状态机理论建立了完整的形式化框架，包括：

1. **理论基础**：状态机定义、配置、计算关系
2. **有限状态机**：DFA、NFA、最小化算法
3. **下推自动机**：PDA定义、配置、实现
4. **图灵机**：图灵机定义、配置、实现
5. **状态机验证**：等价性检查、可达性分析
6. **实践应用**：词法分析器、协议验证器

该理论体系具有以下特点：

- **形式化程度高**：使用严格的数学定义和证明
- **理论完备**：涵盖经典自动机理论
- **实用性强**：提供具体的实现和工具
- **验证完备**：提供完整的状态机验证方法
- **可扩展性好**：支持新状态机模型的加入

下一步将继续完善其他理论模块，建立完整的应用体系。
