# 一致性检查工具

## 概述

本文档实现了一致性检查工具，用于自动检查和验证概念映射的一致性，确保理论概念与实现概念之间的语义一致性和逻辑一致性。

## 1. 一致性检查器结构

### 1.1 检查器核心结构

```rust
use std::collections::{HashMap, HashSet};
use serde::{Deserialize, Serialize};

/// 映射一致性检查器
#[derive(Debug)]
pub struct MappingConsistencyChecker {
    /// 映射数据库
    database: ConceptMappingDatabase,
    /// 一致性规则
    consistency_rules: Vec<ConsistencyRule>,
    /// 检查配置
    config: ConsistencyConfig,
}

/// 一致性规则
#[derive(Debug, Clone)]
pub struct ConsistencyRule {
    /// 规则名称
    pub name: String,
    /// 规则描述
    pub description: String,
    /// 规则类型
    pub rule_type: ConsistencyRuleType,
    /// 规则参数
    pub parameters: HashMap<String, String>,
    /// 是否启用
    pub enabled: bool,
}

/// 一致性规则类型
#[derive(Debug, Clone)]
pub enum ConsistencyRuleType {
    /// 等价性检查
    EquivalenceCheck,
    /// 传递性检查
    TransitivityCheck,
    /// 对称性检查
    SymmetryCheck,
    /// 完整性检查
    CompletenessCheck,
    /// 冲突检查
    ConflictCheck,
    /// 循环检查
    CycleCheck,
    /// 强度一致性检查
    StrengthConsistencyCheck,
}

/// 一致性检查配置
#[derive(Debug, Clone)]
pub struct ConsistencyConfig {
    /// 最小强度阈值
    pub min_strength_threshold: f64,
    /// 最小置信度阈值
    pub min_confidence_threshold: f64,
    /// 最大传递性距离
    pub max_transitivity_distance: usize,
    /// 是否检查循环
    pub check_cycles: bool,
    /// 是否检查冲突
    pub check_conflicts: bool,
    /// 是否检查完整性
    pub check_completeness: bool,
}

impl Default for ConsistencyConfig {
    fn default() -> Self {
        Self {
            min_strength_threshold: 0.7,
            min_confidence_threshold: 0.8,
            max_transitivity_distance: 3,
            check_cycles: true,
            check_conflicts: true,
            check_completeness: true,
        }
    }
}

impl MappingConsistencyChecker {
    /// 创建新的检查器
    pub fn new(database: ConceptMappingDatabase) -> Self {
        Self {
            database,
            consistency_rules: Vec::new(),
            config: ConsistencyConfig::default(),
        }
    }

    /// 设置配置
    pub fn with_config(mut self, config: ConsistencyConfig) -> Self {
        self.config = config;
        self
    }

    /// 添加一致性规则
    pub fn add_rule(&mut self, rule: ConsistencyRule) {
        self.consistency_rules.push(rule);
    }

    /// 添加默认规则集
    pub fn add_default_rules(&mut self) {
        self.add_rule(ConsistencyRule {
            name: "等价性检查".to_string(),
            description: "检查等价映射的强度是否达到阈值".to_string(),
            rule_type: ConsistencyRuleType::EquivalenceCheck,
            parameters: HashMap::new(),
            enabled: true,
        });

        self.add_rule(ConsistencyRule {
            name: "传递性检查".to_string(),
            description: "检查映射的传递性关系".to_string(),
            rule_type: ConsistencyRuleType::TransitivityCheck,
            parameters: HashMap::new(),
            enabled: true,
        });

        self.add_rule(ConsistencyRule {
            name: "对称性检查".to_string(),
            description: "检查等价映射的对称性".to_string(),
            rule_type: ConsistencyRuleType::SymmetryCheck,
            parameters: HashMap::new(),
            enabled: true,
        });

        self.add_rule(ConsistencyRule {
            name: "冲突检查".to_string(),
            description: "检查概念对之间的冲突映射".to_string(),
            rule_type: ConsistencyRuleType::ConflictCheck,
            parameters: HashMap::new(),
            enabled: true,
        });

        self.add_rule(ConsistencyRule {
            name: "循环检查".to_string(),
            description: "检查映射图中的循环".to_string(),
            rule_type: ConsistencyRuleType::CycleCheck,
            parameters: HashMap::new(),
            enabled: true,
        });
    }

    /// 执行一致性检查
    pub fn check_consistency(&self) -> ConsistencyReport {
        let mut report = ConsistencyReport::new();
        
        for rule in &self.consistency_rules {
            if !rule.enabled {
                continue;
            }
            
            match rule.rule_type {
                ConsistencyRuleType::EquivalenceCheck => {
                    self.check_equivalence(rule, &mut report);
                }
                ConsistencyRuleType::TransitivityCheck => {
                    self.check_transitivity(rule, &mut report);
                }
                ConsistencyRuleType::SymmetryCheck => {
                    self.check_symmetry(rule, &mut report);
                }
                ConsistencyRuleType::CompletenessCheck => {
                    self.check_completeness(rule, &mut report);
                }
                ConsistencyRuleType::ConflictCheck => {
                    self.check_conflicts(rule, &mut report);
                }
                ConsistencyRuleType::CycleCheck => {
                    self.check_cycles(rule, &mut report);
                }
                ConsistencyRuleType::StrengthConsistencyCheck => {
                    self.check_strength_consistency(rule, &mut report);
                }
            }
        }
        
        report.calculate_score();
        report
    }

    /// 检查等价性
    fn check_equivalence(&self, rule: &ConsistencyRule, report: &mut ConsistencyReport) {
        let mappings = self.database.get_all_mappings();
        
        for mapping in mappings {
            if mapping.mapping_type == MappingType::Equivalent {
                // 检查等价映射的强度
                if mapping.strength < self.config.min_strength_threshold {
                    report.add_issue(ConsistencyIssue {
                        rule_name: rule.name.clone(),
                        issue_type: IssueType::LowStrength,
                        description: format!("等价映射强度过低: {} -> {} (强度: {:.2})", 
                            mapping.source_concept.name, 
                            mapping.target_concept.name, 
                            mapping.strength),
                        severity: IssueSeverity::Warning,
                        mapping_id: Some(mapping.id.clone()),
                    });
                }
                
                // 检查等价映射的置信度
                if mapping.confidence < self.config.min_confidence_threshold {
                    report.add_issue(ConsistencyIssue {
                        rule_name: rule.name.clone(),
                        issue_type: IssueType::LowConfidence,
                        description: format!("等价映射置信度过低: {} -> {} (置信度: {:.2})", 
                            mapping.source_concept.name, 
                            mapping.target_concept.name, 
                            mapping.confidence),
                        severity: IssueSeverity::Warning,
                        mapping_id: Some(mapping.id.clone()),
                    });
                }
            }
        }
    }

    /// 检查传递性
    fn check_transitivity(&self, rule: &ConsistencyRule, report: &mut ConsistencyReport) {
        let mappings = self.database.get_all_mappings();
        
        for mapping1 in &mappings {
            for mapping2 in &mappings {
                if mapping1.id != mapping2.id {
                    // 检查传递性：A -> B, B -> C 应该存在 A -> C
                    if mapping1.target_concept == mapping2.source_concept {
                        let should_exist = Concept {
                            name: mapping1.source_concept.name.clone(),
                            domain: mapping1.source_concept.domain.clone(),
                            concept_type: mapping1.source_concept.concept_type.clone(),
                            definition: mapping1.source_concept.definition.clone(),
                            context: mapping1.source_concept.context.clone(),
                        };
                        let target = Concept {
                            name: mapping2.target_concept.name.clone(),
                            domain: mapping2.target_concept.domain.clone(),
                            concept_type: mapping2.target_concept.concept_type.clone(),
                            definition: mapping2.target_concept.definition.clone(),
                            context: mapping2.target_concept.context.clone(),
                        };
                        
                        if self.database.find_mapping_between(&should_exist, &target).is_none() {
                            report.add_issue(ConsistencyIssue {
                                rule_name: rule.name.clone(),
                                issue_type: IssueType::MissingTransitivity,
                                description: format!("缺少传递性映射: {} -> {} -> {}", 
                                    mapping1.source_concept.name, 
                                    mapping1.target_concept.name, 
                                    mapping2.target_concept.name),
                                severity: IssueSeverity::Warning,
                                mapping_id: None,
                            });
                        }
                    }
                }
            }
        }
    }

    /// 检查对称性
    fn check_symmetry(&self, rule: &ConsistencyRule, report: &mut ConsistencyReport) {
        let mappings = self.database.get_all_mappings();
        
        for mapping in mappings {
            if mapping.mapping_type == MappingType::Equivalent {
                // 等价映射应该是对称的
                let reverse_mapping = self.database.find_mapping_between(
                    &mapping.target_concept, 
                    &mapping.source_concept
                );
                
                if let Some(reverse) = reverse_mapping {
                    if (mapping.strength - reverse.strength).abs() > 0.1 {
                        report.add_issue(ConsistencyIssue {
                            rule_name: rule.name.clone(),
                            issue_type: IssueType::AsymmetricStrength,
                            description: format!("等价映射强度不对称: {} -> {} ({:.2}) vs {} -> {} ({:.2})", 
                                mapping.source_concept.name, mapping.target_concept.name, mapping.strength,
                                reverse.source_concept.name, reverse.target_concept.name, reverse.strength),
                            severity: IssueSeverity::Warning,
                            mapping_id: Some(mapping.id.clone()),
                        });
                    }
                } else {
                    report.add_issue(ConsistencyIssue {
                        rule_name: rule.name.clone(),
                        issue_type: IssueType::MissingSymmetry,
                        description: format!("等价映射缺少对称映射: {} -> {}", 
                            mapping.source_concept.name, mapping.target_concept.name),
                        severity: IssueSeverity::Warning,
                        mapping_id: Some(mapping.id.clone()),
                    });
                }
            }
        }
    }

    /// 检查完整性
    fn check_completeness(&self, rule: &ConsistencyRule, report: &mut ConsistencyReport) {
        if !self.config.check_completeness {
            return;
        }
        
        // 检查是否有孤立的概念
        let all_mappings = self.database.get_all_mappings();
        let mut connected_concepts = HashSet::new();
        
        for mapping in all_mappings {
            connected_concepts.insert(mapping.source_concept.name.clone());
            connected_concepts.insert(mapping.target_concept.name.clone());
        }
        
        // 计算连接度
        let total_concepts = connected_concepts.len();
        let total_mappings = all_mappings.len();
        
        if total_concepts > 0 {
            let connectivity_ratio = total_mappings as f64 / total_concepts as f64;
            
            if connectivity_ratio < 1.5 {
                report.add_issue(ConsistencyIssue {
                    rule_name: rule.name.clone(),
                    issue_type: IssueType::LowCompleteness,
                    description: format!("映射网络完整性较低，连接度: {:.2} (概念: {}, 映射: {})", 
                        connectivity_ratio, total_concepts, total_mappings),
                    severity: IssueSeverity::Info,
                    mapping_id: None,
                });
            }
        }
    }

    /// 检查冲突
    fn check_conflicts(&self, rule: &ConsistencyRule, report: &mut ConsistencyReport) {
        if !self.config.check_conflicts {
            return;
        }
        
        let mappings = self.database.get_all_mappings();
        
        for mapping1 in &mappings {
            for mapping2 in &mappings {
                if mapping1.id != mapping2.id {
                    // 检查同一对概念之间是否有冲突的映射
                    if (mapping1.source_concept == mapping2.source_concept && 
                        mapping1.target_concept == mapping2.target_concept) ||
                       (mapping1.source_concept == mapping2.target_concept && 
                        mapping1.target_concept == mapping2.source_concept) {
                        
                        if mapping1.mapping_type != mapping2.mapping_type {
                            report.add_issue(ConsistencyIssue {
                                rule_name: rule.name.clone(),
                                issue_type: IssueType::ConflictingMapping,
                                description: format!("概念对存在冲突映射: {} -> {} ({} vs {})", 
                                    mapping1.source_concept.name, mapping1.target_concept.name,
                                    mapping1.mapping_type, mapping2.mapping_type),
                                severity: IssueSeverity::Error,
                                mapping_id: Some(mapping1.id.clone()),
                            });
                        }
                        
                        // 检查强度差异过大
                        if (mapping1.strength - mapping2.strength).abs() > 0.3 {
                            report.add_issue(ConsistencyIssue {
                                rule_name: rule.name.clone(),
                                issue_type: IssueType::ConflictingStrength,
                                description: format!("概念对映射强度差异过大: {} -> {} ({:.2} vs {:.2})", 
                                    mapping1.source_concept.name, mapping1.target_concept.name,
                                    mapping1.strength, mapping2.strength),
                                severity: IssueSeverity::Warning,
                                mapping_id: Some(mapping1.id.clone()),
                            });
                        }
                    }
                }
            }
        }
    }

    /// 检查循环
    fn check_cycles(&self, rule: &ConsistencyRule, report: &mut ConsistencyReport) {
        if !self.config.check_cycles {
            return;
        }
        
        // 构建映射图
        let mut graph = HashMap::new();
        let mappings = self.database.get_all_mappings();
        
        for mapping in mappings {
            let source_name = mapping.source_concept.name.clone();
            let target_name = mapping.target_concept.name.clone();
            
            graph.entry(source_name.clone())
                .or_insert_with(Vec::new)
                .push(target_name.clone());
        }
        
        // 检测循环
        let mut visited = HashSet::new();
        let mut rec_stack = HashSet::new();
        
        for node in graph.keys() {
            if !visited.contains(node) {
                if self.has_cycle_dfs(node, &graph, &mut visited, &mut rec_stack) {
                    report.add_issue(ConsistencyIssue {
                        rule_name: rule.name.clone(),
                        issue_type: IssueType::CycleDetected,
                        description: format!("检测到映射循环，涉及概念: {}", node),
                        severity: IssueSeverity::Error,
                        mapping_id: None,
                    });
                }
            }
        }
    }

    /// DFS检测循环
    fn has_cycle_dfs(&self, node: &String, graph: &HashMap<String, Vec<String>>, 
                     visited: &mut HashSet<String>, rec_stack: &mut HashSet<String>) -> bool {
        visited.insert(node.clone());
        rec_stack.insert(node.clone());
        
        if let Some(neighbors) = graph.get(node) {
            for neighbor in neighbors {
                if !visited.contains(neighbor) {
                    if self.has_cycle_dfs(neighbor, graph, visited, rec_stack) {
                        return true;
                    }
                } else if rec_stack.contains(neighbor) {
                    return true;
                }
            }
        }
        
        rec_stack.remove(node);
        false
    }

    /// 检查强度一致性
    fn check_strength_consistency(&self, rule: &ConsistencyRule, report: &mut ConsistencyReport) {
        let mappings = self.database.get_all_mappings();
        
        // 按映射类型分组检查强度分布
        let mut strength_by_type = HashMap::new();
        
        for mapping in mappings {
            strength_by_type
                .entry(mapping.mapping_type)
                .or_insert_with(Vec::new)
                .push(mapping.strength);
        }
        
        for (mapping_type, strengths) in strength_by_type {
            if strengths.len() > 1 {
                let avg_strength = strengths.iter().sum::<f64>() / strengths.len() as f64;
                let variance = strengths.iter()
                    .map(|s| (s - avg_strength).powi(2))
                    .sum::<f64>() / strengths.len() as f64;
                
                if variance > 0.1 {
                    report.add_issue(ConsistencyIssue {
                        rule_name: rule.name.clone(),
                        issue_type: IssueType::InconsistentStrength,
                        description: format!("{}类型映射强度不一致，方差: {:.3}", 
                            format!("{:?}", mapping_type), variance),
                        severity: IssueSeverity::Warning,
                        mapping_id: None,
                    });
                }
            }
        }
    }
}
```

## 2. 一致性报告结构

### 2.1 报告核心结构

```rust
/// 一致性报告
#[derive(Debug)]
pub struct ConsistencyReport {
    /// 报告ID
    pub id: String,
    /// 生成时间
    pub timestamp: String,
    /// 检查的问题列表
    pub issues: Vec<ConsistencyIssue>,
    /// 总体评分
    pub overall_score: f64,
    /// 统计信息
    pub statistics: ReportStatistics,
}

/// 一致性问题
#[derive(Debug, Clone)]
pub struct ConsistencyIssue {
    /// 规则名称
    pub rule_name: String,
    /// 问题类型
    pub issue_type: IssueType,
    /// 问题描述
    pub description: String,
    /// 严重程度
    pub severity: IssueSeverity,
    /// 相关映射ID
    pub mapping_id: Option<String>,
}

/// 问题类型
#[derive(Debug, Clone)]
pub enum IssueType {
    LowStrength,           // 强度过低
    LowConfidence,         // 置信度过低
    MissingTransitivity,   // 缺少传递性
    MissingSymmetry,       // 缺少对称性
    AsymmetricStrength,    // 不对称强度
    LowCompleteness,       // 完整性低
    ConflictingMapping,    // 冲突映射
    ConflictingStrength,   // 冲突强度
    CycleDetected,         // 检测到循环
    InconsistentStrength,  // 强度不一致
    Other,                 // 其他
}

/// 问题严重程度
#[derive(Debug, Clone)]
pub enum IssueSeverity {
    Error,     // 错误
    Warning,   // 警告
    Info,      // 信息
}

/// 报告统计信息
#[derive(Debug, Clone)]
pub struct ReportStatistics {
    /// 总问题数
    pub total_issues: usize,
    /// 错误数
    pub error_count: usize,
    /// 警告数
    pub warning_count: usize,
    /// 信息数
    pub info_count: usize,
    /// 按问题类型统计
    pub issues_by_type: HashMap<IssueType, usize>,
    /// 按规则统计
    pub issues_by_rule: HashMap<String, usize>,
}

impl ConsistencyReport {
    /// 创建新的报告
    pub fn new() -> Self {
        Self {
            id: uuid::Uuid::new_v4().to_string(),
            timestamp: chrono::Utc::now().to_rfc3339(),
            issues: Vec::new(),
            overall_score: 0.0,
            statistics: ReportStatistics {
                total_issues: 0,
                error_count: 0,
                warning_count: 0,
                info_count: 0,
                issues_by_type: HashMap::new(),
                issues_by_rule: HashMap::new(),
            },
        }
    }

    /// 添加问题
    pub fn add_issue(&mut self, issue: ConsistencyIssue) {
        self.issues.push(issue.clone());
        
        // 更新统计信息
        self.statistics.total_issues += 1;
        
        match issue.severity {
            IssueSeverity::Error => self.statistics.error_count += 1,
            IssueSeverity::Warning => self.statistics.warning_count += 1,
            IssueSeverity::Info => self.statistics.info_count += 1,
        }
        
        *self.statistics.issues_by_type
            .entry(issue.issue_type.clone())
            .or_insert(0) += 1;
        
        *self.statistics.issues_by_rule
            .entry(issue.rule_name.clone())
            .or_insert(0) += 1;
    }

    /// 计算总体评分
    pub fn calculate_score(&mut self) {
        if self.issues.is_empty() {
            self.overall_score = 1.0;
            return;
        }
        
        let mut total_penalty = 0.0;
        let mut total_issues = 0;
        
        for issue in &self.issues {
            total_issues += 1;
            match issue.severity {
                IssueSeverity::Error => total_penalty += 0.3,
                IssueSeverity::Warning => total_penalty += 0.1,
                IssueSeverity::Info => total_penalty += 0.05,
            }
        }
        
        self.overall_score = (1.0 - total_penalty).max(0.0);
    }

    /// 生成报告摘要
    pub fn generate_summary(&self) -> String {
        format!(
            "一致性检查报告\n\
            报告ID: {}\n\
            生成时间: {}\n\
            总体评分: {:.2}\n\
            总问题数: {}\n\
            错误: {}\n\
            警告: {}\n\
            信息: {}",
            self.id,
            self.timestamp,
            self.overall_score,
            self.statistics.total_issues,
            self.statistics.error_count,
            self.statistics.warning_count,
            self.statistics.info_count
        )
    }

    /// 生成详细报告
    pub fn generate_detailed_report(&self) -> String {
        let mut report = self.generate_summary();
        report.push_str("\n\n详细问题列表:\n");
        
        for (i, issue) in self.issues.iter().enumerate() {
            report.push_str(&format!(
                "{}. [{}] {}: {}\n",
                i + 1,
                match issue.severity {
                    IssueSeverity::Error => "ERROR",
                    IssueSeverity::Warning => "WARN",
                    IssueSeverity::Info => "INFO",
                },
                issue.rule_name,
                issue.description
            ));
            
            if let Some(mapping_id) = &issue.mapping_id {
                report.push_str(&format!("   映射ID: {}\n", mapping_id));
            }
        }
        
        report.push_str("\n按问题类型统计:\n");
        for (issue_type, count) in &self.statistics.issues_by_type {
            report.push_str(&format!("- {:?}: {}\n", issue_type, count));
        }
        
        report.push_str("\n按规则统计:\n");
        for (rule_name, count) in &self.statistics.issues_by_rule {
            report.push_str(&format!("- {}: {}\n", rule_name, count));
        }
        
        report
    }

    /// 获取问题统计
    pub fn get_statistics(&self) -> &ReportStatistics {
        &self.statistics
    }

    /// 按严重程度过滤问题
    pub fn filter_by_severity(&self, severity: IssueSeverity) -> Vec<&ConsistencyIssue> {
        self.issues.iter()
            .filter(|issue| issue.severity == severity)
            .collect()
    }

    /// 按规则过滤问题
    pub fn filter_by_rule(&self, rule_name: &str) -> Vec<&ConsistencyIssue> {
        self.issues.iter()
            .filter(|issue| issue.rule_name == rule_name)
            .collect()
    }
}
```

## 3. 使用示例

```rust
fn main() -> Result<(), String> {
    // 创建映射数据库
    let mut database = ConceptMappingDatabase::new();
    
    // 导入映射数据
    let formal_methods_mappings = FormalMethodsMappings::get_mappings();
    for mapping in formal_methods_mappings {
        database.add_mapping(mapping)?;
    }
    
    // 创建一致性检查器
    let mut checker = MappingConsistencyChecker::new(database);
    
    // 设置配置
    let config = ConsistencyConfig {
        min_strength_threshold: 0.8,
        min_confidence_threshold: 0.85,
        max_transitivity_distance: 3,
        check_cycles: true,
        check_conflicts: true,
        check_completeness: true,
    };
    checker = checker.with_config(config);
    
    // 添加默认规则
    checker.add_default_rules();
    
    // 执行一致性检查
    let mut report = checker.check_consistency();
    
    // 输出报告
    println!("{}", report.generate_detailed_report());
    
    // 输出错误级别的问题
    println!("\n错误级别问题:");
    let errors = report.filter_by_severity(IssueSeverity::Error);
    for error in errors {
        println!("- {}", error.description);
    }
    
    // 输出警告级别的问题
    println!("\n警告级别问题:");
    let warnings = report.filter_by_severity(IssueSeverity::Warning);
    for warning in warnings {
        println!("- {}", warning.description);
    }
    
    Ok(())
}
```

## 4. 总结

本文档实现了一致性检查工具，包括：

1. **一致性检查器**：完整的检查器结构，支持多种检查规则
2. **检查规则**：等价性、传递性、对称性、完整性、冲突、循环等检查
3. **一致性报告**：详细的报告结构，包含统计信息和问题分类
4. **使用示例**：展示如何配置和使用一致性检查工具

这个实现为项目的概念映射一致性提供了强大的验证工具，确保理论概念与实现概念之间的语义一致性和逻辑一致性。
