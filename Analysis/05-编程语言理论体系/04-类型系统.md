# 类型系统

## 概述

类型系统是编程语言理论的核心组成部分，用于静态检查程序正确性、提供安全保障和优化代码生成。本文档系统性地阐述类型理论、类型检查和类型推导。

## 1. 类型理论

### 1.1 基本类型

```rust
// 基本类型定义
#[derive(Debug, Clone, PartialEq)]
pub enum Type {
    // 基本类型
    Int,
    Float,
    Bool,
    String,
    Unit,
    
    // 复合类型
    Function(Vec<Type>, Box<Type>), // 参数类型列表 -> 返回类型
    Tuple(Vec<Type>),
    Array(Box<Type>),
    
    // 泛型类型
    Generic(String, Vec<Type>),
    
    // 类型变量（用于类型推导）
    Variable(String),
    
    // 联合类型
    Union(Vec<Type>),
    
    // 可选类型
    Optional(Box<Type>),
}

// 类型环境
#[derive(Debug, Clone)]
pub struct TypeEnvironment {
    variables: HashMap<String, Type>,
    functions: HashMap<String, Type>,
    parent: Option<Box<TypeEnvironment>>,
}

impl TypeEnvironment {
    pub fn new() -> Self {
        Self {
            variables: HashMap::new(),
            functions: HashMap::new(),
            parent: None,
        }
    }
    
    pub fn with_parent(parent: TypeEnvironment) -> Self {
        Self {
            variables: HashMap::new(),
            functions: HashMap::new(),
            parent: Some(Box::new(parent)),
        }
    }
    
    pub fn add_variable(&mut self, name: String, type_info: Type) {
        self.variables.insert(name, type_info);
    }
    
    pub fn add_function(&mut self, name: String, type_info: Type) {
        self.functions.insert(name, type_info);
    }
    
    pub fn get_variable_type(&self, name: &str) -> Option<Type> {
        self.variables.get(name).cloned().or_else(|| {
            self.parent.as_ref().and_then(|parent| parent.get_variable_type(name))
        })
    }
    
    pub fn get_function_type(&self, name: &str) -> Option<Type> {
        self.functions.get(name).cloned().or_else(|| {
            self.parent.as_ref().and_then(|parent| parent.get_function_type(name))
        })
    }
}
```

### 1.2 类型系统分类

```rust
// 类型系统分类
pub trait TypeSystem {
    // 静态类型系统
    fn is_static(&self) -> bool;
    
    // 强类型系统
    fn is_strong(&self) -> bool;
    
    // 类型安全
    fn is_safe(&self) -> bool;
    
    // 类型推导
    fn supports_inference(&self) -> bool;
}

// 静态类型系统
pub struct StaticTypeSystem;

impl TypeSystem for StaticTypeSystem {
    fn is_static(&self) -> bool { true }
    fn is_strong(&self) -> bool { true }
    fn is_safe(&self) -> bool { true }
    fn supports_inference(&self) -> bool { true }
}

// 动态类型系统
pub struct DynamicTypeSystem;

impl TypeSystem for DynamicTypeSystem {
    fn is_static(&self) -> bool { false }
    fn is_strong(&self) -> bool { false }
    fn is_safe(&self) -> bool { false }
    fn supports_inference(&self) -> bool { false }
}
```

## 2. 类型检查

### 2.1 类型检查器

```rust
// 类型检查器
pub struct TypeChecker {
    environment: TypeEnvironment,
    type_variables: HashMap<String, Type>,
}

impl TypeChecker {
    pub fn new() -> Self {
        Self {
            environment: TypeEnvironment::new(),
            type_variables: HashMap::new(),
        }
    }
    
    pub fn check_program(&mut self, ast: &SyntaxNode) -> Result<Type, String> {
        match ast {
            SyntaxNode::Program(statements) => {
                for statement in statements {
                    self.check_statement(statement)?;
                }
                Ok(Type::Unit)
            },
            _ => self.check_expression(ast),
        }
    }
    
    fn check_statement(&mut self, statement: &SyntaxNode) -> Result<Type, String> {
        match statement {
            SyntaxNode::VariableDecl(name, initializer) => {
                let var_type = if let Some(init) = initializer {
                    self.check_expression(init)?
                } else {
                    Type::Unit
                };
                self.environment.add_variable(name.clone(), var_type.clone());
                Ok(var_type)
            },
            SyntaxNode::FunctionDecl(name, parameters, body) => {
                let mut function_env = TypeEnvironment::with_parent(self.environment.clone());
                
                // 添加参数到函数环境
                for param in parameters {
                    let param_type = param.type_annotation.clone()
                        .map(|t| self.parse_type(&t))
                        .unwrap_or(Type::Variable(format!("T_{}", param.name)));
                    function_env.add_variable(param.name.clone(), param_type);
                }
                
                // 检查函数体
                let mut body_checker = TypeChecker {
                    environment: function_env,
                    type_variables: self.type_variables.clone(),
                };
                let body_type = body_checker.check_expression(body)?;
                
                // 构建函数类型
                let param_types: Vec<Type> = parameters.iter()
                    .map(|p| p.type_annotation.clone()
                        .map(|t| self.parse_type(&t))
                        .unwrap_or(Type::Variable(format!("T_{}", p.name))))
                    .collect();
                let function_type = Type::Function(param_types, Box::new(body_type));
                
                self.environment.add_function(name.clone(), function_type.clone());
                Ok(function_type)
            },
            SyntaxNode::Assignment(name, value) => {
                let value_type = self.check_expression(value)?;
                if let Some(var_type) = self.environment.get_variable_type(name) {
                    if self.types_compatible(&var_type, &value_type) {
                        Ok(value_type)
                    } else {
                        Err(format!("Type mismatch: expected {:?}, got {:?}", var_type, value_type))
                    }
                } else {
                    Err(format!("Undefined variable: {}", name))
                }
            },
            _ => self.check_expression(statement),
        }
    }
    
    fn check_expression(&mut self, expression: &SyntaxNode) -> Result<Type, String> {
        match expression {
            SyntaxNode::Literal(value) => self.check_literal_type(value),
            SyntaxNode::Variable(name) => self.check_variable_type(name),
            SyntaxNode::BinaryOp(left, op, right) => {
                self.check_binary_operation(left, op, right)
            },
            SyntaxNode::UnaryOp(op, operand) => {
                self.check_unary_operation(op, operand)
            },
            SyntaxNode::FunctionCall(name, args) => {
                self.check_function_call(name, args)
            },
            SyntaxNode::IfStatement(condition, then_branch, else_branch) => {
                self.check_if_statement(condition, then_branch, else_branch)
            },
            _ => Err("Unsupported expression for type checking".to_string()),
        }
    }
    
    fn check_literal_type(&self, value: &LiteralValue) -> Result<Type, String> {
        match value {
            LiteralValue::Integer(_) => Ok(Type::Int),
            LiteralValue::Float(_) => Ok(Type::Float),
            LiteralValue::Boolean(_) => Ok(Type::Bool),
            LiteralValue::String(_) => Ok(Type::String),
            LiteralValue::Null => Ok(Type::Unit),
        }
    }
    
    fn check_variable_type(&self, name: &str) -> Result<Type, String> {
        self.environment.get_variable_type(name)
            .ok_or_else(|| format!("Undefined variable: {}", name))
    }
    
    fn check_binary_operation(
        &mut self,
        left: &SyntaxNode,
        op: &Operator,
        right: &SyntaxNode,
    ) -> Result<Type, String> {
        let left_type = self.check_expression(left)?;
        let right_type = self.check_expression(right)?;
        
        match (left_type, op, right_type) {
            (Type::Int, Operator::Add, Type::Int) => Ok(Type::Int),
            (Type::Int, Operator::Sub, Type::Int) => Ok(Type::Int),
            (Type::Int, Operator::Mul, Type::Int) => Ok(Type::Int),
            (Type::Int, Operator::Div, Type::Int) => Ok(Type::Int),
            (Type::Float, Operator::Add, Type::Float) => Ok(Type::Float),
            (Type::Float, Operator::Sub, Type::Float) => Ok(Type::Float),
            (Type::Float, Operator::Mul, Type::Float) => Ok(Type::Float),
            (Type::Float, Operator::Div, Type::Float) => Ok(Type::Float),
            (Type::Bool, Operator::And, Type::Bool) => Ok(Type::Bool),
            (Type::Bool, Operator::Or, Type::Bool) => Ok(Type::Bool),
            (Type::Int, Operator::Eq, Type::Int) => Ok(Type::Bool),
            (Type::Int, Operator::Ne, Type::Int) => Ok(Type::Bool),
            (Type::Int, Operator::Lt, Type::Int) => Ok(Type::Bool),
            (Type::Int, Operator::Le, Type::Int) => Ok(Type::Bool),
            (Type::Int, Operator::Gt, Type::Int) => Ok(Type::Bool),
            (Type::Int, Operator::Ge, Type::Int) => Ok(Type::Bool),
            _ => Err(format!("Invalid binary operation: {:?} {:?} {:?}", left_type, op, right_type)),
        }
    }
    
    fn check_unary_operation(
        &mut self,
        op: &Operator,
        operand: &SyntaxNode,
    ) -> Result<Type, String> {
        let operand_type = self.check_expression(operand)?;
        
        match (op, operand_type) {
            (Operator::Not, Type::Bool) => Ok(Type::Bool),
            (Operator::Sub, Type::Int) => Ok(Type::Int),
            (Operator::Sub, Type::Float) => Ok(Type::Float),
            _ => Err(format!("Invalid unary operation: {:?} {:?}", op, operand_type)),
        }
    }
    
    fn check_function_call(
        &mut self,
        name: &str,
        args: &[SyntaxNode],
    ) -> Result<Type, String> {
        let function_type = self.environment.get_function_type(name)
            .ok_or_else(|| format!("Undefined function: {}", name))?;
        
        if let Type::Function(param_types, return_type) = function_type {
            if args.len() != param_types.len() {
                return Err(format!("Function {} expects {} arguments, got {}", 
                    name, param_types.len(), args.len()));
            }
            
            for (arg, expected_type) in args.iter().zip(param_types.iter()) {
                let arg_type = self.check_expression(arg)?;
                if !self.types_compatible(expected_type, &arg_type) {
                    return Err(format!("Type mismatch in function call: expected {:?}, got {:?}", 
                        expected_type, arg_type));
                }
            }
            
            Ok(*return_type)
        } else {
            Err(format!("{} is not a function", name))
        }
    }
    
    fn check_if_statement(
        &mut self,
        condition: &SyntaxNode,
        then_branch: &SyntaxNode,
        else_branch: &Option<Box<SyntaxNode>>,
    ) -> Result<Type, String> {
        let condition_type = self.check_expression(condition)?;
        if condition_type != Type::Bool {
            return Err("Condition must be boolean".to_string());
        }
        
        let then_type = self.check_expression(then_branch)?;
        
        if let Some(else_branch) = else_branch {
            let else_type = self.check_expression(else_branch)?;
            if self.types_compatible(&then_type, &else_type) {
                Ok(then_type)
            } else {
                Err(format!("Type mismatch in if-else: {:?} vs {:?}", then_type, else_type))
            }
        } else {
            Ok(then_type)
        }
    }
    
    fn types_compatible(&self, expected: &Type, actual: &Type) -> bool {
        match (expected, actual) {
            (Type::Variable(_), _) => true, // 类型变量可以匹配任何类型
            (_, Type::Variable(_)) => true,
            (Type::Int, Type::Int) => true,
            (Type::Float, Type::Float) => true,
            (Type::Bool, Type::Bool) => true,
            (Type::String, Type::String) => true,
            (Type::Unit, Type::Unit) => true,
            (Type::Function(params1, ret1), Type::Function(params2, ret2)) => {
                if params1.len() != params2.len() {
                    return false;
                }
                for (p1, p2) in params1.iter().zip(params2.iter()) {
                    if !self.types_compatible(p1, p2) {
                        return false;
                    }
                }
                self.types_compatible(ret1, ret2)
            },
            _ => false,
        }
    }
    
    fn parse_type(&self, type_str: &str) -> Type {
        match type_str {
            "int" => Type::Int,
            "float" => Type::Float,
            "bool" => Type::Bool,
            "string" => Type::String,
            "unit" => Type::Unit,
            _ => Type::Variable(type_str.to_string()),
        }
    }
}
```

### 2.2 类型错误处理

```rust
// 类型错误
#[derive(Debug, Clone)]
pub enum TypeError {
    UndefinedVariable(String),
    UndefinedFunction(String),
    TypeMismatch(Type, Type),
    ArgumentCountMismatch(String, usize, usize),
    InvalidOperation(String, Type),
    CircularType(String),
    UnificationError(Type, Type),
}

impl std::fmt::Display for TypeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TypeError::UndefinedVariable(name) => {
                write!(f, "Undefined variable: {}", name)
            },
            TypeError::UndefinedFunction(name) => {
                write!(f, "Undefined function: {}", name)
            },
            TypeError::TypeMismatch(expected, actual) => {
                write!(f, "Type mismatch: expected {:?}, got {:?}", expected, actual)
            },
            TypeError::ArgumentCountMismatch(func, expected, actual) => {
                write!(f, "Function {} expects {} arguments, got {}", func, expected, actual)
            },
            TypeError::InvalidOperation(op, typ) => {
                write!(f, "Invalid operation {} for type {:?}", op, typ)
            },
            TypeError::CircularType(name) => {
                write!(f, "Circular type definition: {}", name)
            },
            TypeError::UnificationError(t1, t2) => {
                write!(f, "Cannot unify types {:?} and {:?}", t1, t2)
            },
        }
    }
}

// 类型错误收集器
pub struct TypeErrorCollector {
    errors: Vec<TypeError>,
}

impl TypeErrorCollector {
    pub fn new() -> Self {
        Self { errors: Vec::new() }
    }
    
    pub fn add_error(&mut self, error: TypeError) {
        self.errors.push(error);
    }
    
    pub fn has_errors(&self) -> bool {
        !self.errors.is_empty()
    }
    
    pub fn get_errors(&self) -> &[TypeError] {
        &self.errors
    }
    
    pub fn clear(&mut self) {
        self.errors.clear();
    }
}
```

## 3. 类型推导

### 3.1 Hindley-Milner类型推导

```rust
// Hindley-Milner类型推导
pub struct HindleyMilnerTypeInference {
    type_variables: HashMap<String, Type>,
    substitution: Substitution,
    fresh_variable_counter: usize,
}

impl HindleyMilnerTypeInference {
    pub fn new() -> Self {
        Self {
            type_variables: HashMap::new(),
            substitution: Substitution::new(),
            fresh_variable_counter: 0,
        }
    }
    
    pub fn infer_type(&mut self, ast: &SyntaxNode) -> Result<Type, TypeError> {
        let mut env = TypeEnvironment::new();
        self.infer_expression(ast, &mut env)
    }
    
    fn infer_expression(&mut self, expr: &SyntaxNode, env: &mut TypeEnvironment) -> Result<Type, TypeError> {
        match expr {
            SyntaxNode::Literal(value) => self.infer_literal(value),
            SyntaxNode::Variable(name) => self.infer_variable(name, env),
            SyntaxNode::BinaryOp(left, op, right) => {
                self.infer_binary_operation(left, op, right, env)
            },
            SyntaxNode::FunctionCall(name, args) => {
                self.infer_function_call(name, args, env)
            },
            SyntaxNode::IfStatement(condition, then_branch, else_branch) => {
                self.infer_if_statement(condition, then_branch, else_branch, env)
            },
            _ => Err(TypeError::InvalidOperation("Unsupported expression".to_string(), Type::Unit)),
        }
    }
    
    fn infer_literal(&self, value: &LiteralValue) -> Result<Type, TypeError> {
        match value {
            LiteralValue::Integer(_) => Ok(Type::Int),
            LiteralValue::Float(_) => Ok(Type::Float),
            LiteralValue::Boolean(_) => Ok(Type::Bool),
            LiteralValue::String(_) => Ok(Type::String),
            LiteralValue::Null => Ok(Type::Unit),
        }
    }
    
    fn infer_variable(&mut self, name: &str, env: &TypeEnvironment) -> Result<Type, TypeError> {
        if let Some(var_type) = env.get_variable_type(name) {
            Ok(self.substitution.apply(&var_type))
        } else {
            Err(TypeError::UndefinedVariable(name.to_string()))
        }
    }
    
    fn infer_binary_operation(
        &mut self,
        left: &SyntaxNode,
        op: &Operator,
        right: &SyntaxNode,
        env: &mut TypeEnvironment,
    ) -> Result<Type, TypeError> {
        let left_type = self.infer_expression(left, env)?;
        let right_type = self.infer_expression(right, env)?;
        
        // 统一左操作数类型
        let unified_left = self.unify(&left_type, &self.get_expected_type(op, 0))?;
        
        // 统一右操作数类型
        let unified_right = self.unify(&right_type, &self.get_expected_type(op, 1))?;
        
        // 统一操作数类型
        self.unify(&unified_left, &unified_right)?;
        
        Ok(self.get_result_type(op))
    }
    
    fn infer_function_call(
        &mut self,
        name: &str,
        args: &[SyntaxNode],
        env: &mut TypeEnvironment,
    ) -> Result<Type, TypeError> {
        let function_type = env.get_function_type(name)
            .ok_or_else(|| TypeError::UndefinedFunction(name.to_string()))?;
        
        if let Type::Function(param_types, return_type) = function_type {
            if args.len() != param_types.len() {
                return Err(TypeError::ArgumentCountMismatch(
                    name.to_string(), param_types.len(), args.len()));
            }
            
            // 推导参数类型
            let mut arg_types = Vec::new();
            for arg in args {
                let arg_type = self.infer_expression(arg, env)?;
                arg_types.push(arg_type);
            }
            
            // 统一参数类型
            for (arg_type, param_type) in arg_types.iter().zip(param_types.iter()) {
                self.unify(arg_type, param_type)?;
            }
            
            Ok(*return_type)
        } else {
            Err(TypeError::InvalidOperation(
                format!("{} is not a function", name), function_type))
        }
    }
    
    fn infer_if_statement(
        &mut self,
        condition: &SyntaxNode,
        then_branch: &SyntaxNode,
        else_branch: &Option<Box<SyntaxNode>>,
        env: &mut TypeEnvironment,
    ) -> Result<Type, TypeError> {
        let condition_type = self.infer_expression(condition, env)?;
        self.unify(&condition_type, &Type::Bool)?;
        
        let then_type = self.infer_expression(then_branch, env)?;
        
        if let Some(else_branch) = else_branch {
            let else_type = self.infer_expression(else_branch, env)?;
            self.unify(&then_type, &else_type)?;
        }
        
        Ok(then_type)
    }
    
    fn unify(&mut self, t1: &Type, t2: &Type) -> Result<Type, TypeError> {
        let t1_subst = self.substitution.apply(t1);
        let t2_subst = self.substitution.apply(t2);
        
        match (&t1_subst, &t2_subst) {
            (Type::Variable(v1), Type::Variable(v2)) if v1 == v2 => Ok(t1_subst),
            (Type::Variable(v), t) | (t, Type::Variable(v)) => {
                if self.occurs_in(v, t) {
                    Err(TypeError::CircularType(v.clone()))
                } else {
                    self.substitution.add(v.clone(), t.clone());
                    Ok(t.clone())
                }
            },
            (Type::Int, Type::Int) => Ok(Type::Int),
            (Type::Float, Type::Float) => Ok(Type::Float),
            (Type::Bool, Type::Bool) => Ok(Type::Bool),
            (Type::String, Type::String) => Ok(Type::String),
            (Type::Unit, Type::Unit) => Ok(Type::Unit),
            (Type::Function(params1, ret1), Type::Function(params2, ret2)) => {
                if params1.len() != params2.len() {
                    return Err(TypeError::UnificationError(t1_subst, t2_subst));
                }
                
                for (p1, p2) in params1.iter().zip(params2.iter()) {
                    self.unify(p1, p2)?;
                }
                
                self.unify(ret1, ret2)?;
                Ok(t1_subst)
            },
            _ => Err(TypeError::UnificationError(t1_subst, t2_subst)),
        }
    }
    
    fn occurs_in(&self, var: &str, typ: &Type) -> bool {
        match typ {
            Type::Variable(v) => v == var,
            Type::Function(params, ret) => {
                params.iter().any(|p| self.occurs_in(var, p)) || self.occurs_in(var, ret)
            },
            _ => false,
        }
    }
    
    fn get_expected_type(&self, op: &Operator, operand: usize) -> Type {
        match (op, operand) {
            (Operator::Add | Operator::Sub | Operator::Mul | Operator::Div, _) => Type::Int,
            (Operator::And | Operator::Or, _) => Type::Bool,
            (Operator::Eq | Operator::Ne | Operator::Lt | Operator::Le | Operator::Gt | Operator::Ge, _) => Type::Int,
            _ => Type::Variable(format!("T_{}", self.fresh_variable_counter)),
        }
    }
    
    fn get_result_type(&self, op: &Operator) -> Type {
        match op {
            Operator::Add | Operator::Sub | Operator::Mul | Operator::Div => Type::Int,
            Operator::And | Operator::Or => Type::Bool,
            Operator::Eq | Operator::Ne | Operator::Lt | Operator::Le | Operator::Gt | Operator::Ge => Type::Bool,
            _ => Type::Variable(format!("T_{}", self.fresh_variable_counter)),
        }
    }
    
    fn fresh_variable(&mut self) -> Type {
        self.fresh_variable_counter += 1;
        Type::Variable(format!("T_{}", self.fresh_variable_counter))
    }
}

// 类型替换
#[derive(Debug, Clone)]
pub struct Substitution {
    mappings: HashMap<String, Type>,
}

impl Substitution {
    pub fn new() -> Self {
        Self {
            mappings: HashMap::new(),
        }
    }
    
    pub fn add(&mut self, variable: String, typ: Type) {
        self.mappings.insert(variable, typ);
    }
    
    pub fn apply(&self, typ: &Type) -> Type {
        match typ {
            Type::Variable(v) => {
                self.mappings.get(v).cloned().unwrap_or(typ.clone())
            },
            Type::Function(params, ret) => {
                Type::Function(
                    params.iter().map(|p| self.apply(p)).collect(),
                    Box::new(self.apply(ret)),
                )
            },
            _ => typ.clone(),
        }
    }
    
    pub fn compose(&self, other: &Substitution) -> Substitution {
        let mut composed = Substitution::new();
        
        // 应用其他替换到当前替换
        for (var, typ) in &self.mappings {
            composed.add(var.clone(), other.apply(typ));
        }
        
        // 添加其他替换中的新映射
        for (var, typ) in &other.mappings {
            if !composed.mappings.contains_key(var) {
                composed.add(var.clone(), typ.clone());
            }
        }
        
        composed
    }
}
```

## 4. 高级类型系统

### 4.1 泛型系统

```rust
// 泛型类型系统
pub struct GenericTypeSystem {
    type_parameters: HashMap<String, TypeConstraint>,
    generic_functions: HashMap<String, GenericFunction>,
}

#[derive(Debug, Clone)]
pub struct TypeConstraint {
    bounds: Vec<Type>,
    variance: Variance,
}

#[derive(Debug, Clone)]
pub enum Variance {
    Covariant,    // 协变
    Contravariant, // 逆变
    Invariant,    // 不变
}

#[derive(Debug, Clone)]
pub struct GenericFunction {
    name: String,
    type_parameters: Vec<String>,
    constraints: HashMap<String, TypeConstraint>,
    signature: Type,
    implementation: Box<dyn Fn(Vec<Type>) -> Type>,
}

impl GenericTypeSystem {
    pub fn new() -> Self {
        Self {
            type_parameters: HashMap::new(),
            generic_functions: HashMap::new(),
        }
    }
    
    pub fn add_generic_function(&mut self, function: GenericFunction) {
        self.generic_functions.insert(function.name.clone(), function);
    }
    
    pub fn instantiate_generic_function(
        &self,
        name: &str,
        type_arguments: &[Type],
    ) -> Result<Type, TypeError> {
        let generic_function = self.generic_functions.get(name)
            .ok_or_else(|| TypeError::UndefinedFunction(name.to_string()))?;
        
        if type_arguments.len() != generic_function.type_parameters.len() {
            return Err(TypeError::ArgumentCountMismatch(
                name.to_string(), generic_function.type_parameters.len(), type_arguments.len()));
        }
        
        // 检查类型约束
        for (param, arg) in generic_function.type_parameters.iter().zip(type_arguments.iter()) {
            if let Some(constraint) = generic_function.constraints.get(param) {
                if !self.satisfies_constraint(arg, constraint) {
                    return Err(TypeError::TypeMismatch(
                        Type::Variable(param.clone()), arg.clone()));
                }
            }
        }
        
        // 实例化函数类型
        let instantiated_type = self.substitute_type_parameters(
            &generic_function.signature,
            &generic_function.type_parameters,
            type_arguments,
        )?;
        
        Ok(instantiated_type)
    }
    
    fn satisfies_constraint(&self, typ: &Type, constraint: &TypeConstraint) -> bool {
        constraint.bounds.iter().any(|bound| {
            self.is_subtype(typ, bound)
        })
    }
    
    fn is_subtype(&self, sub: &Type, super: &Type) -> bool {
        match (sub, super) {
            (Type::Int, Type::Float) => true, // Int是Float的子类型
            (t1, t2) if t1 == t2 => true,
            (Type::Generic(name1, args1), Type::Generic(name2, args2)) if name1 == name2 => {
                args1.iter().zip(args2.iter()).all(|(a1, a2)| self.is_subtype(a1, a2))
            },
            _ => false,
        }
    }
    
    fn substitute_type_parameters(
        &self,
        typ: &Type,
        parameters: &[String],
        arguments: &[Type],
    ) -> Result<Type, TypeError> {
        match typ {
            Type::Variable(name) => {
                if let Some(index) = parameters.iter().position(|p| p == name) {
                    Ok(arguments[index].clone())
                } else {
                    Ok(typ.clone())
                }
            },
            Type::Function(params, ret) => {
                let new_params: Result<Vec<Type>, TypeError> = params.iter()
                    .map(|p| self.substitute_type_parameters(p, parameters, arguments))
                    .collect();
                let new_ret = self.substitute_type_parameters(ret, parameters, arguments)?;
                Ok(Type::Function(new_params?, Box::new(new_ret)))
            },
            Type::Generic(name, args) => {
                let new_args: Result<Vec<Type>, TypeError> = args.iter()
                    .map(|a| self.substitute_type_parameters(a, parameters, arguments))
                    .collect();
                Ok(Type::Generic(name.clone(), new_args?))
            },
            _ => Ok(typ.clone()),
        }
    }
}
```

## 5. 交叉引用

- [[00-编程语言理论总论|编程语言理论总论]]
- [[01-语言设计原则|语言设计原则]]
- [[02-语法和语义|语法和语义]]
- [[03-编译器理论|编译器理论]]

## 导航

- [返回总目录](../README.md)
- [编程语言理论总论](00-编程语言理论总论.md)
- [语言设计原则](01-语言设计原则.md)
- [语法和语义](02-语法和语义.md)
- [编译器理论](03-编译器理论.md)
