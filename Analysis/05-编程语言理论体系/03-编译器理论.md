# 编译器理论

## 概述

编译器理论是编程语言理论的核心组成部分，研究如何将高级语言程序转换为机器可执行的代码。本文档系统性地阐述编译器架构、代码生成和优化技术。

## 1. 编译器架构

### 1.1 编译器阶段

编译器通常分为多个阶段，每个阶段处理特定的任务：

```mermaid
graph LR
    A[源代码] --> B[词法分析]
    B --> C[语法分析]
    C --> D[语义分析]
    D --> E[中间代码生成]
    E --> F[代码优化]
    F --> G[目标代码生成]
    G --> H[目标代码]
```

#### 编译器阶段实现

```rust
// 编译器主结构
pub struct Compiler {
    lexer: Lexer,
    parser: Parser,
    semantic_analyzer: SemanticAnalyzer,
    code_generator: CodeGenerator,
    optimizer: Optimizer,
    target_generator: TargetGenerator,
}

impl Compiler {
    pub fn new() -> Self {
        Self {
            lexer: Lexer::new(),
            parser: Parser::new(),
            semantic_analyzer: SemanticAnalyzer::new(),
            code_generator: CodeGenerator::new(),
            optimizer: Optimizer::new(),
            target_generator: TargetGenerator::new(),
        }
    }
    
    pub fn compile(&mut self, source: &str) -> Result<Vec<u8>, CompilationError> {
        // 1. 词法分析
        let tokens = self.lexer.tokenize(source)?;
        
        // 2. 语法分析
        let ast = self.parser.parse(&tokens)?;
        
        // 3. 语义分析
        let semantic_info = self.semantic_analyzer.analyze(&ast)?;
        
        // 4. 中间代码生成
        let intermediate_code = self.code_generator.generate(&ast, &semantic_info)?;
        
        // 5. 代码优化
        let optimized_code = self.optimizer.optimize(intermediate_code)?;
        
        // 6. 目标代码生成
        let target_code = self.target_generator.generate(&optimized_code)?;
        
        Ok(target_code)
    }
}

#[derive(Debug)]
pub enum CompilationError {
    LexicalError(String),
    SyntaxError(String),
    SemanticError(String),
    CodeGenerationError(String),
    OptimizationError(String),
    TargetGenerationError(String),
}
```

### 1.2 前端和后端

编译器通常分为前端和后端：

```rust
// 编译器前端
pub trait CompilerFrontend {
    fn lexical_analysis(&self, source: &str) -> Result<Vec<Token>, CompilationError>;
    fn syntax_analysis(&self, tokens: &[Token]) -> Result<SyntaxTree, CompilationError>;
    fn semantic_analysis(&self, ast: &SyntaxTree) -> Result<SemanticInfo, CompilationError>;
}

// 编译器后端
pub trait CompilerBackend {
    fn intermediate_code_generation(&self, ast: &SyntaxTree, semantic_info: &SemanticInfo) -> Result<IntermediateCode, CompilationError>;
    fn code_optimization(&self, intermediate_code: IntermediateCode) -> Result<IntermediateCode, CompilationError>;
    fn target_code_generation(&self, intermediate_code: &IntermediateCode) -> Result<TargetCode, CompilationError>;
}

// 语义信息
#[derive(Debug, Clone)]
pub struct SemanticInfo {
    symbol_table: SymbolTable,
    type_info: HashMap<String, Type>,
    scope_info: Vec<Scope>,
}

#[derive(Debug, Clone)]
pub struct SymbolTable {
    symbols: HashMap<String, Symbol>,
}

#[derive(Debug, Clone)]
pub struct Symbol {
    name: String,
    type_info: Type,
    scope: usize,
    kind: SymbolKind,
}

#[derive(Debug, Clone)]
pub enum SymbolKind {
    Variable,
    Function,
    Type,
    Constant,
}

#[derive(Debug, Clone)]
pub struct Scope {
    level: usize,
    symbols: HashMap<String, Symbol>,
    parent: Option<usize>,
}
```

## 2. 中间代码生成

### 2.1 三地址码

三地址码是一种中间表示形式：

```rust
// 三地址码
#[derive(Debug, Clone)]
pub enum ThreeAddressCode {
    // 赋值: x = y op z
    Assignment(String, String, Option<Operator>, Option<String>),
    
    // 无条件跳转: goto label
    Goto(String),
    
    // 条件跳转: if x goto label
    IfGoto(String, String, String),
    
    // 函数调用: call function_name, args
    FunctionCall(String, Vec<String>),
    
    // 函数返回: return value
    Return(Option<String>),
    
    // 标签: label:
    Label(String),
    
    // 参数传递: param arg
    Param(String),
}

// 三地址码生成器
pub struct ThreeAddressCodeGenerator {
    temp_counter: usize,
    label_counter: usize,
    code: Vec<ThreeAddressCode>,
}

impl ThreeAddressCodeGenerator {
    pub fn new() -> Self {
        Self {
            temp_counter: 0,
            label_counter: 0,
            code: Vec::new(),
        }
    }
    
    pub fn generate(&mut self, ast: &SyntaxNode) -> Result<Vec<ThreeAddressCode>, CompilationError> {
        self.generate_expression(ast)?;
        Ok(self.code.clone())
    }
    
    fn generate_expression(&mut self, node: &SyntaxNode) -> Result<String, CompilationError> {
        match node {
            SyntaxNode::Literal(value) => {
                let temp = self.new_temp();
                let value_str = self.literal_to_string(value);
                self.code.push(ThreeAddressCode::Assignment(temp.clone(), value_str, None, None));
                Ok(temp)
            },
            SyntaxNode::Variable(name) => {
                Ok(name.clone())
            },
            SyntaxNode::BinaryOp(left, op, right) => {
                let left_temp = self.generate_expression(left)?;
                let right_temp = self.generate_expression(right)?;
                let result_temp = self.new_temp();
                
                self.code.push(ThreeAddressCode::Assignment(
                    result_temp.clone(),
                    left_temp,
                    Some(op.clone()),
                    Some(right_temp),
                ));
                
                Ok(result_temp)
            },
            SyntaxNode::FunctionCall(name, args) => {
                let mut arg_temps = Vec::new();
                for arg in args {
                    let arg_temp = self.generate_expression(arg)?;
                    self.code.push(ThreeAddressCode::Param(arg_temp.clone()));
                    arg_temps.push(arg_temp);
                }
                
                let result_temp = self.new_temp();
                self.code.push(ThreeAddressCode::FunctionCall(name.clone(), arg_temps));
                self.code.push(ThreeAddressCode::Assignment(result_temp.clone(), "RETVAL".to_string(), None, None));
                
                Ok(result_temp)
            },
            _ => Err(CompilationError::CodeGenerationError("Unsupported expression".to_string())),
        }
    }
    
    fn generate_statement(&mut self, node: &SyntaxNode) -> Result<(), CompilationError> {
        match node {
            SyntaxNode::Assignment(name, value) => {
                let value_temp = self.generate_expression(value)?;
                self.code.push(ThreeAddressCode::Assignment(name.clone(), value_temp, None, None));
                Ok(())
            },
            SyntaxNode::IfStatement(condition, then_branch, else_branch) => {
                let condition_temp = self.generate_expression(condition)?;
                let then_label = self.new_label();
                let end_label = self.new_label();
                let else_label = if else_branch.is_some() { self.new_label() } else { end_label.clone() };
                
                // 条件跳转
                self.code.push(ThreeAddressCode::IfGoto(condition_temp, then_label.clone(), else_label.clone()));
                
                // else分支
                if let Some(else_branch) = else_branch {
                    self.code.push(ThreeAddressCode::Label(else_label));
                    self.generate_statement(else_branch)?;
                    self.code.push(ThreeAddressCode::Goto(end_label.clone()));
                }
                
                // then分支
                self.code.push(ThreeAddressCode::Label(then_label));
                self.generate_statement(then_branch)?;
                self.code.push(ThreeAddressCode::Label(end_label));
                
                Ok(())
            },
            SyntaxNode::WhileStatement(condition, body) => {
                let start_label = self.new_label();
                let body_label = self.new_label();
                let end_label = self.new_label();
                
                self.code.push(ThreeAddressCode::Label(start_label.clone()));
                let condition_temp = self.generate_expression(condition)?;
                self.code.push(ThreeAddressCode::IfGoto(condition_temp, body_label.clone(), end_label.clone()));
                
                self.code.push(ThreeAddressCode::Label(body_label));
                self.generate_statement(body)?;
                self.code.push(ThreeAddressCode::Goto(start_label));
                
                self.code.push(ThreeAddressCode::Label(end_label));
                Ok(())
            },
            _ => Err(CompilationError::CodeGenerationError("Unsupported statement".to_string())),
        }
    }
    
    fn new_temp(&mut self) -> String {
        self.temp_counter += 1;
        format!("t{}", self.temp_counter)
    }
    
    fn new_label(&mut self) -> String {
        self.label_counter += 1;
        format!("L{}", self.label_counter)
    }
    
    fn literal_to_string(&self, value: &LiteralValue) -> String {
        match value {
            LiteralValue::Integer(i) => i.to_string(),
            LiteralValue::Float(f) => f.to_string(),
            LiteralValue::Boolean(b) => b.to_string(),
            LiteralValue::String(s) => format!("\"{}\"", s),
            LiteralValue::Null => "null".to_string(),
        }
    }
}
```

### 2.2 静态单赋值形式

静态单赋值（SSA）是一种重要的中间表示：

```rust
// SSA形式
#[derive(Debug, Clone)]
pub enum SSANode {
    // 常量
    Constant(Value),
    
    // 变量定义
    Variable(String, Box<SSANode>),
    
    // 二元操作
    BinaryOp(Operator, Box<SSANode>, Box<SSANode>),
    
    // 一元操作
    UnaryOp(Operator, Box<SSANode>),
    
    // Phi函数
    Phi(Vec<String>, Vec<String>),
    
    // 函数调用
    FunctionCall(String, Vec<SSANode>),
}

// SSA转换器
pub struct SSATransformer {
    variable_counter: HashMap<String, usize>,
    phi_functions: Vec<(String, Vec<String>)>,
}

impl SSATransformer {
    pub fn new() -> Self {
        Self {
            variable_counter: HashMap::new(),
            phi_functions: Vec::new(),
        }
    }
    
    pub fn transform(&mut self, ast: &SyntaxNode) -> Result<SSANode, CompilationError> {
        self.transform_node(ast)
    }
    
    fn transform_node(&mut self, node: &SyntaxNode) -> Result<SSANode, CompilationError> {
        match node {
            SyntaxNode::Literal(value) => {
                Ok(SSANode::Constant(self.literal_to_value(value)))
            },
            SyntaxNode::Variable(name) => {
                let ssa_name = self.get_ssa_name(name);
                Ok(SSANode::Variable(ssa_name, Box::new(SSANode::Constant(Value::Unit))))
            },
            SyntaxNode::BinaryOp(left, op, right) => {
                let left_ssa = self.transform_node(left)?;
                let right_ssa = self.transform_node(right)?;
                Ok(SSANode::BinaryOp(op.clone(), Box::new(left_ssa), Box::new(right_ssa)))
            },
            SyntaxNode::Assignment(name, value) => {
                let value_ssa = self.transform_node(value)?;
                let ssa_name = self.new_ssa_name(name);
                Ok(SSANode::Variable(ssa_name, Box::new(value_ssa)))
            },
            _ => Err(CompilationError::CodeGenerationError("Unsupported node for SSA".to_string())),
        }
    }
    
    fn get_ssa_name(&self, name: &str) -> String {
        let counter = self.variable_counter.get(name).unwrap_or(&0);
        format!("{}_{}", name, counter)
    }
    
    fn new_ssa_name(&mut self, name: &str) -> String {
        let counter = self.variable_counter.entry(name.to_string()).or_insert(0);
        *counter += 1;
        format!("{}_{}", name, counter)
    }
    
    fn literal_to_value(&self, value: &LiteralValue) -> Value {
        match value {
            LiteralValue::Integer(i) => Value::Integer(*i),
            LiteralValue::Float(f) => Value::Float(*f),
            LiteralValue::Boolean(b) => Value::Boolean(*b),
            LiteralValue::String(s) => Value::String(s.clone()),
            LiteralValue::Null => Value::Unit,
        }
    }
}
```

## 3. 代码优化

### 3.1 局部优化

#### 常量折叠

```rust
// 常量折叠优化
pub struct ConstantFoldingOptimizer;

impl ConstantFoldingOptimizer {
    pub fn optimize(&self, code: &mut Vec<ThreeAddressCode>) -> Result<(), CompilationError> {
        for instruction in code.iter_mut() {
            if let ThreeAddressCode::Assignment(result, left, Some(op), Some(right)) = instruction {
                if let (Some(left_val), Some(right_val)) = (self.get_constant_value(left), self.get_constant_value(right)) {
                    if let Some(constant_result) = self.evaluate_constant_operation(left_val, op, right_val) {
                        *instruction = ThreeAddressCode::Assignment(
                            result.clone(),
                            constant_result.to_string(),
                            None,
                            None,
                        );
                    }
                }
            }
        }
        Ok(())
    }
    
    fn get_constant_value(&self, operand: &str) -> Option<Value> {
        // 检查是否为常量
        if operand.parse::<i64>().is_ok() {
            Some(Value::Integer(operand.parse().unwrap()))
        } else if operand.parse::<f64>().is_ok() {
            Some(Value::Float(operand.parse().unwrap()))
        } else if operand == "true" {
            Some(Value::Boolean(true))
        } else if operand == "false" {
            Some(Value::Boolean(false))
        } else {
            None
        }
    }
    
    fn evaluate_constant_operation(&self, left: Value, op: &Operator, right: Value) -> Option<Value> {
        match (left, op, right) {
            (Value::Integer(a), Operator::Add, Value::Integer(b)) => Some(Value::Integer(a + b)),
            (Value::Integer(a), Operator::Sub, Value::Integer(b)) => Some(Value::Integer(a - b)),
            (Value::Integer(a), Operator::Mul, Value::Integer(b)) => Some(Value::Integer(a * b)),
            (Value::Integer(a), Operator::Div, Value::Integer(b)) => {
                if b != 0 { Some(Value::Integer(a / b)) } else { None }
            },
            (Value::Boolean(a), Operator::And, Value::Boolean(b)) => Some(Value::Boolean(a && b)),
            (Value::Boolean(a), Operator::Or, Value::Boolean(b)) => Some(Value::Boolean(a || b)),
            _ => None,
        }
    }
}
```

#### 死代码消除

```rust
// 死代码消除优化
pub struct DeadCodeEliminationOptimizer;

impl DeadCodeEliminationOptimizer {
    pub fn optimize(&self, code: &mut Vec<ThreeAddressCode>) -> Result<(), CompilationError> {
        let mut live_variables = HashSet::new();
        let mut used_variables = HashSet::new();
        
        // 第一遍：收集所有使用的变量
        for instruction in code.iter() {
            self.collect_used_variables(instruction, &mut used_variables);
        }
        
        // 第二遍：标记活跃变量
        for instruction in code.iter().rev() {
            self.mark_live_variables(instruction, &mut live_variables, &used_variables);
        }
        
        // 第三遍：消除死代码
        code.retain(|instruction| self.is_instruction_needed(instruction, &live_variables));
        
        Ok(())
    }
    
    fn collect_used_variables(&self, instruction: &ThreeAddressCode, used: &mut HashSet<String>) {
        match instruction {
            ThreeAddressCode::Assignment(result, left, _, right) => {
                if !self.is_constant(left) {
                    used.insert(left.clone());
                }
                if let Some(right_var) = right {
                    if !self.is_constant(right_var) {
                        used.insert(right_var.clone());
                    }
                }
            },
            ThreeAddressCode::IfGoto(condition, _, _) => {
                if !self.is_constant(condition) {
                    used.insert(condition.clone());
                }
            },
            ThreeAddressCode::FunctionCall(_, args) => {
                for arg in args {
                    if !self.is_constant(arg) {
                        used.insert(arg.clone());
                    }
                }
            },
            _ => {},
        }
    }
    
    fn mark_live_variables(
        &self,
        instruction: &ThreeAddressCode,
        live: &mut HashSet<String>,
        used: &HashSet<String>,
    ) {
        match instruction {
            ThreeAddressCode::Assignment(result, left, _, right) => {
                if used.contains(result) {
                    live.insert(result.clone());
                }
                if !self.is_constant(left) {
                    live.insert(left.clone());
                }
                if let Some(right_var) = right {
                    if !self.is_constant(right_var) {
                        live.insert(right_var.clone());
                    }
                }
            },
            ThreeAddressCode::IfGoto(condition, _, _) => {
                if !self.is_constant(condition) {
                    live.insert(condition.clone());
                }
            },
            _ => {},
        }
    }
    
    fn is_instruction_needed(&self, instruction: &ThreeAddressCode, live_variables: &HashSet<String>) -> bool {
        match instruction {
            ThreeAddressCode::Assignment(result, _, _, _) => {
                live_variables.contains(result)
            },
            ThreeAddressCode::Label(_) | ThreeAddressCode::Goto(_) | ThreeAddressCode::IfGoto(_, _, _) => {
                true // 控制流指令总是需要的
            },
            ThreeAddressCode::FunctionCall(_, _) | ThreeAddressCode::Return(_) | ThreeAddressCode::Param(_) => {
                true // 函数调用相关指令总是需要的
            },
        }
    }
    
    fn is_constant(&self, operand: &str) -> bool {
        operand.parse::<i64>().is_ok() || 
        operand.parse::<f64>().is_ok() || 
        operand == "true" || 
        operand == "false"
    }
}
```

### 3.2 全局优化

#### 循环优化

```rust
// 循环优化
pub struct LoopOptimizer;

impl LoopOptimizer {
    pub fn optimize(&self, code: &mut Vec<ThreeAddressCode>) -> Result<(), CompilationError> {
        let loops = self.identify_loops(code)?;
        
        for loop_info in loops {
            self.optimize_loop(code, &loop_info)?;
        }
        
        Ok(())
    }
    
    fn identify_loops(&self, code: &[ThreeAddressCode]) -> Result<Vec<LoopInfo>, CompilationError> {
        let mut loops = Vec::new();
        let mut loop_stack = Vec::new();
        
        for (i, instruction) in code.iter().enumerate() {
            match instruction {
                ThreeAddressCode::Label(label) => {
                    // 检查是否是循环开始
                    if let Some(loop_start) = self.find_loop_start(code, i) {
                        loop_stack.push(LoopInfo {
                            start: loop_start,
                            end: i,
                            header: label.clone(),
                        });
                    }
                },
                ThreeAddressCode::Goto(target) => {
                    // 检查是否是循环结束
                    if let Some(loop_info) = loop_stack.last_mut() {
                        if target == &loop_info.header {
                            loop_info.end = i;
                        }
                    }
                },
                _ => {},
            }
        }
        
        loops.extend(loop_stack);
        Ok(loops)
    }
    
    fn optimize_loop(&self, code: &mut Vec<ThreeAddressCode>, loop_info: &LoopInfo) -> Result<(), CompilationError> {
        // 循环不变代码外提
        self.hoist_invariant_code(code, loop_info)?;
        
        // 循环展开
        self.unroll_loop(code, loop_info)?;
        
        Ok(())
    }
    
    fn hoist_invariant_code(&self, code: &mut Vec<ThreeAddressCode>, loop_info: &LoopInfo) -> Result<(), CompilationError> {
        let mut invariant_instructions = Vec::new();
        let mut loop_variables = HashSet::new();
        
        // 收集循环变量
        for i in loop_info.start..=loop_info.end {
            if let ThreeAddressCode::Assignment(result, _, _, _) = &code[i] {
                loop_variables.insert(result.clone());
            }
        }
        
        // 识别不变代码
        for i in loop_info.start..=loop_info.end {
            if let ThreeAddressCode::Assignment(result, left, op, right) = &code[i] {
                let is_invariant = !loop_variables.contains(result) && 
                                 !loop_variables.contains(left) &&
                                 right.as_ref().map_or(true, |r| !loop_variables.contains(r));
                
                if is_invariant {
                    invariant_instructions.push((i, code[i].clone()));
                }
            }
        }
        
        // 外提不变代码
        for (_, instruction) in invariant_instructions.iter().rev() {
            code.insert(loop_info.start, instruction.clone());
        }
        
        Ok(())
    }
    
    fn unroll_loop(&self, code: &mut Vec<ThreeAddressCode>, loop_info: &LoopInfo) -> Result<(), CompilationError> {
        // 简单的循环展开：展开2次
        let loop_body: Vec<_> = code[loop_info.start..=loop_info.end].to_vec();
        
        // 插入展开的循环体
        for i in 1..3 {
            for instruction in loop_body.iter() {
                let mut new_instruction = instruction.clone();
                self.rename_variables(&mut new_instruction, i);
                code.insert(loop_info.end + i, new_instruction);
            }
        }
        
        Ok(())
    }
    
    fn rename_variables(&self, instruction: &mut ThreeAddressCode, suffix: usize) {
        match instruction {
            ThreeAddressCode::Assignment(result, left, _, right) => {
                *result = format!("{}_{}", result, suffix);
                if !self.is_constant(left) {
                    *left = format!("{}_{}", left, suffix);
                }
                if let Some(right_var) = right {
                    if !self.is_constant(right_var) {
                        *right_var = format!("{}_{}", right_var, suffix);
                    }
                }
            },
            _ => {},
        }
    }
    
    fn find_loop_start(&self, code: &[ThreeAddressCode], current: usize) -> Option<usize> {
        // 简单的循环开始识别
        for i in (0..current).rev() {
            if let ThreeAddressCode::Goto(target) = &code[i] {
                if let ThreeAddressCode::Label(label) = &code[current] {
                    if target == label {
                        return Some(i);
                    }
                }
            }
        }
        None
    }
}

#[derive(Debug, Clone)]
pub struct LoopInfo {
    start: usize,
    end: usize,
    header: String,
}
```

## 4. 目标代码生成

### 4.1 寄存器分配

```rust
// 寄存器分配器
pub struct RegisterAllocator {
    available_registers: Vec<String>,
    register_map: HashMap<String, String>,
    spilled_variables: Vec<String>,
}

impl RegisterAllocator {
    pub fn new() -> Self {
        let available_registers = vec![
            "r0".to_string(), "r1".to_string(), "r2".to_string(), "r3".to_string(),
            "r4".to_string(), "r5".to_string(), "r6".to_string(), "r7".to_string(),
        ];
        
        Self {
            available_registers,
            register_map: HashMap::new(),
            spilled_variables: Vec::new(),
        }
    }
    
    pub fn allocate(&mut self, code: &mut Vec<ThreeAddressCode>) -> Result<(), CompilationError> {
        let interference_graph = self.build_interference_graph(code)?;
        let coloring = self.graph_coloring(&interference_graph)?;
        
        for instruction in code.iter_mut() {
            self.assign_registers(instruction, &coloring)?;
        }
        
        Ok(())
    }
    
    fn build_interference_graph(&self, code: &[ThreeAddressCode]) -> Result<Graph<String>, CompilationError> {
        let mut graph = Graph::new();
        let mut live_ranges = self.compute_live_ranges(code)?;
        
        // 为每个变量添加节点
        for variable in live_ranges.keys() {
            graph.add_node(variable.clone());
        }
        
        // 添加冲突边
        for (var1, range1) in &live_ranges {
            for (var2, range2) in &live_ranges {
                if var1 != var2 && self.ranges_overlap(range1, range2) {
                    graph.add_edge(var1.clone(), var2.clone());
                }
            }
        }
        
        Ok(graph)
    }
    
    fn graph_coloring(&self, graph: &Graph<String>) -> Result<HashMap<String, String>, CompilationError> {
        let mut coloring = HashMap::new();
        let mut stack = Vec::new();
        let mut graph_copy = graph.clone();
        
        // 简化阶段：移除度数小于寄存器数量的节点
        while graph_copy.node_count() > 0 {
            let mut removed = false;
            for node in graph_copy.nodes() {
                if graph_copy.degree(&node) < self.available_registers.len() {
                    stack.push(node.clone());
                    graph_copy.remove_node(&node);
                    removed = true;
                    break;
                }
            }
            
            if !removed {
                // 需要溢出
                let node_to_spill = graph_copy.nodes().next().unwrap().clone();
                stack.push(node_to_spill.clone());
                graph_copy.remove_node(&node_to_spill);
            }
        }
        
        // 着色阶段
        while let Some(node) = stack.pop() {
            let used_colors: HashSet<_> = graph.neighbors(&node)
                .filter_map(|neighbor| coloring.get(neighbor))
                .collect();
            
            for color in &self.available_registers {
                if !used_colors.contains(color) {
                    coloring.insert(node, color.clone());
                    break;
                }
            }
            
            // 如果没有可用颜色，标记为溢出
            if !coloring.contains_key(&node) {
                self.spilled_variables.push(node);
            }
        }
        
        Ok(coloring)
    }
    
    fn assign_registers(&mut self, instruction: &mut ThreeAddressCode, coloring: &HashMap<String, String>) -> Result<(), CompilationError> {
        match instruction {
            ThreeAddressCode::Assignment(result, left, _, right) => {
                if let Some(reg) = coloring.get(result) {
                    *result = reg.clone();
                }
                if let Some(reg) = coloring.get(left) {
                    *left = reg.clone();
                }
                if let Some(right_var) = right {
                    if let Some(reg) = coloring.get(right_var) {
                        *right_var = reg.clone();
                    }
                }
            },
            _ => {},
        }
        Ok(())
    }
    
    fn compute_live_ranges(&self, code: &[ThreeAddressCode]) -> Result<HashMap<String, (usize, usize)>, CompilationError> {
        let mut live_ranges = HashMap::new();
        let mut variable_defs = HashMap::new();
        let mut variable_uses = HashMap::new();
        
        for (i, instruction) in code.iter().enumerate() {
            match instruction {
                ThreeAddressCode::Assignment(result, left, _, right) => {
                    variable_defs.insert(result.clone(), i);
                    variable_uses.entry(left.clone()).or_insert_with(Vec::new).push(i);
                    if let Some(right_var) = right {
                        variable_uses.entry(right_var.clone()).or_insert_with(Vec::new).push(i);
                    }
                },
                _ => {},
            }
        }
        
        for (variable, def_pos) in variable_defs {
            let uses = variable_uses.get(&variable).unwrap_or(&Vec::new());
            let last_use = uses.iter().max().unwrap_or(&def_pos);
            live_ranges.insert(variable, (def_pos, *last_use));
        }
        
        Ok(live_ranges)
    }
    
    fn ranges_overlap(&self, range1: &(usize, usize), range2: &(usize, usize)) -> bool {
        range1.0 <= range2.1 && range2.0 <= range1.1
    }
}

// 简单的图实现
#[derive(Debug, Clone)]
pub struct Graph<T> {
    nodes: HashSet<T>,
    edges: HashMap<T, HashSet<T>>,
}

impl<T: Clone + Eq + std::hash::Hash> Graph<T> {
    pub fn new() -> Self {
        Self {
            nodes: HashSet::new(),
            edges: HashMap::new(),
        }
    }
    
    pub fn add_node(&mut self, node: T) {
        self.nodes.insert(node.clone());
        self.edges.entry(node).or_insert_with(HashSet::new);
    }
    
    pub fn add_edge(&mut self, from: T, to: T) {
        self.edges.entry(from.clone()).or_insert_with(HashSet::new).insert(to.clone());
        self.edges.entry(to).or_insert_with(HashSet::new).insert(from);
    }
    
    pub fn remove_node(&mut self, node: &T) {
        self.nodes.remove(node);
        self.edges.remove(node);
        for edges in self.edges.values_mut() {
            edges.remove(node);
        }
    }
    
    pub fn nodes(&self) -> impl Iterator<Item = &T> {
        self.nodes.iter()
    }
    
    pub fn neighbors(&self, node: &T) -> impl Iterator<Item = &T> {
        self.edges.get(node).map(|edges| edges.iter()).unwrap_or([].iter())
    }
    
    pub fn degree(&self, node: &T) -> usize {
        self.edges.get(node).map(|edges| edges.len()).unwrap_or(0)
    }
    
    pub fn node_count(&self) -> usize {
        self.nodes.len()
    }
}
```

### 4.2 指令选择

```rust
// 指令选择器
pub struct InstructionSelector {
    target_architecture: TargetArchitecture,
    instruction_patterns: Vec<InstructionPattern>,
}

impl InstructionSelector {
    pub fn new(architecture: TargetArchitecture) -> Self {
        let instruction_patterns = Self::build_instruction_patterns(architecture);
        
        Self {
            target_architecture: architecture,
            instruction_patterns,
        }
    }
    
    pub fn select_instructions(&self, code: &[ThreeAddressCode]) -> Result<Vec<AssemblyInstruction>, CompilationError> {
        let mut assembly_code = Vec::new();
        
        for instruction in code {
            let assembly_instructions = self.translate_instruction(instruction)?;
            assembly_code.extend(assembly_instructions);
        }
        
        Ok(assembly_code)
    }
    
    fn translate_instruction(&self, instruction: &ThreeAddressCode) -> Result<Vec<AssemblyInstruction>, CompilationError> {
        match instruction {
            ThreeAddressCode::Assignment(result, left, Some(op), Some(right)) => {
                self.translate_binary_operation(result, left, op, right)
            },
            ThreeAddressCode::Assignment(result, value, None, None) => {
                self.translate_assignment(result, value)
            },
            ThreeAddressCode::Goto(label) => {
                Ok(vec![AssemblyInstruction::Jump(label.clone())])
            },
            ThreeAddressCode::IfGoto(condition, true_label, false_label) => {
                self.translate_conditional_jump(condition, true_label, false_label)
            },
            _ => Err(CompilationError::TargetGenerationError("Unsupported instruction".to_string())),
        }
    }
    
    fn translate_binary_operation(
        &self,
        result: &str,
        left: &str,
        op: &Operator,
        right: &str,
    ) -> Result<Vec<AssemblyInstruction>, CompilationError> {
        let mut instructions = Vec::new();
        
        // 加载左操作数到寄存器
        instructions.push(AssemblyInstruction::Load("r1".to_string(), left.to_string()));
        
        // 加载右操作数到寄存器
        instructions.push(AssemblyInstruction::Load("r2".to_string(), right.to_string()));
        
        // 执行操作
        let operation = match op {
            Operator::Add => "ADD",
            Operator::Sub => "SUB",
            Operator::Mul => "MUL",
            Operator::Div => "DIV",
            _ => return Err(CompilationError::TargetGenerationError("Unsupported operator".to_string())),
        };
        
        instructions.push(AssemblyInstruction::Arithmetic(operation.to_string(), "r1".to_string(), "r2".to_string()));
        
        // 存储结果
        instructions.push(AssemblyInstruction::Store(result.to_string(), "r1".to_string()));
        
        Ok(instructions)
    }
    
    fn translate_assignment(&self, result: &str, value: &str) -> Result<Vec<AssemblyInstruction>, CompilationError> {
        Ok(vec![
            AssemblyInstruction::Load("r1".to_string(), value.to_string()),
            AssemblyInstruction::Store(result.to_string(), "r1".to_string()),
        ])
    }
    
    fn translate_conditional_jump(
        &self,
        condition: &str,
        true_label: &str,
        false_label: &str,
    ) -> Result<Vec<AssemblyInstruction>, CompilationError> {
        Ok(vec![
            AssemblyInstruction::Load("r1".to_string(), condition.to_string()),
            AssemblyInstruction::Compare("r1".to_string(), "0".to_string()),
            AssemblyInstruction::JumpIfNotZero(true_label.to_string()),
            AssemblyInstruction::Jump(false_label.to_string()),
        ])
    }
    
    fn build_instruction_patterns(architecture: TargetArchitecture) -> Vec<InstructionPattern> {
        match architecture {
            TargetArchitecture::X86 => vec![
                InstructionPattern::new("ADD", vec!["reg", "reg"]),
                InstructionPattern::new("SUB", vec!["reg", "reg"]),
                InstructionPattern::new("MOV", vec!["reg", "imm"]),
            ],
            TargetArchitecture::ARM => vec![
                InstructionPattern::new("ADD", vec!["reg", "reg", "reg"]),
                InstructionPattern::new("SUB", vec!["reg", "reg", "reg"]),
                InstructionPattern::new("LDR", vec!["reg", "imm"]),
            ],
        }
    }
}

#[derive(Debug, Clone)]
pub enum AssemblyInstruction {
    Load(String, String),      // Load destination, source
    Store(String, String),     // Store destination, source
    Arithmetic(String, String, String), // Operation, operand1, operand2
    Compare(String, String),   // Compare operand1, operand2
    Jump(String),              // Jump to label
    JumpIfZero(String),        // Jump if zero to label
    JumpIfNotZero(String),     // Jump if not zero to label
    Label(String),             // Label definition
}

#[derive(Debug, Clone)]
pub struct InstructionPattern {
    mnemonic: String,
    operands: Vec<String>,
}

impl InstructionPattern {
    pub fn new(mnemonic: String, operands: Vec<String>) -> Self {
        Self { mnemonic, operands }
    }
}

#[derive(Debug, Clone)]
pub enum TargetArchitecture {
    X86,
    ARM,
    RISC_V,
}
```

## 5. 交叉引用

- [[00-编程语言理论总论|编程语言理论总论]]
- [[01-语言设计原则|语言设计原则]]
- [[02-语法和语义|语法和语义]]
- [[04-类型系统|类型系统]]

## 导航

- [返回总目录](../README.md)
- [编程语言理论总论](00-编程语言理论总论.md)
- [语言设计原则](01-语言设计原则.md)
- [语法和语义](02-语法和语义.md)
- [类型系统](04-类型系统.md)
