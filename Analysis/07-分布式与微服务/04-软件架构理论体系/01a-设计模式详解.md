# 设计模式详解-主题树形目录

1. [软件架构理论统一总论](00-软件架构理论统一总论.md)
2. [架构模式理论](01-架构模式理论.md)
   2.1 [设计模式详解](01a-设计模式详解.md)

## 设计模式详解

设计模式是在软件工程中，针对在特定上下文中反复出现的问题，所提出的经过验证的、可重用的解决方案。它们是独立于具体编程语言的经验总结，旨在提高代码的可重用性、灵活性和可维护性。

## 目录

- [设计模式详解-主题树形目录](#设计模式详解-主题树形目录)
  - [设计模式详解](#设计模式详解)
  - [目录](#目录)
  - [1. 设计模式原则](#1-设计模式原则)
  - [2. 创建型模式 (Creational Patterns)](#2-创建型模式-creational-patterns)
    - [2.1 工厂方法 (Factory Method)](#21-工厂方法-factory-method)
    - [2.2 抽象工厂 (Abstract Factory)](#22-抽象工厂-abstract-factory)
    - [2.3 建造者 (Builder)](#23-建造者-builder)
    - [2.4 原型 (Prototype)](#24-原型-prototype)
    - [2.5 单例 (Singleton)](#25-单例-singleton)
  - [3. 结构型模式 (Structural Patterns)](#3-结构型模式-structural-patterns)
    - [3.1 适配器 (Adapter)](#31-适配器-adapter)
    - [3.2 桥接 (Bridge)](#32-桥接-bridge)
    - [3.3 组合 (Composite)](#33-组合-composite)
    - [3.4 装饰器 (Decorator)](#34-装饰器-decorator)
    - [3.5 外观 (Facade)](#35-外观-facade)
    - [3.6 享元 (Flyweight)](#36-享元-flyweight)
  - [4. 行为型模式 (Behavioral Patterns)](#4-行为型模式-behavioral-patterns)
    - [4.1 责任链 (Chain of Responsibility)](#41-责任链-chain-of-responsibility)
    - [4.2 命令 (Command)](#42-命令-command)
    - [4.3 迭代器 (Iterator)](#43-迭代器-iterator)
    - [4.4 中介者 (Mediator)](#44-中介者-mediator)
    - [4.5 观察者 (Observer)](#45-观察者-observer)
    - [4.6 状态 (State)](#46-状态-state)
    - [4.7 策略 (Strategy)](#47-策略-strategy)
    - [4.8 解释器 (Interpreter)](#48-解释器-interpreter)
  - [5. 并发与并行模式 (Concurrent \& Parallel Patterns)](#5-并发与并行模式-concurrent--parallel-patterns)
    - [5.1 并行模式](#51-并行模式)
    - [5.2 并发模式](#52-并发模式)
    - [5.3 同步模式](#53-同步模式)
    - [5.4 数据共享模式](#54-数据共享模式)
    - [5.5 任务分解与调度模式](#55-任务分解与调度模式)
  - [2025 对齐](#2025-对齐)

## 1. 设计模式原则

(待补充)

## 2. 创建型模式 (Creational Patterns)

这些模式提供了对象创建的机制，增加了现有代码的灵活性和重用性。

### 2.1 工厂方法 (Factory Method)

**意图**: 定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。

**形式化描述**（与 [06-形式模型理论体系](../../06-形式模型理论体系/00-形式模型理论体系总论.md) 状态机视角一致）：设产品类型集合为 \(P\)，创建者类型为 \(C\)。工厂方法对应映射 \(\phi : C \times \text{Context} \to P\)，满足：同一创建者在不同上下文可产出不同具体产品，且客户仅依赖抽象 \(P\)。类图可视为 [06-软件架构理论体系/01-架构模式理论](../../06-软件架构理论体系/01-架构模式理论.md) 中组件-连接器的一种特例（创建关系）。

**最小代码示例**（伪代码）：

```text
abstract class Product { }
abstract class Creator {
  abstract Product factoryMethod();
  void operation() { use(factoryMethod()); }
}
class ConcreteProductA extends Product { }
class ConcreteCreatorA extends Creator {
  Product factoryMethod() { return new ConcreteProductA(); }
}
```

**相关**：[架构模式理论](../../06-软件架构理论体系/01-架构模式理论.md)（分层、MVC）、[形式模型理论体系总论](../../06-形式模型理论体系/00-形式模型理论体系总论.md)（状态与抽象）。

### 2.2 抽象工厂 (Abstract Factory)

**意图**: 提供一个接口，用于创建一系列相关或相互依赖的对象，而无需指定它们具体的类。
(待补充详细内容、形式化描述和代码示例)

### 2.3 建造者 (Builder)

**意图**: 将一个复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示。
(待补充详细内容、形式化描述和代码示例)

### 2.4 原型 (Prototype)

**意图**: 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
(待补充详细内容、形式化描述和代码示例)

### 2.5 单例 (Singleton)

**意图**: 保证一个类仅有一个实例，并提供一个访问它的全局访问点。
(待补充详细内容、形式化描述和代码示例)

## 3. 结构型模式 (Structural Patterns)

这些模式处理对象组合，通常涉及类或对象之间的关系，以形成更大的结构。

### 3.1 适配器 (Adapter)

**意图**: 将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

**形式化描述**：设目标接口为 \(T\)，被适配者接口为 \(A\)。适配器实现从 \(A\) 到 \(T\) 的**接口同构**（双射或满射）：对客户可见的 \(T\) 的每个操作，存在从 \(A\) 的操作到 \(T\) 的映射。这与 [06-形式模型理论体系](../../06-形式模型理论体系/00-形式模型理论体系总论.md) 中的“行为等价/互模拟”一致：适配后系统对外行为等价于仅使用 \(T\) 的客户期望。结构上属于 [06-软件架构理论体系/01-架构模式理论](../../06-软件架构理论体系/01-架构模式理论.md) 的包装/桥接式组件。

**最小代码示例**（伪代码）：

```text
interface Target { void request(); }
class Adaptee { void specificRequest() { /* 已有实现 */ } }
class Adapter implements Target {
  private Adaptee a;
  Adapter(Adaptee a) { this.a = a; }
  void request() { a.specificRequest(); }
}
// 客户: Target t = new Adapter(new Adaptee()); t.request();
```

**相关**：[形式模型理论体系总论](../../06-形式模型理论体系/00-形式模型理论体系总论.md)（行为等价、接口规约）、[架构模式理论](../../06-软件架构理论体系/01-架构模式理论.md)（分层与接口）。

### 3.2 桥接 (Bridge)

**意图**: 将抽象部分与它的实现部分分离，使它们都可以独立地变化。
(待补充详细内容、形式化描述和代码示例)

### 3.3 组合 (Composite)

**意图**: 将对象组合成树形结构以表示"部分-整体"的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。
(待补充详细内容、形式化描述和代码示例)

### 3.4 装饰器 (Decorator)

**意图**: 动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。
(待补充详细内容、形式化描述和代码示例)

### 3.5 外观 (Facade)

**意图**: 为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。
(待补充详细内容、形式化描述和代码示例)

### 3.6 享元 (Flyweight)

**意图**: 运用共享技术有效地支持大量细粒度的对象。
(待补充详细内容、形式化描述和代码示例)

## 4. 行为型模式 (Behavioral Patterns)

这些模式关注对象之间的交互以及它们如何分配责任。

### 4.1 责任链 (Chain of Responsibility)

**意图**: 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。
(待补充详细内容、形式化描述和代码示例)

### 4.2 命令 (Command)

**意图**: 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。
(待补充详细内容、形式化描述和代码示例)

### 4.3 迭代器 (Iterator)

**意图**: 提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。
(待补充详细内容、形式化描述和代码示例)

### 4.4 中介者 (Mediator)

**意图**: 用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。
(待补充详细内容、形式化描述和代码示例)

### 4.5 观察者 (Observer)

**意图**: 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。

**形式化描述**：设主体（Subject）状态空间为 \(S\)，观察者集合为 \(O\)。观察者模式可建模为 [06-形式模型理论体系](../../06-形式模型理论体系/00-形式模型理论体系总论.md) 中的**事件/状态传播**：状态迁移 \(\delta: S \times \text{Event} \to S\) 触发通知函数 \(\text{notify}: O \to \text{Unit}\)，满足“状态一致”：所有观察者看到的主体状态在通知后与当前 \(S\) 一致。与事件驱动架构（[06-软件架构理论体系/01-架构模式理论](../../06-软件架构理论体系/01-架构模式理论.md) 第5节事件驱动架构模式）同属发布-订阅语义。

**最小代码示例**（伪代码）：

```text
interface Observer { void update(Subject s); }
abstract class Subject {
  private List<Observer> obs = new ArrayList<>();
  void attach(Observer o) { obs.add(o); }
  void notifyObservers() { for (Observer o : obs) o.update(this); }
}
class ConcreteSubject extends Subject {
  private int state;
  void setState(int s) { state = s; notifyObservers(); }
}
```

**相关**：[形式模型理论体系总论](../../06-形式模型理论体系/00-形式模型理论体系总论.md)（状态机、时序逻辑）、[架构模式理论-事件驱动](../../06-软件架构理论体系/01-架构模式理论.md#5-事件驱动架构模式)（事件总线、Saga）。

### 4.6 状态 (State)

**意图**: 允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。
(待补充详细内容、形式化描述和代码示例)

### 4.7 策略 (Strategy)

**意图**: 定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。
(待补充详细内容、形式化描述和代码示例)

### 4.8 解释器 (Interpreter)

**意图**: 给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。
(待补充详细内容、形式化描述和代码示例)

## 5. 并发与并行模式 (Concurrent & Parallel Patterns)

这些模式主要关注如何有效地利用多核处理器和多线程来提高程序的执行效率和处理并发任务。

### 5.1 并行模式

- **流水线 (Pipeline)**: 将任务分解成多个阶段，每个阶段可以并行处理。
- **主从模式 (Master-Worker)**: 一个主节点分配任务给多个工作节点并行执行。
(待补充详细内容、形式化描述和代码示例)

### 5.2 并发模式

- **线程池 (Thread Pool)**: 预先创建一组线程，用于执行任务，避免频繁创建和销毁线程的开销。
- **Future 与 Promise**: 用于处理异步操作的结果。
- **反应器 (Reactor)**: 通过非阻塞I/O处理多个I/O请求。
- **Proactor**: 用于异步I/O操作，在操作完成时通知应用程序。
- **Actor 模型**: 将并发实体建模为Actor，通过消息传递进行通信。
(待补充详细内容、形式化描述和代码示例)

### 5.3 同步模式

- **锁/互斥锁 (Lock/Mutex)**: 控制对共享资源的独占访问。
- **信号量 (Semaphore)**: 控制对共享资源的访问数量。
- **屏障 (Barrier)**: 确保所有线程在继续执行前都到达某个点。
- **监视器对象 (Monitor Object)**: 封装了所有对共享资源的同步访问。
(待补充详细内容、形式化描述和代码示例)

### 5.4 数据共享模式

- **读写锁 (Read-Write Lock)**: 允许多个读线程，但写线程独占。
- **写时复制 (Copy-on-Write)**: 在修改数据前先复制，以减少锁定。
(待补充详细内容、形式化描述和代码示例)

### 5.5 任务分解与调度模式

- **任务分解 (Task Decomposition)**: 将大任务分解为多个可在不同线程中并行执行的小任务。
- **工作窃取 (Work Stealing)**: 空闲线程从其他线程的任务队列中"窃取"任务来执行，以实现负载均衡。
(待补充详细内容、形式化描述和代码示例)

## 2025 对齐

- **国际 Wiki**：
  - [Wikipedia: Design Patterns](https://en.wikipedia.org/wiki/Design_Patterns)
  - [Wikipedia: Software design pattern](https://en.wikipedia.org/wiki/Software_design_pattern)
  - [Wikipedia: Creational pattern](https://en.wikipedia.org/wiki/Creational_pattern)
  - [Wikipedia: Structural pattern](https://en.wikipedia.org/wiki/Structural_pattern)
  - [Wikipedia: Behavioral pattern](https://en.wikipedia.org/wiki/Behavioral_pattern)

- **名校课程**：
  - [CMU 17-313: Foundations of Software Engineering](https://www.cs.cmu.edu/~ckaestne/17313/)（设计模式实践）
  - [MIT 6.170: Software Studio](https://web.mit.edu/6.170/www/)（软件设计）
  - [Stanford CS 108: Object-Oriented System Design](https://web.stanford.edu/class/cs108/)（面向对象设计）

- **代表性论文**：
  - [Design Patterns: Elements of Reusable Object-Oriented Software](https://en.wikipedia.org/wiki/Design_Patterns) (Gang of Four, 1994)
  - [Pattern Languages of Program Design](https://www.hillside.net/plop/) (PLoP Conference Series)
  - [Refactoring: Improving the Design of Existing Code](https://refactoring.com/) (Fowler, 1999)

- **前沿技术**：
  - [Spring Framework](https://spring.io/)（企业级Java应用框架，实现多种设计模式）
  - [.NET Design Patterns](https://dotnet.microsoft.com/apps/aspnet)（Microsoft设计模式实现）
  - [Head First Design Patterns](https://www.oreilly.com/library/view/head-first-design/0596007124/)（设计模式学习资源）

- **对齐状态**：已完成（最后更新：2025-01-15）
