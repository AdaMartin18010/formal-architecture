# 自动机理论

## 概述

自动机理论是形式语言理论的核心，研究抽象的计算模型。在软件架构中，自动机为状态机设计、协议验证和系统建模提供了理论基础。

## 1. 基本概念

### 1.1 有限自动机

有限自动机是最基本的自动机模型，用于识别正则语言。

#### 形式化定义

```latex
M = (Q, \Sigma, \delta, q_0, F)
```

其中：

- $Q$ 是有限状态集
- $\Sigma$ 是输入字母表
- $\delta: Q \times \Sigma \rightarrow Q$ 是转移函数
- $q_0 \in Q$ 是初始状态
- $F \subseteq Q$ 是接受状态集

### 1.2 自动机类型

#### 确定性有限自动机 (DFA)

```latex
\delta: Q \times \Sigma \rightarrow Q
```

#### 非确定性有限自动机 (NFA)

```latex
\delta: Q \times \Sigma \rightarrow 2^Q
```

## 2. 形式化实现

### 2.1 有限自动机实现

```rust
use std::collections::{HashMap, HashSet};

#[derive(Debug, Clone)]
pub struct FiniteAutomaton {
    states: HashSet<String>,
    alphabet: HashSet<char>,
    transitions: HashMap<(String, char), HashSet<String>>,
    initial_state: String,
    accepting_states: HashSet<String>,
}

impl FiniteAutomaton {
    pub fn new(
        states: HashSet<String>,
        alphabet: HashSet<char>,
        initial_state: String,
        accepting_states: HashSet<String>,
    ) -> Self {
        Self {
            states,
            alphabet,
            transitions: HashMap::new(),
            initial_state,
            accepting_states,
        }
    }
    
    pub fn add_transition(&mut self, from: String, symbol: char, to: String) {
        let key = (from, symbol);
        self.transitions.entry(key).or_insert_with(HashSet::new).insert(to);
    }
    
    pub fn accepts(&self, input: &str) -> bool {
        let mut current_states = HashSet::new();
        current_states.insert(self.initial_state.clone());
        
        for symbol in input.chars() {
            let mut next_states = HashSet::new();
            for state in &current_states {
                if let Some(transitions) = self.transitions.get(&(state.clone(), symbol)) {
                    for next_state in transitions {
                        next_states.insert(next_state.clone());
                    }
                }
            }
            current_states = next_states;
        }
        
        current_states.iter().any(|state| self.accepting_states.contains(state))
    }
    
    pub fn is_deterministic(&self) -> bool {
        for ((_, _), targets) in &self.transitions {
            if targets.len() > 1 {
                return false;
            }
        }
        true
    }
    
    pub fn to_dfa(&self) -> FiniteAutomaton {
        if self.is_deterministic() {
            return self.clone();
        }
        
        // 子集构造法
        let mut dfa_states = HashSet::new();
        let mut dfa_transitions = HashMap::new();
        let mut dfa_accepting = HashSet::new();
        
        // 初始状态
        let initial_dfa_state = format!("{{{}}}", self.initial_state);
        dfa_states.insert(initial_dfa_state.clone());
        
        let mut unprocessed_states = vec![vec![self.initial_state.clone()]];
        
        while let Some(current_nfa_states) = unprocessed_states.pop() {
            let current_dfa_state = format!("{{{}}}", current_nfa_states.join(","));
            
            // 检查是否为接受状态
            if current_nfa_states.iter().any(|s| self.accepting_states.contains(s)) {
                dfa_accepting.insert(current_dfa_state.clone());
            }
            
            // 为每个输入符号计算转移
            for symbol in &self.alphabet {
                let mut next_nfa_states = HashSet::new();
                
                for nfa_state in &current_nfa_states {
                    if let Some(transitions) = self.transitions.get(&(nfa_state.clone(), *symbol)) {
                        for next_state in transitions {
                            next_nfa_states.insert(next_state.clone());
                        }
                    }
                }
                
                if !next_nfa_states.is_empty() {
                    let next_nfa_states_vec: Vec<String> = next_nfa_states.iter().cloned().collect();
                    let next_dfa_state = format!("{{{}}}", next_nfa_states_vec.join(","));
                    
                    dfa_states.insert(next_dfa_state.clone());
                    dfa_transitions.insert((current_dfa_state.clone(), *symbol), next_dfa_state);
                    
                    // 如果这是新状态，加入待处理列表
                    if !unprocessed_states.contains(&next_nfa_states_vec) {
                        unprocessed_states.push(next_nfa_states_vec);
                    }
                }
            }
        }
        
        FiniteAutomaton {
            states: dfa_states,
            alphabet: self.alphabet.clone(),
            transitions: dfa_transitions,
            initial_state: initial_dfa_state,
            accepting_states: dfa_accepting,
        }
    }
    
    pub fn minimize(&self) -> FiniteAutomaton {
        let dfa = if self.is_deterministic() {
            self.clone()
        } else {
            self.to_dfa()
        };
        
        // Hopcroft算法实现最小化
        let mut partitions = vec![
            dfa.accepting_states.clone(),
            dfa.states.difference(&dfa.accepting_states).cloned().collect(),
        ];
        
        loop {
            let mut new_partitions = Vec::new();
            for partition in &partitions {
                if partition.len() <= 1 {
                    new_partitions.push(partition.clone());
                    continue;
                }
                
                let mut refined = dfa.refine_partition(partition, &partitions);
                new_partitions.append(&mut refined);
            }
            
            if new_partitions.len() == partitions.len() {
                break;
            }
            partitions = new_partitions;
        }
        
        dfa.build_minimized_automaton(&partitions)
    }
    
    fn refine_partition(&self, partition: &HashSet<String>, partitions: &[HashSet<String>]) -> Vec<HashSet<String>> {
        let mut refined = Vec::new();
        let mut groups = HashMap::new();
        
        for state in partition {
            let mut signature = Vec::new();
            for symbol in &self.alphabet {
                let mut target_partition = 0;
                if let Some(transitions) = self.transitions.get(&(state.clone(), *symbol)) {
                    for target in transitions {
                        for (i, partition) in partitions.iter().enumerate() {
                            if partition.contains(target) {
                                target_partition = i;
                                break;
                            }
                        }
                    }
                }
                signature.push(target_partition);
            }
            groups.entry(signature).or_insert_with(Vec::new).push(state.clone());
        }
        
        for group in groups.values() {
            refined.push(group.iter().cloned().collect());
        }
        
        refined
    }
    
    fn build_minimized_automaton(&self, partitions: &[HashSet<String>]) -> FiniteAutomaton {
        let mut minimized = FiniteAutomaton::new(
            (0..partitions.len()).map(|i| i.to_string()).collect(),
            self.alphabet.clone(),
            self.find_partition_index(&self.initial_state, partitions).to_string(),
            HashSet::new(),
        );
        
        // 设置接受状态
        for (i, partition) in partitions.iter().enumerate() {
            if partition.iter().any(|state| self.accepting_states.contains(state)) {
                minimized.accepting_states.insert(i.to_string());
            }
        }
        
        // 设置转移
        for (i, partition) in partitions.iter().enumerate() {
            for state in partition {
                for symbol in &self.alphabet {
                    if let Some(transitions) = self.transitions.get(&(state.clone(), *symbol)) {
                        for target in transitions {
                            let target_partition = self.find_partition_index(target, partitions);
                            minimized.add_transition(i.to_string(), *symbol, target_partition.to_string());
                        }
                    }
                }
            }
        }
        
        minimized
    }
    
    fn find_partition_index(&self, state: &str, partitions: &[HashSet<String>]) -> usize {
        for (i, partition) in partitions.iter().enumerate() {
            if partition.contains(state) {
                return i;
            }
        }
        0
    }
}
```

### 2.2 下推自动机实现

```rust
#[derive(Debug, Clone)]
pub struct PushdownAutomaton {
    states: HashSet<String>,
    input_alphabet: HashSet<char>,
    stack_alphabet: HashSet<char>,
    transitions: Vec<PDATransition>,
    initial_state: String,
    initial_stack_symbol: char,
    accepting_states: HashSet<String>,
}

#[derive(Debug, Clone)]
pub struct PDATransition {
    from_state: String,
    input_symbol: Option<char>,
    stack_top: char,
    to_state: String,
    stack_push: Vec<char>,
}

impl PushdownAutomaton {
    pub fn new(
        states: HashSet<String>,
        input_alphabet: HashSet<char>,
        stack_alphabet: HashSet<char>,
        initial_state: String,
        initial_stack_symbol: char,
        accepting_states: HashSet<String>,
    ) -> Self {
        Self {
            states,
            input_alphabet,
            stack_alphabet,
            transitions: Vec::new(),
            initial_state,
            initial_stack_symbol,
            accepting_states,
        }
    }
    
    pub fn add_transition(
        &mut self,
        from_state: String,
        input_symbol: Option<char>,
        stack_top: char,
        to_state: String,
        stack_push: Vec<char>,
    ) {
        self.transitions.push(PDATransition {
            from_state,
            input_symbol,
            stack_top,
            to_state,
            stack_push,
        });
    }
    
    pub fn accepts(&self, input: &str) -> bool {
        let mut configurations = vec![PDAConfiguration {
            state: self.initial_state.clone(),
            input_remaining: input.chars().collect(),
            stack: vec![self.initial_stack_symbol],
        }];
        
        while !configurations.is_empty() {
            let mut next_configurations = Vec::new();
            
            for config in configurations {
                if config.input_remaining.is_empty() && self.accepting_states.contains(&config.state) {
                    return true;
                }
                
                for transition in &self.transitions {
                    if transition.from_state == config.state
                        && config.stack.last() == Some(&transition.stack_top)
                        && (transition.input_symbol.is_none()
                            || config.input_remaining.first() == transition.input_symbol.as_ref())
                    {
                        let mut new_stack = config.stack.clone();
                        new_stack.pop(); // 移除栈顶
                        for symbol in transition.stack_push.iter().rev() {
                            new_stack.push(*symbol);
                        }
                        
                        let mut new_input = config.input_remaining.clone();
                        if transition.input_symbol.is_some() {
                            new_input.remove(0);
                        }
                        
                        next_configurations.push(PDAConfiguration {
                            state: transition.to_state.clone(),
                            input_remaining: new_input,
                            stack: new_stack,
                        });
                    }
                }
            }
            
            configurations = next_configurations;
        }
        
        false
    }
    
    pub fn is_deterministic(&self) -> bool {
        for i in 0..self.transitions.len() {
            for j in i + 1..self.transitions.len() {
                let t1 = &self.transitions[i];
                let t2 = &self.transitions[j];
                
                if t1.from_state == t2.from_state
                    && t1.stack_top == t2.stack_top
                    && t1.input_symbol == t2.input_symbol
                {
                    return false;
                }
            }
        }
        true
    }
}

#[derive(Debug, Clone)]
pub struct PDAConfiguration {
    state: String,
    input_remaining: Vec<char>,
    stack: Vec<char>,
}
```

### 2.3 图灵机实现

```rust
#[derive(Debug, Clone)]
pub struct TuringMachine {
    states: HashSet<String>,
    input_alphabet: HashSet<char>,
    tape_alphabet: HashSet<char>,
    transitions: HashMap<(String, char), TuringTransition>,
    initial_state: String,
    blank_symbol: char,
    accepting_states: HashSet<String>,
    rejecting_states: HashSet<String>,
}

#[derive(Debug, Clone)]
pub struct TuringTransition {
    to_state: String,
    write_symbol: char,
    move_direction: MoveDirection,
}

#[derive(Debug, Clone)]
pub enum MoveDirection {
    Left,
    Right,
    Stay,
}

impl TuringMachine {
    pub fn new(
        states: HashSet<String>,
        input_alphabet: HashSet<char>,
        tape_alphabet: HashSet<char>,
        initial_state: String,
        blank_symbol: char,
        accepting_states: HashSet<String>,
        rejecting_states: HashSet<String>,
    ) -> Self {
        Self {
            states,
            input_alphabet,
            tape_alphabet,
            transitions: HashMap::new(),
            initial_state,
            blank_symbol,
            accepting_states,
            rejecting_states,
        }
    }
    
    pub fn add_transition(
        &mut self,
        from_state: String,
        read_symbol: char,
        to_state: String,
        write_symbol: char,
        move_direction: MoveDirection,
    ) {
        self.transitions.insert(
            (from_state, read_symbol),
            TuringTransition {
                to_state,
                write_symbol,
                move_direction,
            },
        );
    }
    
    pub fn run(&self, input: &str) -> TuringResult {
        let mut tape = input.chars().collect::<Vec<char>>();
        let mut head_position = 0;
        let mut current_state = self.initial_state.clone();
        let mut step_count = 0;
        let max_steps = 10000; // 防止无限循环
        
        while step_count < max_steps {
            if self.accepting_states.contains(&current_state) {
                return TuringResult::Accept(tape);
            }
            
            if self.rejecting_states.contains(&current_state) {
                return TuringResult::Reject(tape);
            }
            
            // 扩展磁带如果需要
            while head_position >= tape.len() {
                tape.push(self.blank_symbol);
            }
            while head_position < 0 {
                tape.insert(0, self.blank_symbol);
                head_position += 1;
            }
            
            let current_symbol = tape[head_position];
            let key = (current_state.clone(), current_symbol);
            
            if let Some(transition) = self.transitions.get(&key) {
                tape[head_position] = transition.write_symbol;
                current_state = transition.to_state.clone();
                
                match transition.move_direction {
                    MoveDirection::Left => head_position -= 1,
                    MoveDirection::Right => head_position += 1,
                    MoveDirection::Stay => {}
                }
            } else {
                return TuringResult::Reject(tape);
            }
            
            step_count += 1;
        }
        
        TuringResult::Timeout(tape)
    }
    
    pub fn is_deterministic(&self) -> bool {
        // 图灵机默认是确定性的
        true
    }
    
    pub fn simulate_universal_turing_machine(&self, program: &str, input: &str) -> TuringResult {
        // 通用图灵机模拟
        // 这里实现一个简化的通用图灵机
        self.run(input)
    }
}

#[derive(Debug, Clone)]
pub enum TuringResult {
    Accept(Vec<char>),
    Reject(Vec<char>),
    Timeout(Vec<char>),
}
```

## 3. 软件架构应用

### 3.1 状态机设计

```rust
// 基于自动机的状态机
pub struct StateMachine {
    automaton: FiniteAutomaton,
    current_state: String,
    event_handlers: HashMap<(String, char), Box<dyn Fn() -> ()>>,
    state_handlers: HashMap<String, Box<dyn Fn() -> ()>>,
}

impl StateMachine {
    pub fn new(automaton: FiniteAutomaton) -> Self {
        Self {
            current_state: automaton.initial_state.clone(),
            automaton,
            event_handlers: HashMap::new(),
            state_handlers: HashMap::new(),
        }
    }
    
    pub fn add_event_handler<F>(&mut self, state: String, event: char, handler: F)
    where
        F: Fn() -> () + 'static,
    {
        self.event_handlers.insert((state, event), Box::new(handler));
    }
    
    pub fn add_state_handler<F>(&mut self, state: String, handler: F)
    where
        F: Fn() -> () + 'static,
    {
        self.state_handlers.insert(state, Box::new(handler));
    }
    
    pub fn trigger_event(&mut self, event: char) -> Result<(), String> {
        let key = (self.current_state.clone(), event);
        
        // 执行事件处理器
        if let Some(handler) = self.event_handlers.get(&key) {
            handler();
        }
        
        // 检查转移
        if let Some(transitions) = self.automaton.transitions.get(&key) {
            if let Some(next_state) = transitions.iter().next() {
                // 执行状态退出处理器
                if let Some(exit_handler) = self.state_handlers.get(&self.current_state) {
                    exit_handler();
                }
                
                self.current_state = next_state.clone();
                
                // 执行状态进入处理器
                if let Some(enter_handler) = self.state_handlers.get(&self.current_state) {
                    enter_handler();
                }
                
                Ok(())
            } else {
                Err(format!("No transition for event {} in state {}", event, self.current_state))
            }
        } else {
            Err(format!("No transition for event {} in state {}", event, self.current_state))
        }
    }
    
    pub fn get_current_state(&self) -> &str {
        &self.current_state
    }
    
    pub fn is_in_accepting_state(&self) -> bool {
        self.automaton.accepting_states.contains(&self.current_state)
    }
    
    pub fn reset(&mut self) {
        self.current_state = self.automaton.initial_state.clone();
    }
}
```

### 3.2 协议验证

```rust
// 基于自动机的协议验证
pub struct ProtocolVerifier {
    protocol_automaton: FiniteAutomaton,
    safety_properties: Vec<SafetyProperty>,
    liveness_properties: Vec<LivenessProperty>,
}

#[derive(Debug, Clone)]
pub struct SafetyProperty {
    name: String,
    condition: String,
    description: String,
}

#[derive(Debug, Clone)]
pub struct LivenessProperty {
    name: String,
    condition: String,
    description: String,
}

impl ProtocolVerifier {
    pub fn new(protocol_automaton: FiniteAutomaton) -> Self {
        Self {
            protocol_automaton,
            safety_properties: Vec::new(),
            liveness_properties: Vec::new(),
        }
    }
    
    pub fn add_safety_property(&mut self, property: SafetyProperty) {
        self.safety_properties.push(property);
    }
    
    pub fn add_liveness_property(&mut self, property: LivenessProperty) {
        self.liveness_properties.push(property);
    }
    
    pub fn verify_safety(&self, trace: &str) -> Vec<SafetyViolation> {
        let mut violations = Vec::new();
        
        for property in &self.safety_properties {
            if let Some(violation) = self.check_safety_property(property, trace) {
                violations.push(violation);
            }
        }
        
        violations
    }
    
    pub fn verify_liveness(&self, trace: &str) -> Vec<LivenessViolation> {
        let mut violations = Vec::new();
        
        for property in &self.liveness_properties {
            if let Some(violation) = self.check_liveness_property(property, trace) {
                violations.push(violation);
            }
        }
        
        violations
    }
    
    fn check_safety_property(&self, property: &SafetyProperty, trace: &str) -> Option<SafetyViolation> {
        // 简化的安全性检查
        if trace.contains("error") {
            Some(SafetyViolation {
                property: property.clone(),
                trace: trace.to_string(),
                position: trace.find("error").unwrap(),
            })
        } else {
            None
        }
    }
    
    fn check_liveness_property(&self, property: &LivenessProperty, trace: &str) -> Option<LivenessViolation> {
        // 简化的活性检查
        if !trace.contains("success") {
            Some(LivenessViolation {
                property: property.clone(),
                trace: trace.to_string(),
                description: "No success state reached".to_string(),
            })
        } else {
            None
        }
    }
    
    pub fn model_check(&self, property: &str) -> ModelCheckingResult {
        // 简化的模型检查
        ModelCheckingResult {
            property: property.to_string(),
            satisfied: true,
            counterexample: None,
        }
    }
}

#[derive(Debug, Clone)]
pub struct SafetyViolation {
    property: SafetyProperty,
    trace: String,
    position: usize,
}

#[derive(Debug, Clone)]
pub struct LivenessViolation {
    property: LivenessProperty,
    trace: String,
    description: String,
}

#[derive(Debug, Clone)]
pub struct ModelCheckingResult {
    property: String,
    satisfied: bool,
    counterexample: Option<String>,
}
```

### 3.3 系统建模

```rust
// 基于自动机的系统建模
pub struct SystemModel {
    components: HashMap<String, ComponentModel>,
    interactions: Vec<Interaction>,
    global_state: GlobalState,
}

#[derive(Debug, Clone)]
pub struct ComponentModel {
    name: String,
    automaton: FiniteAutomaton,
    current_state: String,
    variables: HashMap<String, Value>,
}

#[derive(Debug, Clone)]
pub struct Interaction {
    source: String,
    target: String,
    event: char,
    condition: Option<String>,
    action: Option<String>,
}

#[derive(Debug, Clone)]
pub struct GlobalState {
    component_states: HashMap<String, String>,
    shared_variables: HashMap<String, Value>,
}

#[derive(Debug, Clone)]
pub enum Value {
    Boolean(bool),
    Integer(i64),
    String(String),
    Object(HashMap<String, Value>),
}

impl SystemModel {
    pub fn new() -> Self {
        Self {
            components: HashMap::new(),
            interactions: Vec::new(),
            global_state: GlobalState {
                component_states: HashMap::new(),
                shared_variables: HashMap::new(),
            },
        }
    }
    
    pub fn add_component(&mut self, component: ComponentModel) {
        self.components.insert(component.name.clone(), component);
        self.global_state.component_states.insert(component.name.clone(), component.current_state.clone());
    }
    
    pub fn add_interaction(&mut self, interaction: Interaction) {
        self.interactions.push(interaction);
    }
    
    pub fn execute_event(&mut self, component_name: &str, event: char) -> Result<(), String> {
        if let Some(component) = self.components.get_mut(component_name) {
            // 检查转移
            let key = (component.current_state.clone(), event);
            if let Some(transitions) = component.automaton.transitions.get(&key) {
                if let Some(next_state) = transitions.iter().next() {
                    component.current_state = next_state.clone();
                    self.global_state.component_states.insert(component_name.to_string(), next_state.clone());
                    
                    // 执行交互
                    self.execute_interactions(component_name, event);
                    
                    Ok(())
                } else {
                    Err(format!("No transition for event {} in component {}", event, component_name))
                }
            } else {
                Err(format!("No transition for event {} in component {}", event, component_name))
            }
        } else {
            Err(format!("Component {} not found", component_name))
        }
    }
    
    fn execute_interactions(&mut self, source: &str, event: char) {
        for interaction in &self.interactions {
            if interaction.source == source && interaction.event == event {
                // 检查条件
                if let Some(condition) = &interaction.condition {
                    if !self.evaluate_condition(condition) {
                        continue;
                    }
                }
                
                // 执行动作
                if let Some(action) = &interaction.action {
                    self.execute_action(action);
                }
                
                // 触发目标组件
                if let Some(target_component) = self.components.get_mut(&interaction.target) {
                    // 这里可以触发目标组件的事件
                }
            }
        }
    }
    
    fn evaluate_condition(&self, condition: &str) -> bool {
        // 简化的条件求值
        match condition {
            "true" => true,
            "false" => false,
            _ => true,
        }
    }
    
    fn execute_action(&mut self, action: &str) {
        // 简化的动作执行
        println!("Executing action: {}", action);
    }
    
    pub fn get_global_state(&self) -> &GlobalState {
        &self.global_state
    }
    
    pub fn is_system_in_accepting_state(&self) -> bool {
        self.components.values().all(|component| {
            component.automaton.accepting_states.contains(&component.current_state)
        })
    }
    
    pub fn generate_trace(&self, max_steps: usize) -> Vec<String> {
        let mut trace = Vec::new();
        let mut step_count = 0;
        
        while step_count < max_steps && !self.is_system_in_accepting_state() {
            // 随机选择组件和事件
            for (component_name, component) in &self.components {
                for event in &component.automaton.alphabet {
                    let key = (component.current_state.clone(), *event);
                    if component.automaton.transitions.contains_key(&key) {
                        trace.push(format!("{}:{}", component_name, event));
                        break;
                    }
                }
            }
            step_count += 1;
        }
        
        trace
    }
}
```

## 4. 交叉引用

- [[00-形式语言理论总论|形式语言理论总论]]
- [[02-语法分析理论|语法分析理论]]
- [[03-语义分析理论|语义分析理论]]
- [[04-计算理论|计算理论]]
- [[05-编译理论|编译理论]]

## 导航

- [返回总目录](../README.md)
- [返回形式语言理论](00-形式语言理论总论.md)
- [02-语法分析理论](02-语法分析理论.md)
- [03-语义分析理论](03-语义分析理论.md)
- [04-计算理论](04-计算理论.md)
- [05-编译理论](05-编译理论.md)
