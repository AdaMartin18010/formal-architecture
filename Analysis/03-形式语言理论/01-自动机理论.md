# 01-形式语言理论：自动机理论

## 目录

1. [1.1 自动机公理化框架](#11-自动机公理化框架)
2. [1.2 有限状态自动机](#12-有限状态自动机)
3. [1.3 下推自动机](#13-下推自动机)
4. [1.4 图灵机](#14-图灵机)
5. [1.5 自动机等价性](#15-自动机等价性)
6. [1.6 自动机最小化](#16-自动机最小化)
7. [1.7 自动机验证](#17-自动机验证)
8. [1.8 形式化证明](#18-形式化证明)

## 1.1 自动机公理化框架

### 1.1.1 基础定义

**定义 1.1.1 (自动机)**
自动机是一个五元组 $\mathcal{A} = (Q, \Sigma, \delta, q_0, F)$，其中：

- $Q$ 是状态集合
- $\Sigma$ 是输入字母表
- $\delta$ 是转移函数
- $q_0 \in Q$ 是初始状态
- $F \subseteq Q$ 是接受状态集合

**公理 1.1.1 (自动机公理)**
对于任意自动机 $\mathcal{A}$：
1. $Q$ 是非空有限集合
2. $\Sigma$ 是非空有限集合
3. $q_0 \in Q$
4. $F \subseteq Q$

### 1.1.2 形式化语言

**定义 1.1.2 (自动机语言)**
自动机语言 $\mathcal{L}_A$ 由以下语法规则定义：

$$\phi ::= q \in Q \mid a \in \Sigma \mid \delta(q, a) = q' \mid q_0 \mid q \in F \mid \text{Accept}(w) \mid \neg \phi \mid \phi \land \psi \mid \phi \lor \psi \mid \phi \rightarrow \psi \mid \forall x \cdot \phi \mid \exists x \cdot \phi$$

### 1.1.3 计算模型

**定义 1.1.3 (计算模型)**
自动机的计算模型定义为：
$$\text{Compute}(\mathcal{A}, w) = \text{Result of running } \mathcal{A} \text{ on input } w$$

## 1.2 有限状态自动机

### 1.2.1 DFA定义

**定义 1.2.1 (确定性有限自动机)**
确定性有限自动机(DFA)是一个五元组 $\mathcal{D} = (Q, \Sigma, \delta, q_0, F)$，其中：

- $\delta: Q \times \Sigma \rightarrow Q$ 是确定性转移函数

**公理 1.2.1 (DFA公理)**
对于任意DFA $\mathcal{D}$：
$$\forall q \in Q, a \in \Sigma \cdot \exists! q' \in Q \cdot \delta(q, a) = q'$$

### 1.2.2 NFA定义

**定义 1.2.2 (非确定性有限自动机)**
非确定性有限自动机(NFA)是一个五元组 $\mathcal{N} = (Q, \Sigma, \delta, q_0, F)$，其中：

- $\delta: Q \times \Sigma \rightarrow \mathcal{P}(Q)$ 是非确定性转移函数

**公理 1.2.2 (NFA公理)**
对于任意NFA $\mathcal{N}$：
$$\forall q \in Q, a \in \Sigma \cdot \delta(q, a) \subseteq Q$$

### 1.2.3 扩展转移函数

**定义 1.2.3 (扩展转移函数)**
DFA的扩展转移函数定义为：
$$\hat{\delta}(q, \epsilon) = q$$
$$\hat{\delta}(q, wa) = \delta(\hat{\delta}(q, w), a)$$

NFA的扩展转移函数定义为：
$$\hat{\delta}(q, \epsilon) = \{q\}$$
$$\hat{\delta}(q, wa) = \bigcup_{p \in \hat{\delta}(q, w)} \delta(p, a)$$

### 1.2.4 语言接受

**定义 1.2.4 (语言接受)**
自动机 $\mathcal{A}$ 接受的语言定义为：
$$L(\mathcal{A}) = \{w \in \Sigma^* \mid \hat{\delta}(q_0, w) \cap F \neq \emptyset\}$$

**定理 1.2.1 (DFA-NFA等价性)**
对于任意NFA $\mathcal{N}$，存在DFA $\mathcal{D}$ 使得 $L(\mathcal{N}) = L(\mathcal{D})$。

**证明：**
通过子集构造法：
1. DFA的状态是NFA状态的子集
2. DFA的转移函数通过NFA的转移函数定义
3. DFA的接受状态包含NFA的接受状态

```haskell
-- DFA-NFA等价性证明
data DFA = DFA
  { states :: Set State
  , alphabet :: Set Symbol
  , transition :: State -> Symbol -> State
  , initial :: State
  , accepting :: Set State
  }

data NFA = NFA
  { states :: Set State
  , alphabet :: Set Symbol
  , transition :: State -> Symbol -> Set State
  , initial :: State
  , accepting :: Set State
  }

-- 子集构造
subsetConstruction :: NFA -> DFA
subsetConstruction nfa = 
  let -- 新状态集合是原状态集合的幂集
      newStates = powerSet (states nfa)
      
      -- 新转移函数
      newTransition q a = 
        let oldStates = case q of
              Subset states -> states
        in Subset $ union $ map (\s -> transition nfa s a) oldStates
      
      -- 新初始状态
      newInitial = Subset [initial nfa]
      
      -- 新接受状态
      newAccepting = filter (\q -> 
        case q of
          Subset states -> not $ null $ intersect states (accepting nfa)
        ) newStates
  in DFA { states = newStates
         , alphabet = alphabet nfa
         , transition = newTransition
         , initial = newInitial
         , accepting = newAccepting }
```

## 1.3 下推自动机

### 1.3.1 PDA定义

**定义 1.3.1 (下推自动机)**
下推自动机(PDA)是一个七元组 $\mathcal{P} = (Q, \Sigma, \Gamma, \delta, q_0, Z_0, F)$，其中：

- $Q$ 是状态集合
- $\Sigma$ 是输入字母表
- $\Gamma$ 是栈字母表
- $\delta: Q \times (\Sigma \cup \{\epsilon\}) \times \Gamma \rightarrow \mathcal{P}(Q \times \Gamma^*)$ 是转移函数
- $q_0 \in Q$ 是初始状态
- $Z_0 \in \Gamma$ 是初始栈符号
- $F \subseteq Q$ 是接受状态集合

**公理 1.3.1 (PDA公理)**
对于任意PDA $\mathcal{P}$：
$$\forall q \in Q, a \in \Sigma \cup \{\epsilon\}, Z \in \Gamma \cdot \delta(q, a, Z) \subseteq Q \times \Gamma^*$$

### 1.3.2 PDA配置

**定义 1.3.2 (PDA配置)**
PDA的配置是一个三元组 $(q, w, \gamma)$，其中：

- $q \in Q$ 是当前状态
- $w \in \Sigma^*$ 是剩余输入
- $\gamma \in \Gamma^*$ 是栈内容

### 1.3.3 PDA转移

**定义 1.3.3 (PDA转移)**
PDA的转移关系定义为：
$$(q, aw, Z\gamma) \vdash (q', w, \beta\gamma)$$
当且仅当 $(q', \beta) \in \delta(q, a, Z)$

**定理 1.3.1 (PDA语言定理)**
PDA接受的语言类是上下文无关语言。

## 1.4 图灵机

### 1.4.1 TM定义

**定义 1.4.1 (图灵机)**
图灵机(TM)是一个七元组 $\mathcal{T} = (Q, \Sigma, \Gamma, \delta, q_0, B, F)$，其中：

- $Q$ 是状态集合
- $\Sigma$ 是输入字母表
- $\Gamma$ 是带字母表，$\Sigma \subseteq \Gamma$
- $\delta: Q \times \Gamma \rightarrow Q \times \Gamma \times \{L, R\}$ 是转移函数
- $q_0 \in Q$ 是初始状态
- $B \in \Gamma$ 是空白符号
- $F \subseteq Q$ 是接受状态集合

**公理 1.4.1 (TM公理)**
对于任意TM $\mathcal{T}$：
$$\forall q \in Q, a \in \Gamma \cdot \delta(q, a) \in Q \times \Gamma \times \{L, R\}$$

### 1.4.2 TM配置

**定义 1.4.2 (TM配置)**
TM的配置是一个三元组 $(q, \alpha, \beta)$，其中：

- $q \in Q$ 是当前状态
- $\alpha \in \Gamma^*$ 是带头左侧的带内容
- $\beta \in \Gamma^*$ 是带头右侧的带内容

### 1.4.3 TM转移

**定义 1.4.3 (TM转移)**
TM的转移关系定义为：
$$(q, \alpha a, \beta) \vdash (q', \alpha, b\beta)$$
当且仅当 $\delta(q, a) = (q', b, R)$

$$(q, \alpha, a\beta) \vdash (q', \alpha b, \beta)$$
当且仅当 $\delta(q, a) = (q', b, L)$

**定理 1.4.1 (图灵机完备性)**
图灵机能够计算所有可计算函数。

## 1.5 自动机等价性

### 1.5.1 等价性定义

**定义 1.5.1 (自动机等价性)**
两个自动机 $\mathcal{A}_1$ 和 $\mathcal{A}_2$ 是等价的，如果：
$$L(\mathcal{A}_1) = L(\mathcal{A}_2)$$

### 1.5.2 等价性证明

**定理 1.5.1 (DFA等价性)**
两个DFA $\mathcal{D}_1$ 和 $\mathcal{D}_2$ 等价当且仅当它们的最小化DFA同构。

**证明：**
通过最小化算法和同构检查：

```haskell
-- DFA等价性证明
checkEquivalence :: DFA -> DFA -> Bool
checkEquivalence dfa1 dfa2 = 
  let minimized1 = minimizeDFA dfa1
      minimized2 = minimizeDFA dfa2
  in isIsomorphic minimized1 minimized2

-- 最小化算法
minimizeDFA :: DFA -> DFA
minimizeDFA dfa = 
  let -- 移除不可达状态
      reachable = findReachableStates dfa
      
      -- 计算等价类
      equivalenceClasses = computeEquivalenceClasses dfa reachable
      
      -- 构造最小化DFA
      newStates = map (\cls -> State $ show cls) equivalenceClasses
      newTransition q a = 
        let oldState = findRepresentative q equivalenceClasses
            nextState = transition dfa oldState a
            newState = findClass nextState equivalenceClasses
        in newState
  in DFA { states = newStates
         , alphabet = alphabet dfa
         , transition = newTransition
         , initial = findClass (initial dfa) equivalenceClasses
         , accepting = filter (\q -> 
             let oldState = findRepresentative q equivalenceClasses
             in oldState `elem` accepting dfa
           ) newStates }
```

## 1.6 自动机最小化

### 1.6.1 最小化算法

**定义 1.6.1 (状态等价性)**
两个状态 $q_1$ 和 $q_2$ 是等价的，如果：
$$\forall w \in \Sigma^* \cdot \hat{\delta}(q_1, w) \in F \Leftrightarrow \hat{\delta}(q_2, w) \in F$$

**算法 1.6.1 (Hopcroft最小化算法)**
1. 初始化：将状态分为接受状态和非接受状态
2. 迭代：对于每个等价类，检查是否可以根据输入符号进一步分割
3. 终止：当没有进一步分割可能时停止

### 1.6.2 最小化证明

**定理 1.6.1 (最小化唯一性)**
DFA的最小化在同构意义下是唯一的。

**证明：**
通过等价类的唯一性和同构构造证明。

## 1.7 自动机验证

### 1.7.1 验证问题

**定义 1.7.1 (验证问题)**
自动机验证问题包括：

1. **语言包含**：$L(\mathcal{A}_1) \subseteq L(\mathcal{A}_2)$
2. **语言等价**：$L(\mathcal{A}_1) = L(\mathcal{A}_2)$
3. **语言非空**：$L(\mathcal{A}) \neq \emptyset$
4. **语言有限**：$|L(\mathcal{A})| < \infty$

### 1.7.2 验证算法

**算法 1.7.1 (语言包含验证)**
1. 构造补自动机 $\overline{\mathcal{A}_2}$
2. 构造交自动机 $\mathcal{A}_1 \cap \overline{\mathcal{A}_2}$
3. 检查是否为空

**算法 1.7.2 (语言非空验证)**
1. 从初始状态开始可达性分析
2. 检查是否存在到接受状态的路径

## 1.8 形式化证明

### 1.8.1 自动机理论一致性证明

**定理 1.8.1 (自动机理论一致性)**
自动机理论公理系统是一致的。

**证明：**
通过模型构造证明：

```haskell
-- 自动机理论一致性证明
data Automaton = Automaton
  { states :: Set State
  , alphabet :: Set Symbol
  , transition :: TransitionFunction
  , initial :: State
  , accepting :: Set State
  }

-- 一致性检查
checkConsistency :: Automaton -> Bool
checkConsistency automaton = 
  let stateConsistent = not $ null $ states automaton
      alphabetConsistent = not $ null $ alphabet automaton
      initialConsistent = initial automaton `elem` states automaton
      acceptingConsistent = accepting automaton `subset` states automaton
      transitionConsistent = checkTransitionConsistency (transition automaton) (states automaton) (alphabet automaton)
  in stateConsistent && alphabetConsistent && initialConsistent && acceptingConsistent && transitionConsistent

-- 模型构造
constructModel :: Automaton -> Model
constructModel automaton = 
  let stateModel = constructStateModel (states automaton)
      transitionModel = constructTransitionModel (transition automaton)
      languageModel = constructLanguageModel automaton
  in UnifiedModel { stateModel = stateModel
                  , transitionModel = transitionModel
                  , languageModel = languageModel }
```

### 1.8.2 计算能力层次证明

**定理 1.8.2 (计算能力层次)**
自动机的计算能力形成严格层次：
$$\text{DFA} \subset \text{PDA} \subset \text{TM}$$

**证明：**
通过语言类包含关系证明：

1. **DFA ⊂ PDA**：正则语言 ⊂ 上下文无关语言
2. **PDA ⊂ TM**：上下文无关语言 ⊂ 递归可枚举语言

```haskell
-- 计算能力层次证明
data ComputationalPower = 
  | DFA
  | NFA
  | PDA
  | TM

-- 能力比较
comparePower :: ComputationalPower -> ComputationalPower -> Bool
comparePower DFA NFA = True  -- DFA可以模拟NFA
comparePower NFA PDA = True  -- PDA可以模拟NFA
comparePower PDA TM = True   -- TM可以模拟PDA
comparePower _ _ = False

-- 严格包含检查
checkStrictInclusion :: ComputationalPower -> ComputationalPower -> Bool
checkStrictInclusion p1 p2 = 
  comparePower p1 p2 && not (comparePower p2 p1)
```

### 1.8.3 自动机最小化正确性证明

**定理 1.8.3 (最小化正确性)**
Hopcroft最小化算法产生最小的等价DFA。

**证明：**
通过算法不变性和最优性证明：

```haskell
-- 最小化正确性证明
data MinimizationAlgorithm = MinimizationAlgorithm
  { equivalenceClasses :: Set (Set State)
  , refinement :: RefinementFunction
  , termination :: TerminationCondition
  }

-- 正确性检查
checkCorrectness :: MinimizationAlgorithm -> DFA -> Bool
checkCorrectness algorithm dfa = 
  let minimized = runMinimization algorithm dfa
      original = dfa
      
      -- 语言等价性
      languageEquivalent = checkLanguageEquivalence original minimized
      
      -- 最小性
      isMinimal = checkMinimality minimized
      
      -- 唯一性
      isUnique = checkUniqueness minimized
  in languageEquivalent && isMinimal && isUnique

-- 语言等价性检查
checkLanguageEquivalence :: DFA -> DFA -> Bool
checkLanguageEquivalence dfa1 dfa2 = 
  let language1 = generateLanguage dfa1
      language2 = generateLanguage dfa2
  in language1 == language2
```

---

## 参考文献

1. Hopcroft, J. E., Motwani, R., & Ullman, J. D. (2006). *Introduction to Automata Theory, Languages, and Computation*. Pearson.
2. Sipser, M. (2012). *Introduction to the Theory of Computation*. Cengage Learning.
3. Kozen, D. C. (2006). *Automata and Computability*. Springer.
4. Lewis, H. R., & Papadimitriou, C. H. (1997). *Elements of the Theory of Computation*. Prentice Hall.
5. Hopcroft, J. E. (1971). An n log n algorithm for minimizing states in a finite automaton. *Theory of Machines and Computations*, 189-196. 