# 02-自动机理论

## 目录

1. [基本概念](#1-基本概念)
2. [有限自动机](#2-有限自动机)
3. [下推自动机](#3-下推自动机)
4. [图灵机](#4-图灵机)
5. [自动机等价性](#5-自动机等价性)
6. [应用实例](#6-应用实例)

## 1. 基本概念

### 1.1 自动机概述

自动机是计算的形式化模型，用于描述和实现计算过程。在形式化架构理论中，自动机理论为软件系统的状态管理和行为建模提供理论基础。

### 1.2 基本定义

```latex
\begin{definition}[自动机]
自动机是计算设备的形式化模型，包含：
\begin{enumerate}
\item 有限状态集
\item 输入字母表
\item 转移函数
\item 初始状态
\item 接受状态集
\end{enumerate}
\end{definition}
```

## 2. 有限自动机

### 2.1 DFA定义

```latex
\begin{definition}[确定有限自动机]
DFA是五元组 $M = (Q, \Sigma, \delta, q_0, F)$：
\begin{enumerate}
\item $Q$ 是有限状态集
\item $\Sigma$ 是输入字母表
\item $\delta: Q \times \Sigma \rightarrow Q$ 是转移函数
\item $q_0 \in Q$ 是初始状态
\item $F \subseteq Q$ 是接受状态集
\end{enumerate}
\end{definition}
```

### 2.2 NFA定义

```latex
\begin{definition}[非确定有限自动机]
NFA是五元组 $M = (Q, \Sigma, \delta, q_0, F)$：
\begin{enumerate}
\item $Q$ 是有限状态集
\item $\Sigma$ 是输入字母表
\item $\delta: Q \times \Sigma \rightarrow \mathcal{P}(Q)$ 是转移函数
\item $q_0 \in Q$ 是初始状态
\item $F \subseteq Q$ 是接受状态集
\end{enumerate}
\end{definition}
```

## 3. 下推自动机

### 3.1 PDA定义

```latex
\begin{definition}[下推自动机]
PDA是七元组 $M = (Q, \Sigma, \Gamma, \delta, q_0, Z_0, F)$：
\begin{enumerate}
\item $Q$ 是有限状态集
\item $\Sigma$ 是输入字母表
\item $\Gamma$ 是栈字母表
\item $\delta: Q \times \Sigma \times \Gamma \rightarrow \mathcal{P}(Q \times \Gamma^*)$ 是转移函数
\item $q_0 \in Q$ 是初始状态
\item $Z_0 \in \Gamma$ 是初始栈符号
\item $F \subseteq Q$ 是接受状态集
\end{enumerate}
\end{definition}
```

## 4. 图灵机

### 4.1 TM定义

```latex
\begin{definition}[图灵机]
TM是七元组 $M = (Q, \Sigma, \Gamma, \delta, q_0, B, F)$：
\begin{enumerate}
\item $Q$ 是有限状态集
\item $\Sigma$ 是输入字母表
\item $\Gamma$ 是带字母表
\item $\delta: Q \times \Gamma \rightarrow Q \times \Gamma \times \{L, R\}$ 是转移函数
\item $q_0 \in Q$ 是初始状态
\item $B \in \Gamma$ 是空白符号
\item $F \subseteq Q$ 是接受状态集
\end{enumerate}
\end{definition}
```

## 5. 自动机等价性

### 5.1 DFA与NFA等价性

```latex
\begin{theorem}[DFA与NFA等价性]
对于任意NFA，存在等价的DFA。
\end{theorem}

\begin{proof}
使用子集构造法：
\begin{enumerate}
\item 设NFA $N = (Q, \Sigma, \delta, q_0, F)$
\item 构造DFA $D = (\mathcal{P}(Q), \Sigma, \delta', \{q_0\}, F')$
\item $\delta'(S, a) = \bigcup_{q \in S} \delta(q, a)$
\item $F' = \{S \subseteq Q \mid S \cap F \neq \emptyset\}$
\end{enumerate}
\end{proof}
```

## 6. 应用实例

### 6.1 状态机实现

```rust
// 有限自动机的实现
#[derive(Debug, Clone)]
pub struct FiniteAutomaton {
    pub states: Set<String>,
    pub alphabet: Set<char>,
    pub transitions: Map<(String, char), String>,
    pub initial_state: String,
    pub accepting_states: Set<String>,
}

impl FiniteAutomaton {
    pub fn new(
        states: Set<String>,
        alphabet: Set<char>,
        initial_state: String,
        accepting_states: Set<String>,
    ) -> Self {
        FiniteAutomaton {
            states,
            alphabet,
            transitions: Map::new(),
            initial_state,
            accepting_states,
        }
    }
    
    pub fn add_transition(&mut self, from: String, input: char, to: String) {
        self.transitions.insert((from, input), to);
    }
    
    pub fn accept(&self, input: &str) -> bool {
        let mut current_state = self.initial_state.clone();
        
        for c in input.chars() {
            if let Some(next_state) = self.transitions.get(&(current_state.clone(), c)) {
                current_state = next_state.clone();
            } else {
                return false;
            }
        }
        
        self.accepting_states.contains(&current_state)
    }
    
    pub fn minimize(&self) -> FiniteAutomaton {
        // 实现Hopcroft算法进行最小化
        let equivalence_classes = self.compute_equivalence_classes();
        self.build_minimal_automaton(&equivalence_classes)
    }
    
    pub fn compute_equivalence_classes(&self) -> Vec<Set<String>> {
        // 计算等价类
        let mut classes = vec![
            self.accepting_states.clone(),
            self.states.difference(&self.accepting_states).cloned().collect(),
        ];
        
        loop {
            let new_classes = self.refine_classes(&classes);
            if new_classes.len() == classes.len() {
                break;
            }
            classes = new_classes;
        }
        
        classes
    }
}

// 下推自动机的实现
#[derive(Debug, Clone)]
pub struct PushdownAutomaton {
    pub states: Set<String>,
    pub input_alphabet: Set<char>,
    pub stack_alphabet: Set<char>,
    pub transitions: Vec<PDATransition>,
    pub initial_state: String,
    pub initial_stack_symbol: char,
    pub accepting_states: Set<String>,
}

#[derive(Debug, Clone)]
pub struct PDATransition {
    pub from_state: String,
    pub input_symbol: Option<char>,
    pub stack_top: char,
    pub to_state: String,
    pub stack_push: Vec<char>,
}

impl PushdownAutomaton {
    pub fn accept(&self, input: &str) -> bool {
        let mut configurations = vec![Configuration {
            state: self.initial_state.clone(),
            input_remaining: input.to_string(),
            stack: vec![self.initial_stack_symbol],
        }];
        
        while !configurations.is_empty() {
            let mut new_configurations = Vec::new();
            
            for config in configurations {
                if config.input_remaining.is_empty() && 
                   self.accepting_states.contains(&config.state) {
                    return true;
                }
                
                for transition in &self.transitions {
                    if self.can_apply_transition(&config, transition) {
                        let new_config = self.apply_transition(&config, transition);
                        new_configurations.push(new_config);
                    }
                }
            }
            
            configurations = new_configurations;
        }
        
        false
    }
    
    pub fn can_apply_transition(&self, config: &Configuration, transition: &PDATransition) -> bool {
        config.state == transition.from_state &&
        config.stack.last() == Some(&transition.stack_top) &&
        (transition.input_symbol.is_none() || 
         config.input_remaining.starts_with(transition.input_symbol.unwrap()))
    }
}

// 图灵机的实现
#[derive(Debug, Clone)]
pub struct TuringMachine {
    pub states: Set<String>,
    pub input_alphabet: Set<char>,
    pub tape_alphabet: Set<char>,
    pub transitions: Map<(String, char), (String, char, Direction)>,
    pub initial_state: String,
    pub blank_symbol: char,
    pub accepting_states: Set<String>,
}

#[derive(Debug, Clone)]
pub enum Direction {
    Left,
    Right,
}

impl TuringMachine {
    pub fn run(&self, input: &str) -> Option<String> {
        let mut tape = input.chars().collect::<Vec<_>>();
        let mut head_position = 0;
        let mut current_state = self.initial_state.clone();
        
        // 扩展磁带
        while head_position >= tape.len() {
            tape.push(self.blank_symbol);
        }
        
        loop {
            if self.accepting_states.contains(&current_state) {
                return Some(tape.into_iter().collect());
            }
            
            let current_symbol = tape[head_position];
            let key = (current_state.clone(), current_symbol);
            
            if let Some(&(ref new_state, new_symbol, direction)) = self.transitions.get(&key) {
                tape[head_position] = new_symbol;
                current_state = new_state.clone();
                
                match direction {
                    Direction::Left => {
                        if head_position == 0 {
                            tape.insert(0, self.blank_symbol);
                        } else {
                            head_position -= 1;
                        }
                    }
                    Direction::Right => {
                        head_position += 1;
                        if head_position >= tape.len() {
                            tape.push(self.blank_symbol);
                        }
                    }
                }
            } else {
                return None; // 停机
            }
        }
    }
}
```

### 6.2 协议状态机

```rust
// 协议状态机的实现
#[derive(Debug, Clone)]
pub struct ProtocolStateMachine {
    pub states: Set<String>,
    pub events: Set<String>,
    pub transitions: Vec<ProtocolTransition>,
    pub initial_state: String,
    pub final_states: Set<String>,
}

#[derive(Debug, Clone)]
pub struct ProtocolTransition {
    pub from_state: String,
    pub event: String,
    pub to_state: String,
    pub action: Option<Box<dyn Fn() -> ()>>,
    pub guard: Option<Box<dyn Fn() -> bool>>,
}

impl ProtocolStateMachine {
    pub fn process_event(&mut self, event: &str) -> Result<bool, String> {
        let current_state = self.get_current_state();
        
        for transition in &self.transitions {
            if transition.from_state == current_state && transition.event == event {
                // 检查守卫条件
                if let Some(guard) = &transition.guard {
                    if !guard() {
                        return Err("Guard condition failed".to_string());
                    }
                }
                
                // 执行动作
                if let Some(action) = &transition.action {
                    action();
                }
                
                // 转移状态
                self.set_current_state(&transition.to_state);
                return Ok(true);
            }
        }
        
        Err("No valid transition found".to_string())
    }
    
    pub fn is_in_final_state(&self) -> bool {
        self.final_states.contains(&self.get_current_state())
    }
    
    pub fn validate_protocol(&self, event_sequence: &[String]) -> bool {
        let mut machine = self.clone();
        
        for event in event_sequence {
            if machine.process_event(event).is_err() {
                return false;
            }
        }
        
        machine.is_in_final_state()
    }
}
```

---

**文档版本**：v1.0  
**创建时间**：2024-12-19  
**最后更新**：2024-12-19  
**状态**：完成

**相关链接**：

- [01-形式语言基础](./01-形式语言基础.md)
- [03-计算理论](./03-计算理论.md)
- [02-数学理论体系](../02-数学理论体系/01-集合论基础.md)
