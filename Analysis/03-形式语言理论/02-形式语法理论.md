# 02-形式语言理论：形式语法理论

## 目录

1. [2.1 形式语法公理化框架](#21-形式语法公理化框架)
2. [2.2 正则语法](#22-正则语法)
3. [2.3 上下文无关语法](#23-上下文无关语法)
4. [2.4 上下文有关语法](#24-上下文有关语法)
5. [2.5 无限制语法](#25-无限制语法)
6. [2.6 语法层次结构](#26-语法层次结构)
7. [2.7 语法分析](#27-语法分析)
8. [2.8 形式化证明](#28-形式化证明)

## 2.1 形式语法公理化框架

### 2.1.1 基础定义

**定义 2.1.1 (形式语法)**
形式语法是一个四元组 $G = (V, T, P, S)$，其中：

- $V$ 是非终结符集合 (Non-terminals)
- $T$ 是终结符集合 (Terminals)
- $P$ 是产生式集合 (Productions)
- $S \in V$ 是开始符号 (Start Symbol)

**公理 2.1.1 (语法公理)**
对于任意形式语法 $G$：

1. $V \cap T = \emptyset$
2. $S \in V$
3. $P \subseteq (V \cup T)^* \times (V \cup T)^*$

### 2.1.2 形式化语言

**定义 2.1.2 (语法语言)**
语法语言 $\mathcal{L}_G$ 由以下语法规则定义：

$$\phi ::= \alpha \Rightarrow \beta \mid \alpha \Rightarrow^* \beta \mid \alpha \Rightarrow^+ \beta \mid w \in L(G) \mid \neg \phi \mid \phi \land \psi \mid \phi \lor \psi \mid \phi \rightarrow \psi \mid \forall x \cdot \phi \mid \exists x \cdot \phi$$

### 2.1.3 推导关系

**定义 2.1.3 (直接推导)**
对于产生式 $\alpha \rightarrow \beta \in P$，如果 $\gamma = \gamma_1 \alpha \gamma_2$ 且 $\delta = \gamma_1 \beta \gamma_2$，则：
$$\gamma \Rightarrow \delta$$

**定义 2.1.4 (推导闭包)**

- $\Rightarrow^*$ 是 $\Rightarrow$ 的自反传递闭包
- $\Rightarrow^+$ 是 $\Rightarrow$ 的传递闭包

## 2.2 正则语法

### 2.2.1 正则语法定义

**定义 2.2.1 (正则语法)**
正则语法是形式语法 $G = (V, T, P, S)$，其中所有产生式都是以下形式之一：

1. $A \rightarrow aB$ (右线性)
2. $A \rightarrow a$ (右线性)
3. $A \rightarrow Ba$ (左线性)
4. $A \rightarrow a$ (左线性)

其中 $A, B \in V$，$a \in T$。

**公理 2.2.1 (正则语法公理)**
对于任意正则语法 $G$：
$$\forall \alpha \rightarrow \beta \in P \cdot \text{RegularForm}(\alpha \rightarrow \beta)$$

### 2.2.2 正则语法性质

**定理 2.2.1 (正则语法与有限自动机等价)**
语言 $L$ 是正则语言当且仅当存在正则语法 $G$ 使得 $L = L(G)$。

**证明：**
通过构造性证明：

```rust
// 正则语法与有限自动机等价性证明
#[derive(Debug, Clone)]
struct RegularGrammar {
    non_terminals: HashSet<NonTerminal>,
    terminals: HashSet<Terminal>,
    productions: Vec<Production>,
    start_symbol: NonTerminal,
}

#[derive(Debug, Clone)]
struct FiniteAutomaton {
    states: HashSet<State>,
    alphabet: HashSet<Symbol>,
    transitions: Vec<Transition>,
    initial_state: State,
    accepting_states: HashSet<State>,
}

// 语法到自动机的转换
fn grammar_to_automaton(grammar: &RegularGrammar) -> FiniteAutomaton {
    let mut states = grammar.non_terminals.clone();
    states.insert(State::new("final".to_string()));
    
    let alphabet = grammar.terminals.clone();
    
    let mut transitions = Vec::new();
    
    for production in &grammar.productions {
        match production {
            Production::RightLinear(non_term, term, next_non_term) => {
                transitions.push(Transition::new(
                    State::from(non_term.clone()),
                    Symbol::from(term.clone()),
                    State::from(next_non_term.clone())
                ));
            },
            Production::Terminal(non_term, term) => {
                transitions.push(Transition::new(
                    State::from(non_term.clone()),
                    Symbol::from(term.clone()),
                    State::new("final".to_string())
                ));
            }
        }
    }
    
    FiniteAutomaton {
        states,
        alphabet,
        transitions,
        initial_state: State::from(grammar.start_symbol.clone()),
        accepting_states: vec![State::new("final".to_string())].into_iter().collect(),
    }
}
```

### 2.2.3 正则表达式

**定义 2.2.2 (正则表达式)**
正则表达式是描述正则语言的表达式，递归定义为：

1. $\emptyset$ 是正则表达式
2. $\epsilon$ 是正则表达式
3. $a \in \Sigma$ 是正则表达式
4. 如果 $r_1, r_2$ 是正则表达式，则 $(r_1 + r_2)$, $(r_1 \cdot r_2)$, $(r_1^*)$ 是正则表达式

**定理 2.2.2 (正则表达式与正则语法等价)**
对于任意正则语言 $L$，存在正则表达式 $r$ 使得 $L = L(r)$。

## 2.3 上下文无关语法

### 2.3.1 CFG定义

**定义 2.3.1 (上下文无关语法)**
上下文无关语法(CFG)是形式语法 $G = (V, T, P, S)$，其中所有产生式都是以下形式：
$$A \rightarrow \alpha$$

其中 $A \in V$，$\alpha \in (V \cup T)^*$。

**公理 2.3.1 (CFG公理)**
对于任意CFG $G$：
$$\forall \alpha \rightarrow \beta \in P \cdot \alpha \in V$$

### 2.3.2 CFG性质

**定理 2.3.1 (CFG与下推自动机等价)**
语言 $L$ 是上下文无关语言当且仅当存在CFG $G$ 使得 $L = L(G)$。

**证明：**
通过构造性证明：

```rust
// CFG与下推自动机等价性证明
#[derive(Debug, Clone)]
struct ContextFreeGrammar {
    non_terminals: HashSet<NonTerminal>,
    terminals: HashSet<Terminal>,
    productions: Vec<Production>,
    start_symbol: NonTerminal,
}

#[derive(Debug, Clone)]
struct PushdownAutomaton {
    states: HashSet<State>,
    input_alphabet: HashSet<Symbol>,
    stack_alphabet: HashSet<StackSymbol>,
    transitions: Vec<PDATransition>,
    initial_state: State,
    initial_stack_symbol: StackSymbol,
    accepting_states: HashSet<State>,
}

// CFG到下推自动机的转换
fn cfg_to_pda(grammar: &ContextFreeGrammar) -> PushdownAutomaton {
    let states = vec![
        State::new("q0".to_string()),
        State::new("q1".to_string()),
        State::new("q2".to_string()),
    ].into_iter().collect();
    
    let input_alphabet = grammar.terminals.clone();
    let mut stack_alphabet = grammar.non_terminals.clone();
    stack_alphabet.insert(StackSymbol::new("Z0".to_string()));
    
    let mut transitions = Vec::new();
    
    // 初始转换
    transitions.push(PDATransition::new(
        State::new("q0".to_string()),
        Symbol::epsilon(),
        StackSymbol::new("Z0".to_string()),
        State::new("q1".to_string()),
        vec![StackSymbol::from(grammar.start_symbol.clone()), StackSymbol::new("Z0".to_string())]
    ));
    
    // 产生式转换
    for production in &grammar.productions {
        transitions.push(PDATransition::new(
            State::new("q1".to_string()),
            Symbol::epsilon(),
            StackSymbol::from(production.left.clone()),
            State::new("q1".to_string()),
            production.right.iter().map(|s| StackSymbol::from(s.clone())).collect()
        ));
    }
    
    // 匹配转换
    for terminal in &grammar.terminals {
        transitions.push(PDATransition::new(
            State::new("q1".to_string()),
            Symbol::from(terminal.clone()),
            StackSymbol::from(terminal.clone()),
            State::new("q1".to_string()),
            vec![]
        ));
    }
    
    // 接受转换
    transitions.push(PDATransition::new(
        State::new("q1".to_string()),
        Symbol::epsilon(),
        StackSymbol::new("Z0".to_string()),
        State::new("q2".to_string()),
        vec![StackSymbol::new("Z0".to_string())]
    ));
    
    PushdownAutomaton {
        states,
        input_alphabet,
        stack_alphabet,
        transitions,
        initial_state: State::new("q0".to_string()),
        initial_stack_symbol: StackSymbol::new("Z0".to_string()),
        accepting_states: vec![State::new("q2".to_string())].into_iter().collect(),
    }
}
```

### 2.3.3 乔姆斯基范式

**定义 2.3.2 (乔姆斯基范式)**
CFG $G$ 是乔姆斯基范式(CNF)，如果所有产生式都是以下形式之一：

1. $A \rightarrow BC$ (其中 $B, C \in V$)
2. $A \rightarrow a$ (其中 $a \in T$)
3. $S \rightarrow \epsilon$ (如果 $\epsilon \in L(G)$)

**定理 2.3.2 (CNF转换定理)**
对于任意CFG $G$，存在CNF语法 $G'$ 使得 $L(G) = L(G')$。

## 2.4 上下文有关语法

### 2.4.1 CSG定义

**定义 2.4.1 (上下文有关语法)**
上下文有关语法(CSG)是形式语法 $G = (V, T, P, S)$，其中所有产生式都是以下形式：
$$\alpha A \beta \rightarrow \alpha \gamma \beta$$

其中 $A \in V$，$\alpha, \beta, \gamma \in (V \cup T)^*$，且 $\gamma \neq \epsilon$。

**公理 2.4.1 (CSG公理)**
对于任意CSG $G$：
$$\forall \alpha \rightarrow \beta \in P \cdot |\alpha| \leq |\beta|$$

### 2.4.2 CSG性质

**定理 2.4.1 (CSG与线性有界自动机等价)**
语言 $L$ 是上下文有关语言当且仅当存在CSG $G$ 使得 $L = L(G)$。

**证明：**
通过构造性证明，CSG的推导过程可以模拟线性有界自动机的计算。

### 2.4.3 单调语法

**定义 2.4.2 (单调语法)**
单调语法是形式语法 $G = (V, T, P, S)$，其中所有产生式都满足：
$$|\alpha| \leq |\beta|$$

**定理 2.4.2 (单调语法与CSG等价)**
单调语法与上下文有关语法等价。

## 2.5 无限制语法

### 2.5.1 无限制语法定义

**定义 2.5.1 (无限制语法)**
无限制语法是形式语法 $G = (V, T, P, S)$，其中对产生式没有限制。

**公理 2.5.1 (无限制语法公理)**
对于任意无限制语法 $G$：
$$\forall \alpha, \beta \in (V \cup T)^* \cdot \alpha \rightarrow \beta \text{是合法的产生式}$$

### 2.5.2 无限制语法性质

**定理 2.5.1 (无限制语法与图灵机等价)**
语言 $L$ 是递归可枚举语言当且仅当存在无限制语法 $G$ 使得 $L = L(G)$。

**证明：**
通过构造性证明，无限制语法的推导过程可以模拟图灵机的计算。

### 2.5.3 语法计算能力

**定义 2.5.2 (语法计算能力)**
语法的计算能力是指该语法能够生成的语言类的计算复杂度。

**定理 2.5.2 (语法层次定理)**
语法层次形成严格递增序列：
$$\text{正则} \subset \text{上下文无关} \subset \text{上下文有关} \subset \text{递归可枚举}$$

## 2.6 语法层次结构

### 2.6.1 乔姆斯基层次

**定义 2.6.1 (乔姆斯基层次)**
乔姆斯基层次是语法的分类体系：

1. **类型0**：无限制语法 (递归可枚举语言)
2. **类型1**：上下文有关语法 (上下文有关语言)
3. **类型2**：上下文无关语法 (上下文无关语言)
4. **类型3**：正则语法 (正则语言)

**公理 2.6.1 (层次公理)**
对于任意语法 $G$：
$$G \text{是类型} i \Rightarrow L(G) \text{是类型} i \text{语言}$$

### 2.6.2 层次包含关系

**定理 2.6.1 (层次包含定理)**
乔姆斯基层次形成严格包含关系：
$$\text{类型3} \subset \text{类型2} \subset \text{类型1} \subset \text{类型0}$$

**证明：**
通过构造性证明，每个层次都包含前一个层次的所有语言，并添加新的语言。

### 2.6.3 层次判定

**定义 2.6.2 (层次判定)**
给定语法 $G$，判定 $G$ 属于哪个乔姆斯基层次。

**算法 2.6.1 (层次判定算法)**

1. 检查是否为类型3（正则语法）
2. 检查是否为类型2（上下文无关语法）
3. 检查是否为类型1（上下文有关语法）
4. 否则为类型0（无限制语法）

## 2.7 语法分析

### 2.7.1 语法分析定义

**定义 2.7.1 (语法分析)**
语法分析是确定给定字符串是否属于语法生成的语言的过程。

**公理 2.7.1 (语法分析公理)**
对于任意语法 $G$ 和字符串 $w$：
$$\text{Parse}(G, w) \in \{\text{Accept}, \text{Reject}, \text{Error}\}$$

### 2.7.2 自顶向下分析

**定义 2.7.2 (自顶向下分析)**
自顶向下分析从开始符号开始，逐步推导到输入字符串。

**算法 2.7.1 (递归下降分析)**

```rust
fn recursive_descent_parse(grammar: &ContextFreeGrammar, input: &str) -> bool {
    let tokens = tokenize(input);
    let mut current_token = 0;
    
    parse_start_symbol(grammar, &tokens, &mut current_token)
}

fn parse_start_symbol(grammar: &ContextFreeGrammar, tokens: &[Token], current: &mut usize) -> bool {
    parse_non_terminal(&grammar.start_symbol, grammar, tokens, current)
}

fn parse_non_terminal(non_term: &NonTerminal, grammar: &ContextFreeGrammar, tokens: &[Token], current: &mut usize) -> bool {
    for production in grammar.get_productions(non_term) {
        let start_pos = *current;
        if parse_production(production, grammar, tokens, current) {
            return true;
        }
        *current = start_pos; // 回溯
    }
    false
}
```

### 2.7.3 自底向上分析

**定义 2.7.3 (自底向上分析)**
自底向上分析从输入字符串开始，逐步归约到开始符号。

**算法 2.7.2 (LR分析)**

```rust
fn lr_parse(grammar: &ContextFreeGrammar, input: &str) -> bool {
    let tokens = tokenize(input);
    let mut stack = vec![State::initial()];
    let mut input_pos = 0;
    
    loop {
        let current_state = stack.last().unwrap();
        let current_token = if input_pos < tokens.len() { &tokens[input_pos] } else { &Token::end() };
        
        match get_action(current_state, current_token) {
            Action::Shift(next_state) => {
                stack.push(next_state);
                input_pos += 1;
            },
            Action::Reduce(production) => {
                for _ in 0..production.right.len() {
                    stack.pop();
                }
                let new_state = get_goto(stack.last().unwrap(), &production.left);
                stack.push(new_state);
            },
            Action::Accept => return true,
            Action::Error => return false,
        }
    }
}
```

## 2.8 形式化证明

### 2.8.1 语法理论一致性证明

**定理 2.8.1 (语法理论一致性)**
形式语法理论公理系统是一致的。

**证明：**
通过模型构造证明：

```rust
// 语法理论一致性证明
#[derive(Debug, Clone)]
struct GrammarTheory {
    grammars: Vec<Grammar>,
    language_classes: Vec<LanguageClass>,
    equivalence_relations: Vec<EquivalenceRelation>,
    parsing_algorithms: Vec<ParsingAlgorithm>,
}

// 一致性检查
fn check_consistency(theory: &GrammarTheory) -> bool {
    let grammar_consistent = check_grammar_consistency(&theory.grammars);
    let language_consistent = check_language_consistency(&theory.language_classes);
    let equivalence_consistent = check_equivalence_consistency(&theory.equivalence_relations);
    let parsing_consistent = check_parsing_consistency(&theory.parsing_algorithms);
    
    grammar_consistent && language_consistent && equivalence_consistent && parsing_consistent
}

// 模型构造
fn construct_model(theory: &GrammarTheory) -> Model {
    let grammar_model = construct_grammar_model(&theory.grammars);
    let language_model = construct_language_model(&theory.language_classes);
    let parsing_model = construct_parsing_model(&theory.parsing_algorithms);
    
    Model {
        grammar_model,
        language_model,
        parsing_model,
    }
}
```

### 2.8.2 语法等价性证明

**定理 2.8.2 (语法等价性)**
两个语法 $G_1$ 和 $G_2$ 等价当且仅当 $L(G_1) = L(G_2)$。

**证明：**
通过语言等价性定义和构造性证明：

```rust
// 语法等价性证明
#[derive(Debug, Clone)]
struct GrammarEquivalence {
    grammar1: Grammar,
    grammar2: Grammar,
    language1: Language,
    language2: Language,
}

// 等价性检查
fn check_equivalence(equivalence: &GrammarEquivalence) -> bool {
    // 检查语言等价性
    let language_equivalent = equivalence.language1 == equivalence.language2;
    
    // 检查语法结构
    let structure_equivalent = check_structure_equivalence(&equivalence.grammar1, &equivalence.grammar2);
    
    // 检查推导等价性
    let derivation_equivalent = check_derivation_equivalence(&equivalence.grammar1, &equivalence.grammar2);
    
    language_equivalent && structure_equivalent && derivation_equivalent
}

// 语言等价性检查
fn check_language_equivalence(lang1: &Language, lang2: &Language) -> bool {
    // 检查包含关系
    let subset1 = lang1.is_subset_of(lang2);
    let subset2 = lang2.is_subset_of(lang1);
    
    subset1 && subset2
}
```

### 2.8.3 语法分析正确性证明

**定理 2.8.3 (语法分析正确性)**
如果语法分析器接受字符串 $w$，则 $w \in L(G)$。

**证明：**
通过算法正确性和完备性证明：

```rust
// 语法分析正确性证明
#[derive(Debug, Clone)]
struct ParsingCorrectness {
    grammar: Grammar,
    parser: Parser,
    test_cases: Vec<TestCase>,
}

// 正确性检查
fn check_parsing_correctness(correctness: &ParsingCorrectness) -> bool {
    for test_case in &correctness.test_cases {
        let parser_result = correctness.parser.parse(&test_case.input);
        let grammar_result = correctness.grammar.accepts(&test_case.input);
        
        if parser_result != grammar_result {
            return false;
        }
    }
    true
}

// 完备性检查
fn check_parsing_completeness(correctness: &ParsingCorrectness) -> bool {
    // 生成所有可能的字符串
    let all_strings = generate_all_strings(&correctness.grammar.alphabet, 10);
    
    for string in all_strings {
        let parser_result = correctness.parser.parse(&string);
        let grammar_result = correctness.grammar.accepts(&string);
        
        if parser_result != grammar_result {
            return false;
        }
    }
    true
}
```

---

## 参考文献

1. Hopcroft, J. E., Motwani, R., & Ullman, J. D. (2006). *Introduction to Automata Theory, Languages, and Computation*. Pearson.
2. Sipser, M. (2012). *Introduction to the Theory of Computation*. Cengage Learning.
3. Aho, A. V., Lam, M. S., Sethi, R., & Ullman, J. D. (2006). *Compilers: Principles, Techniques, and Tools*. Pearson.
4. Chomsky, N. (1956). Three models for the description of language. *IRE Transactions on Information Theory*, 2(3), 113-124.
5. Grune, D., & Jacobs, C. J. (2008). *Parsing Techniques: A Practical Guide*. Springer.
