# 03-计算理论

## 目录

1. [1.0 可计算性理论](#10-可计算性理论)
2. [2.0 递归函数理论](#20-递归函数理论)
3. [3.0 λ演算理论](#30-λ演算理论)
4. [4.0 停机问题](#40-停机问题)
5. [5.0 不可判定问题](#50-不可判定问题)
6. [6.0 计算模型](#60-计算模型)

## 1.0 可计算性理论

### 1.1 可计算函数

**定义 1.1.1 (可计算函数)**
函数 $f: \mathbb{N}^k \to \mathbb{N}$ 是可计算的，当且仅当存在图灵机 $M$ 使得：
$$\forall x_1, \ldots, x_k \in \mathbb{N}, \quad f(x_1, \ldots, x_k) = \text{Output}(M, x_1, \ldots, x_k)$$

**定义 1.1.2 (部分可计算函数)**
函数 $f: \mathbb{N}^k \to \mathbb{N}$ 是部分可计算的，当且仅当存在图灵机 $M$ 使得：
$$\forall x_1, \ldots, x_k \in \mathbb{N}, \quad f(x_1, \ldots, x_k) \downarrow \Leftrightarrow M(x_1, \ldots, x_k) \text{ 停机}$$

**定理 1.1.1 (丘奇-图灵论题)**
任何可计算的函数都可以由图灵机计算。

### 1.2 可计算语言

**定义 1.2.1 (可判定语言)**
语言 $L \subseteq \Sigma^*$ 是可判定的，当且仅当存在图灵机 $M$ 使得：
$$\forall w \in \Sigma^*, \quad w \in L \Leftrightarrow M(w) \text{ 接受}$$

**定义 1.2.2 (可识别语言)**
语言 $L \subseteq \Sigma^*$ 是可识别的，当且仅当存在图灵机 $M$ 使得：
$$\forall w \in \Sigma^*, \quad w \in L \Leftrightarrow M(w) \text{ 停机}$$

**定理 1.2.1 (可判定性与可识别性)**
语言 $L$ 是可判定的当且仅当 $L$ 和 $\overline{L}$ 都是可识别的。

## 2.0 递归函数理论

### 2.1 原始递归函数

**定义 2.1.1 (基本函数)**
基本函数包括：

1. **零函数**：$Z(x) = 0$
2. **后继函数**：$S(x) = x + 1$
3. **投影函数**：$P_i^n(x_1, \ldots, x_n) = x_i$

**定义 2.1.2 (复合)**
函数 $h$ 是函数 $f$ 和 $g_1, \ldots, g_k$ 的复合，如果：
$$h(x_1, \ldots, x_n) = f(g_1(x_1, \ldots, x_n), \ldots, g_k(x_1, \ldots, x_n))$$

**定义 2.1.3 (原始递归)**
函数 $h$ 通过原始递归从 $f$ 和 $g$ 定义，如果：
$$h(x_1, \ldots, x_n, 0) = f(x_1, \ldots, x_n)$$
$$h(x_1, \ldots, x_n, y+1) = g(x_1, \ldots, x_n, y, h(x_1, \ldots, x_n, y))$$

**定义 2.1.4 (原始递归函数)**
原始递归函数是基本函数通过有限次复合和原始递归得到的函数。

### 2.2 μ递归函数

**定义 2.2.1 (μ算子)**
函数 $h$ 通过μ算子从 $f$ 定义，如果：
$$h(x_1, \ldots, x_n) = \mu y[f(x_1, \ldots, x_n, y) = 0]$$

其中 $\mu y$ 表示最小的 $y$ 使得 $f(x_1, \ldots, x_n, y) = 0$。

**定义 2.2.2 (μ递归函数)**
μ递归函数是原始递归函数通过有限次μ算子得到的函数。

**定理 2.2.1 (μ递归函数等价性)**
μ递归函数类与图灵可计算函数类等价。

## 3.0 λ演算理论

### 3.1 λ表达式

**定义 3.1.1 (λ表达式)**
λ表达式的语法定义为：
$$M ::= x \mid \lambda x.M \mid M N$$

其中：

- $x$ 是变量
- $\lambda x.M$ 是抽象
- $M N$ 是应用

**定义 3.1.2 (自由变量)**
自由变量函数 $FV$ 定义为：
$$FV(x) = \{x\}$$
$$FV(\lambda x.M) = FV(M) - \{x\}$$
$$FV(M N) = FV(M) \cup FV(N)$$

**定义 3.1.3 (α等价)**
两个λ表达式是α等价的，如果它们可以通过变量重命名相互转换。

### 3.2 β归约

**定义 3.2.1 (β归约)**
β归约关系 $\to_\beta$ 定义为：
$$(\lambda x.M) N \to_\beta M[x := N]$$

其中 $M[x := N]$ 表示将 $M$ 中所有自由出现的 $x$ 替换为 $N$。

**定义 3.2.2 (β归约闭包)**
β归约的传递自反闭包 $\twoheadrightarrow_\beta$ 定义为：
$$M \twoheadrightarrow_\beta N \Leftrightarrow M \to_\beta^* N$$

**定理 3.2.1 (丘奇-罗瑟定理)**
如果 $M \twoheadrightarrow_\beta N_1$ 和 $M \twoheadrightarrow_\beta N_2$，则存在 $P$ 使得 $N_1 \twoheadrightarrow_\beta P$ 和 $N_2 \twoheadrightarrow_\beta P$。

### 3.3 不动点理论

**定义 3.3.1 (不动点组合子)**
不动点组合子 $Y$ 定义为：
$$Y = \lambda f.(\lambda x.f(x x))(\lambda x.f(x x))$$

**定理 3.3.1 (不动点定理)**
对于任意λ表达式 $F$，$Y F$ 是 $F$ 的不动点，即：
$$Y F \twoheadrightarrow_\beta F(Y F)$$

**定义 3.3.2 (递归函数)**
递归函数可以通过不动点组合子定义：
$$\text{fact} = Y(\lambda f.\lambda n.\text{if } n = 0 \text{ then } 1 \text{ else } n \times f(n-1))$$

## 4.0 停机问题

### 4.1 停机问题定义

**定义 4.1.1 (停机问题)**
停机问题是判断给定图灵机 $M$ 和输入 $w$，$M$ 在输入 $w$ 上是否会停机。

**定义 4.1.2 (停机语言)**
停机语言定义为：
$$H = \{\langle M, w \rangle \mid M \text{ 在输入 } w \text{ 上停机}\}$$

**定理 4.1.1 (停机问题不可判定性)**
停机语言 $H$ 是不可判定的。

**证明**：
假设 $H$ 是可判定的，则存在图灵机 $H'$ 判定 $H$。构造图灵机 $D$：
$$D(\langle M \rangle) = \begin{cases}
\text{停机} & \text{if } H'(\langle M, \langle M \rangle \rangle) = \text{拒绝} \\
\text{循环} & \text{if } H'(\langle M, \langle M \rangle \rangle) = \text{接受}
\end{cases}$$

考虑 $D(\langle D \rangle)$，得到矛盾。

### 4.2 停机问题变种

**定义 4.2.1 (自停机问题)**
自停机问题是判断给定图灵机 $M$，$M$ 在输入 $\langle M \rangle$ 上是否会停机。

**定理 4.2.1 (自停机问题不可判定性)**
自停机问题是不可判定的。

**定义 4.2.2 (空语言问题)**
空语言问题是判断给定图灵机 $M$，$L(M)$ 是否为空。

**定理 4.2.2 (空语言问题不可判定性)**
空语言问题是不可判定的。

## 5.0 不可判定问题

### 5.1 波斯特对应问题

**定义 5.1.1 (波斯特对应问题)**
波斯特对应问题(PCP)是判断给定字符串对序列 $(x_1, y_1), \ldots, (x_n, y_n)$，是否存在索引序列 $i_1, \ldots, i_k$ 使得：
$$x_{i_1} x_{i_2} \cdots x_{i_k} = y_{i_1} y_{i_2} \cdots y_{i_k}$$

**定理 5.1.1 (PCP不可判定性)**
波斯特对应问题是不可判定的。

### 5.2 希尔伯特第十问题

**定义 5.2.1 (希尔伯特第十问题)**
希尔伯特第十问题是判断给定多项式方程 $P(x_1, \ldots, x_n) = 0$，是否存在整数解。

**定理 5.2.1 (希尔伯特第十问题不可判定性)**
希尔伯特第十问题是不可判定的。

### 5.3 字问题

**定义 5.3.1 (群的字问题)**
群的字问题是判断给定群 $G$ 的生成元和关系，以及两个群元素 $g, h$，是否有 $g = h$。

**定理 5.3.1 (字问题不可判定性)**
存在群的字问题是不可判定的。

## 6.0 计算模型

### 6.1 寄存器机

**定义 6.1.1 (寄存器机)**
寄存器机是一个四元组 $M = (R, I, P, C)$，其中：

- $R$ 是寄存器集合
- $I$ 是指令集
- $P$ 是程序
- $C$ 是控制单元

**定义 6.1.2 (寄存器机指令)**
寄存器机指令包括：

1. **清零**：$Z(r)$ - 将寄存器 $r$ 清零
2. **递增**：$S(r)$ - 将寄存器 $r$ 的值加1
3. **转移**：$J(r, s, k)$ - 如果 $r = s$ 则跳转到第 $k$ 条指令

**定理 6.1.1 (寄存器机等价性)**
寄存器机与图灵机在计算能力上等价。

### 6.2 递归函数

**定义 6.2.1 (递归函数)**
递归函数是通过基本函数、复合、原始递归和μ算子定义的函数。

**定理 6.2.1 (递归函数等价性)**
递归函数类与图灵可计算函数类等价。

### 6.3 λ演算

**定义 6.3.1 (λ可定义函数)**
函数 $f$ 是λ可定义的，如果存在λ表达式 $F$ 使得：
$$\forall x_1, \ldots, x_n, \quad F \overline{x_1} \cdots \overline{x_n} \twoheadrightarrow_\beta \overline{f(x_1, \ldots, x_n)}$$

**定理 6.3.1 (λ演算等价性)**
λ可定义函数类与图灵可计算函数类等价。

## 总结

本计算理论建立了完整的可计算性理论框架，包括：

1. **基础理论**：可计算函数、可计算语言、递归函数
2. **形式化理论**：λ演算、β归约、不动点理论
3. **不可判定性**：停机问题、波斯特对应问题、希尔伯特第十问题
4. **计算模型**：图灵机、寄存器机、λ演算

该理论为计算机科学的基础理论提供了坚实的数学基础，证明了计算的本质限制和可能性边界。

---

**相关链接**：
- [形式语言基础](../01-形式语言基础.md)
- [自动机理论](../02-自动机理论.md)
- [复杂性理论](../04-复杂性理论.md)
