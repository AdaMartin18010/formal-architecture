# 03-语义分析理论：程序含义的形式化基础

## 目录

1. [1.0 属性文法](#10-属性文法)
2. [2.0 类型系统](#20-类型系统)
3. [3.0 静态语义检查](#30-静态语义检查)
4. [4.0 抽象语法树注释](#40-抽象语法树注释)
5. [5.0 语义分析器实现](#50-语义分析器实现)
6. [6.0 形式化证明](#60-形式化证明)

## 1.0 属性文法

### 1.1 属性文法定义

**定义 1.1.1 (属性文法)**
属性文法是上下文无关文法的扩展，定义为 $G = (V, \Sigma, P, S, A, R)$，其中：
- $A$ 为属性集合
- $R$ 为属性计算规则集合

**定义 1.1.2 (综合属性与继承属性)**
- 综合属性：自下而上传递
- 继承属性：自上而下传递

**例 1.1.1**
表达式求值属性文法：
- $E \to E_1 + T$，$E.val = E_1.val + T.val$
- $T \to n$，$T.val = n.lexval$

```rust
#[derive(Debug, Clone)]
pub enum AttributeValue {
    Int(i32),
    Str(String),
    None,
}

#[derive(Debug, Clone)]
pub struct Attribute {
    name: String,
    value: AttributeValue,
}

#[derive(Debug, Clone)]
pub struct AttributedNode {
    node_type: String,
    attributes: Vec<Attribute>,
    children: Vec<AttributedNode>,
}

impl AttributedNode {
    pub fn new(node_type: &str) -> Self {
        Self {
            node_type: node_type.to_string(),
            attributes: Vec::new(),
            children: Vec::new(),
        }
    }
    pub fn add_attribute(&mut self, name: &str, value: AttributeValue) {
        self.attributes.push(Attribute { name: name.to_string(), value });
    }
    pub fn add_child(&mut self, child: AttributedNode) {
        self.children.push(child);
    }
}
```

## 2.0 类型系统

### 2.1 类型系统定义

**定义 2.1.1 (类型系统)**
类型系统是为程序语言中的表达式、变量等分配类型并检查类型一致性的规则集合。

**定义 2.1.2 (类型推断)**
类型推断是自动确定表达式类型的过程。

**例 2.1.1**
简单类型推断规则：
- $x: \text{int}, y: \text{int} \implies x + y: \text{int}$
- $f: \text{int} \to \text{bool}, x: \text{int} \implies f(x): \text{bool}$

```rust
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Type {
    Int,
    Bool,
    Str,
    Function(Box<Type>, Box<Type>),
    Unknown,
}

#[derive(Debug, Clone)]
pub struct TypeEnv {
    env: std::collections::HashMap<String, Type>,
}

impl TypeEnv {
    pub fn new() -> Self {
        Self { env: std::collections::HashMap::new() }
    }
    pub fn set(&mut self, name: &str, ty: Type) {
        self.env.insert(name.to_string(), ty);
    }
    pub fn get(&self, name: &str) -> Option<&Type> {
        self.env.get(name)
    }
}

pub fn infer_type(expr: &AttributedNode, env: &TypeEnv) -> Type {
    match expr.node_type.as_str() {
        "IntLiteral" => Type::Int,
        "BoolLiteral" => Type::Bool,
        "Var" => {
            if let Some(Attribute { value: AttributeValue::Str(ref name), .. }) = expr.attributes.iter().find(|a| a.name == "name") {
                env.get(name).cloned().unwrap_or(Type::Unknown)
            } else {
                Type::Unknown
            }
        }
        "Add" => {
            let t1 = infer_type(&expr.children[0], env);
            let t2 = infer_type(&expr.children[1], env);
            if t1 == Type::Int && t2 == Type::Int { Type::Int } else { Type::Unknown }
        }
        _ => Type::Unknown,
    }
}
```

## 3.0 静态语义检查

### 3.1 静态检查定义

**定义 3.1.1 (静态语义检查)**
静态语义检查是在编译时对程序进行的语义正确性验证，包括类型检查、作用域检查等。

**例 3.1.1**
- 检查变量是否声明
- 检查类型是否一致

```rust
pub fn check_static_semantics(ast: &AttributedNode, env: &mut TypeEnv) -> Result<(), String> {
    match ast.node_type.as_str() {
        "VarDecl" => {
            if let Some(Attribute { value: AttributeValue::Str(ref name), .. }) = ast.attributes.iter().find(|a| a.name == "name") {
                if let Some(Attribute { value: AttributeValue::Str(ref ty), .. }) = ast.attributes.iter().find(|a| a.name == "type") {
                    let ty = match ty.as_str() {
                        "int" => Type::Int,
                        "bool" => Type::Bool,
                        _ => Type::Unknown,
                    };
                    env.set(name, ty);
                }
            }
        }
        "Assign" => {
            let var_type = if let Some(Attribute { value: AttributeValue::Str(ref name), .. }) = ast.attributes.iter().find(|a| a.name == "name") {
                env.get(name).cloned().unwrap_or(Type::Unknown)
            } else { Type::Unknown };
            let expr_type = infer_type(&ast.children[0], env);
            if var_type != expr_type {
                return Err(format!("Type mismatch: {:?} != {:?}", var_type, expr_type));
            }
        }
        _ => {}
    }
    for child in &ast.children {
        check_static_semantics(child, env)?;
    }
    Ok(())
}
```

## 4.0 抽象语法树注释

### 4.1 AST注释定义

**定义 4.1.1 (AST注释)**
在抽象语法树节点上附加属性信息的过程称为AST注释。

**例 4.1.1**
- 在表达式节点上注释类型信息
- 在变量节点上注释作用域信息

```rust
pub fn annotate_ast(ast: &mut AttributedNode, env: &TypeEnv) {
    let ty = infer_type(ast, env);
    ast.add_attribute("type", AttributeValue::Str(format!("{:?}", ty)));
    for child in &mut ast.children {
        annotate_ast(child, env);
    }
}
```

## 5.0 语义分析器实现

### 5.1 语义分析器结构

```rust
#[derive(Debug, Clone)]
pub struct SemanticAnalyzer {
    type_env: TypeEnv,
}

impl SemanticAnalyzer {
    pub fn new() -> Self {
        Self { type_env: TypeEnv::new() }
    }
    pub fn analyze(&mut self, ast: &mut AttributedNode) -> Result<(), String> {
        annotate_ast(ast, &self.type_env);
        check_static_semantics(ast, &mut self.type_env)
    }
}
```

## 6.0 形式化证明

**定理 6.1.1 (类型安全性)**
若程序通过类型检查，则在运行时不会发生类型错误。

**证明**：
归纳证明类型系统的保型性和进展性。

---

## 总结

语义分析理论为程序含义的形式化提供了基础，通过属性文法、类型系统、静态检查等机制，保证了程序的正确性和安全性。 