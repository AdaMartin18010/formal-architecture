# 01-形式语言基础

## 目录

1. [1.0 形式语言理论概述](#10-形式语言理论概述)
2. [2.0 字母表与字符串](#20-字母表与字符串)
3. [3.0 语言定义](#30-语言定义)
4. [4.0 正则语言](#40-正则语言)
5. [5.0 上下文无关语言](#50-上下文无关语言)
6. [6.0 上下文相关语言](#60-上下文相关语言)
7. [7.0 递归可枚举语言](#70-递归可枚举语言)
8. [8.0 计算复杂性理论](#80-计算复杂性理论)
9. [9.0 实践应用](#90-实践应用)

## 1.0 形式语言理论概述

### 1.1 形式语言定义

**定义 1.1.1 (形式语言)**
形式语言是一个二元组 $\mathcal{L} = (\Sigma, L)$，其中：

- $\Sigma$ 是字母表 (Alphabet)
- $L \subseteq \Sigma^*$ 是语言集合

**定义 1.1.2 (字母表)**
字母表是一个有限集合 $\Sigma = \{a_1, a_2, \ldots, a_n\}$，其中每个元素称为符号。

**定义 1.1.3 (字符串)**
字符串是字母表中符号的有限序列，空字符串记为 $\varepsilon$。

**定义 1.1.4 (字符串长度)**
字符串 $w$ 的长度记为 $|w|$，满足：

- $|\varepsilon| = 0$
- $|wa| = |w| + 1$，其中 $a \in \Sigma$

### 1.2 语言操作

**定义 1.2.1 (语言连接)**
语言 $L_1$ 和 $L_2$ 的连接定义为：
$$L_1 \cdot L_2 = \{w_1w_2 \mid w_1 \in L_1, w_2 \in L_2\}$$

**定义 1.2.2 (语言幂)**
语言 $L$ 的幂定义为：

- $L^0 = \{\varepsilon\}$
- $L^{n+1} = L^n \cdot L$

**定义 1.2.3 (语言闭包)**
语言 $L$ 的Kleene闭包定义为：
$$L^* = \bigcup_{n=0}^{\infty} L^n$$

**定义 1.2.4 (语言正闭包)**
语言 $L$ 的正闭包定义为：
$$L^+ = \bigcup_{n=1}^{\infty} L^n$$

```rust
// Rust实现：形式语言
#[derive(Debug, Clone)]
pub struct Alphabet {
    pub symbols: HashSet<char>,
}

#[derive(Debug, Clone)]
pub struct String {
    pub symbols: Vec<char>,
}

#[derive(Debug, Clone)]
pub struct Language {
    pub alphabet: Alphabet,
    pub strings: HashSet<String>,
}

impl Alphabet {
    pub fn new(symbols: Vec<char>) -> Self {
        Alphabet {
            symbols: symbols.into_iter().collect(),
        }
    }
    
    pub fn contains(&self, symbol: char) -> bool {
        self.symbols.contains(&symbol)
    }
}

impl String {
    pub fn new() -> Self {
        String { symbols: Vec::new() }
    }
    
    pub fn from_str(s: &str) -> Self {
        String {
            symbols: s.chars().collect(),
        }
    }
    
    pub fn length(&self) -> usize {
        self.symbols.len()
    }
    
    pub fn is_empty(&self) -> bool {
        self.symbols.is_empty()
    }
    
    pub fn concatenate(&self, other: &String) -> String {
        let mut result = self.symbols.clone();
        result.extend(other.symbols.clone());
        String { symbols: result }
    }
}

impl Language {
    pub fn new(alphabet: Alphabet) -> Self {
        Language {
            alphabet,
            strings: HashSet::new(),
        }
    }
    
    pub fn add_string(&mut self, s: String) {
        self.strings.insert(s);
    }
    
    pub fn concatenate(&self, other: &Language) -> Language {
        let mut result = Language::new(self.alphabet.clone());
        
        for s1 in &self.strings {
            for s2 in &other.strings {
                result.add_string(s1.concatenate(s2));
            }
        }
        
        result
    }
    
    pub fn kleene_star(&self) -> Language {
        let mut result = Language::new(self.alphabet.clone());
        result.add_string(String::new()); // 空字符串
        
        let mut current = self.clone();
        for _ in 0..100 { // 限制迭代次数
            let next = self.concatenate(&current);
            for s in &next.strings {
                result.add_string(s.clone());
            }
            current = next;
        }
        
        result
    }
}
```

## 2.0 字母表与字符串

### 2.1 字符串操作

**定义 2.1.1 (字符串前缀)**
字符串 $w$ 的前缀是满足 $w = xy$ 的字符串 $x$，其中 $y$ 是任意字符串。

**定义 2.1.2 (字符串后缀)**
字符串 $w$ 的后缀是满足 $w = xy$ 的字符串 $y$，其中 $x$ 是任意字符串。

**定义 2.1.3 (字符串子串)**
字符串 $w$ 的子串是满足 $w = xyz$ 的字符串 $y$，其中 $x, z$ 是任意字符串。

**定义 2.1.4 (字符串反转)**
字符串 $w = a_1a_2\ldots a_n$ 的反转定义为 $w^R = a_na_{n-1}\ldots a_1$。

### 2.2 字符串关系

**定义 2.2.1 (字典序)**
字符串 $w_1$ 和 $w_2$ 的字典序关系定义为：
$$w_1 < w_2 \Leftrightarrow \exists x, y, z: w_1 = xay, w_2 = xbz, a < b$$

**定义 2.2.2 (字符串等价)**
字符串 $w_1$ 和 $w_2$ 等价，记为 $w_1 \equiv w_2$，当且仅当 $w_1 = w_2$。

```go
// Go实现：字符串操作
type String struct {
    symbols []rune
}

func NewString(s string) *String {
    return &String{
        symbols: []rune(s),
    }
}

func (s *String) Length() int {
    return len(s.symbols)
}

func (s *String) IsEmpty() bool {
    return len(s.symbols) == 0
}

func (s *String) Prefix(length int) *String {
    if length > len(s.symbols) {
        length = len(s.symbols)
    }
    return &String{
        symbols: s.symbols[:length],
    }
}

func (s *String) Suffix(length int) *String {
    if length > len(s.symbols) {
        length = len(s.symbols)
    }
    return &String{
        symbols: s.symbols[len(s.symbols)-length:],
    }
}

func (s *String) Substring(start, end int) *String {
    if start < 0 {
        start = 0
    }
    if end > len(s.symbols) {
        end = len(s.symbols)
    }
    if start >= end {
        return &String{symbols: []rune{}}
    }
    return &String{
        symbols: s.symbols[start:end],
    }
}

func (s *String) Reverse() *String {
    reversed := make([]rune, len(s.symbols))
    for i, j := 0, len(s.symbols)-1; i < len(s.symbols); i, j = i+1, j-1 {
        reversed[i] = s.symbols[j]
    }
    return &String{symbols: reversed}
}

func (s *String) Compare(other *String) int {
    minLen := len(s.symbols)
    if len(other.symbols) < minLen {
        minLen = len(other.symbols)
    }
    
    for i := 0; i < minLen; i++ {
        if s.symbols[i] < other.symbols[i] {
            return -1
        }
        if s.symbols[i] > other.symbols[i] {
            return 1
        }
    }
    
    if len(s.symbols) < len(other.symbols) {
        return -1
    }
    if len(s.symbols) > len(other.symbols) {
        return 1
    }
    return 0
}
```

## 3.0 语言定义

### 3.1 语言分类

**定义 3.1.1 (Chomsky层次结构)**
Chomsky层次结构将语言分为四个层次：

1. **类型0**：递归可枚举语言
2. **类型1**：上下文相关语言
3. **类型2**：上下文无关语言
4. **类型3**：正则语言

**定理 3.1.1 (语言层次包含关系)**
$$\text{Type 3} \subset \text{Type 2} \subset \text{Type 1} \subset \text{Type 0}$$

### 3.2 语言判定

**定义 3.2.1 (语言判定问题)**
语言判定问题是判断给定字符串 $w$ 是否属于语言 $L$。

**定义 3.2.2 (可判定语言)**
语言 $L$ 是可判定的，如果存在算法能够在有限时间内判定任意字符串是否属于 $L$。

**定义 3.2.3 (可识别语言)**
语言 $L$ 是可识别的，如果存在算法能够识别属于 $L$ 的字符串。

## 4.0 正则语言

### 4.1 正则表达式

**定义 4.1.1 (正则表达式)**
正则表达式是定义正则语言的表达式，递归定义如下：

1. $\emptyset$ 是正则表达式，表示空语言
2. $\varepsilon$ 是正则表达式，表示 $\{\varepsilon\}$
3. $a \in \Sigma$ 是正则表达式，表示 $\{a\}$
4. 如果 $r_1, r_2$ 是正则表达式，则：
   - $(r_1 + r_2)$ 是正则表达式，表示 $L(r_1) \cup L(r_2)$
   - $(r_1 \cdot r_2)$ 是正则表达式，表示 $L(r_1) \cdot L(r_2)$
   - $(r_1^*)$ 是正则表达式，表示 $L(r_1)^*$

**定理 4.1.1 (正则表达式等价性)**
对于任意正则语言 $L$，存在正则表达式 $r$ 使得 $L = L(r)$。

### 4.2 有限自动机

**定义 4.2.1 (确定性有限自动机)**
确定性有限自动机是一个五元组 $M = (Q, \Sigma, \delta, q_0, F)$，其中：

- $Q$ 是状态集合
- $\Sigma$ 是输入字母表
- $\delta: Q \times \Sigma \to Q$ 是转移函数
- $q_0 \in Q$ 是初始状态
- $F \subseteq Q$ 是接受状态集合

**定义 4.2.2 (非确定性有限自动机)**
非确定性有限自动机是一个五元组 $M = (Q, \Sigma, \delta, q_0, F)$，其中：

- $\delta: Q \times \Sigma \to 2^Q$ 是转移函数

**定理 4.2.1 (DFA与NFA等价性)**
对于任意NFA，存在等价的DFA。

```rust
// Rust实现：有限自动机
#[derive(Debug, Clone)]
pub struct DFA {
    pub states: HashSet<State>,
    pub alphabet: Alphabet,
    pub transitions: HashMap<(State, char), State>,
    pub initial_state: State,
    pub accepting_states: HashSet<State>,
}

#[derive(Debug, Clone, Hash, Eq, PartialEq)]
pub struct State(String);

impl DFA {
    pub fn new(alphabet: Alphabet) -> Self {
        DFA {
            states: HashSet::new(),
            alphabet,
            transitions: HashMap::new(),
            initial_state: State("q0".to_string()),
            accepting_states: HashSet::new(),
        }
    }
    
    pub fn add_state(&mut self, state: State) {
        self.states.insert(state);
    }
    
    pub fn add_transition(&mut self, from: State, symbol: char, to: State) {
        self.transitions.insert((from, symbol), to);
    }
    
    pub fn set_accepting(&mut self, state: State) {
        self.accepting_states.insert(state);
    }
    
    pub fn accepts(&self, input: &str) -> bool {
        let mut current_state = self.initial_state.clone();
        
        for symbol in input.chars() {
            if let Some(next_state) = self.transitions.get(&(current_state.clone(), symbol)) {
                current_state = next_state.clone();
            } else {
                return false;
            }
        }
        
        self.accepting_states.contains(&current_state)
    }
}

#[derive(Debug, Clone)]
pub struct NFA {
    pub states: HashSet<State>,
    pub alphabet: Alphabet,
    pub transitions: HashMap<(State, char), HashSet<State>>,
    pub initial_states: HashSet<State>,
    pub accepting_states: HashSet<State>,
}

impl NFA {
    pub fn to_dfa(&self) -> DFA {
        // 子集构造法
        let mut dfa = DFA::new(self.alphabet.clone());
        let mut dfa_states = HashMap::new();
        let mut unprocessed = Vec::new();
        
        // 初始状态
        let initial_dfa_state = State(format!("{:?}", self.initial_states));
        dfa_states.insert(self.initial_states.clone(), initial_dfa_state.clone());
        unprocessed.push(self.initial_states.clone());
        dfa.add_state(initial_dfa_state.clone());
        dfa.initial_state = initial_dfa_state;
        
        while let Some(nfa_states) = unprocessed.pop() {
            let dfa_state = dfa_states.get(&nfa_states).unwrap();
            
            for symbol in &self.alphabet.symbols {
                let mut next_nfa_states = HashSet::new();
                
                for nfa_state in &nfa_states {
                    if let Some(transitions) = self.transitions.get(&(nfa_state.clone(), *symbol)) {
                        next_nfa_states.extend(transitions.clone());
                    }
                }
                
                if !next_nfa_states.is_empty() {
                    let next_dfa_state = if let Some(existing) = dfa_states.get(&next_nfa_states) {
                        existing.clone()
                    } else {
                        let new_state = State(format!("{:?}", next_nfa_states));
                        dfa_states.insert(next_nfa_states.clone(), new_state.clone());
                        unprocessed.push(next_nfa_states);
                        dfa.add_state(new_state.clone());
                        new_state
                    };
                    
                    dfa.add_transition(dfa_state.clone(), *symbol, next_dfa_state);
                }
            }
            
            // 检查是否为接受状态
            for nfa_state in &nfa_states {
                if self.accepting_states.contains(nfa_state) {
                    dfa.set_accepting(dfa_state.clone());
                    break;
                }
            }
        }
        
        dfa
    }
}
```

## 5.0 上下文无关语言

### 5.1 上下文无关文法

**定义 5.1.1 (上下文无关文法)**
上下文无关文法是一个四元组 $G = (V, \Sigma, P, S)$，其中：

- $V$ 是非终结符集合
- $\Sigma$ 是终结符集合
- $P$ 是产生式集合，形式为 $A \to \alpha$，其中 $A \in V, \alpha \in (V \cup \Sigma)^*$
- $S \in V$ 是开始符号

**定义 5.1.2 (推导)**
推导关系 $\Rightarrow$ 定义为：
$$\alpha A \beta \Rightarrow \alpha \gamma \beta \text{ if } A \to \gamma \in P$$

**定义 5.1.3 (语言)**
文法 $G$ 生成的语言定义为：
$$L(G) = \{w \in \Sigma^* \mid S \Rightarrow^* w\}$$

### 5.2 下推自动机

**定义 5.2.1 (下推自动机)**
下推自动机是一个七元组 $M = (Q, \Sigma, \Gamma, \delta, q_0, Z_0, F)$，其中：

- $Q$ 是状态集合
- $\Sigma$ 是输入字母表
- $\Gamma$ 是栈字母表
- $\delta: Q \times \Sigma \times \Gamma \to 2^{Q \times \Gamma^*}$ 是转移函数
- $q_0 \in Q$ 是初始状态
- $Z_0 \in \Gamma$ 是初始栈符号
- $F \subseteq Q$ 是接受状态集合

**定理 5.2.1 (CFG与PDA等价性)**
对于任意上下文无关文法，存在等价的下推自动机。

```go
// Go实现：上下文无关文法
type CFG struct {
    Variables    map[string]bool
    Terminals    map[string]bool
    Productions  []Production
    StartSymbol  string
}

type Production struct {
    Left  string
    Right []string
}

type PDA struct {
    States       map[string]bool
    InputAlphabet map[string]bool
    StackAlphabet map[string]bool
    Transitions  map[TransitionKey][]TransitionValue
    InitialState string
    InitialStack string
    AcceptingStates map[string]bool
}

type TransitionKey struct {
    State string
    Input string
    Stack string
}

type TransitionValue struct {
    State string
    Stack []string
}

func (cfg *CFG) Parse(input []string) bool {
    // CYK算法实现
    n := len(input)
    table := make([][][]string, n)
    for i := range table {
        table[i] = make([][]string, n)
    }
    
    // 初始化对角线
    for i := 0; i < n; i++ {
        for _, prod := range cfg.Productions {
            if len(prod.Right) == 1 && prod.Right[0] == input[i] {
                table[i][i] = append(table[i][i], prod.Left)
            }
        }
    }
    
    // 填充表格
    for length := 2; length <= n; length++ {
        for i := 0; i <= n-length; i++ {
            j := i + length - 1
            for k := i; k < j; k++ {
                for _, prod := range cfg.Productions {
                    if len(prod.Right) == 2 {
                        leftInTable := contains(table[i][k], prod.Right[0])
                        rightInTable := contains(table[k+1][j], prod.Right[1])
                        if leftInTable && rightInTable {
                            table[i][j] = append(table[i][j], prod.Left)
                        }
                    }
                }
            }
        }
    }
    
    return contains(table[0][n-1], cfg.StartSymbol)
}

func contains(slice []string, item string) bool {
    for _, s := range slice {
        if s == item {
            return true
        }
    }
    return false
}
```

## 6.0 上下文相关语言

### 6.1 上下文相关文法

**定义 6.1.1 (上下文相关文法)**
上下文相关文法的产生式形式为：
$$\alpha A \beta \to \alpha \gamma \beta$$
其中 $A \in V, \alpha, \beta \in (V \cup \Sigma)^*, \gamma \in (V \cup \Sigma)^+$

**定义 6.1.2 (线性有界自动机)**
线性有界自动机是一个五元组 $M = (Q, \Sigma, \Gamma, \delta, q_0)$，其中：

- $\delta: Q \times \Gamma \to Q \times \Gamma \times \{L, R\}$ 是转移函数
- 磁带长度受输入长度限制

### 6.2 上下文相关语言性质

**定理 6.1.1 (上下文相关语言封闭性)**
上下文相关语言在以下操作下封闭：

- 并集
- 连接
- Kleene星号
- 交集
- 补集

## 7.0 递归可枚举语言

### 7.1 图灵机

**定义 7.1.1 (图灵机)**
图灵机是一个七元组 $M = (Q, \Sigma, \Gamma, \delta, q_0, B, F)$，其中：

- $Q$ 是状态集合
- $\Sigma$ 是输入字母表
- $\Gamma$ 是磁带字母表
- $\delta: Q \times \Gamma \to Q \times \Gamma \times \{L, R\}$ 是转移函数
- $q_0 \in Q$ 是初始状态
- $B \in \Gamma$ 是空白符号
- $F \subseteq Q$ 是接受状态集合

**定义 7.1.2 (图灵机计算)**
图灵机 $M$ 接受语言：
$$L(M) = \{w \in \Sigma^* \mid M \text{ accepts } w\}$$

### 7.2 递归可枚举语言

**定义 7.2.1 (递归可枚举语言)**
语言 $L$ 是递归可枚举的，如果存在图灵机 $M$ 使得 $L = L(M)$。

**定义 7.2.2 (递归语言)**
语言 $L$ 是递归的，如果存在图灵机 $M$ 使得 $M$ 总是停机且 $L = L(M)$。

**定理 7.2.1 (递归与递归可枚举关系)**
递归语言是递归可枚举语言的真子集。

```rust
// Rust实现：图灵机
#[derive(Debug, Clone)]
pub struct TuringMachine {
    pub states: HashSet<State>,
    pub input_alphabet: Alphabet,
    pub tape_alphabet: Alphabet,
    pub transitions: HashMap<(State, char), (State, char, Direction)>,
    pub initial_state: State,
    pub blank_symbol: char,
    pub accepting_states: HashSet<State>,
}

#[derive(Debug, Clone, Copy)]
pub enum Direction {
    Left,
    Right,
}

#[derive(Debug, Clone)]
pub struct Tape {
    pub left: Vec<char>,
    pub current: char,
    pub right: Vec<char>,
}

impl TuringMachine {
    pub fn new(input_alphabet: Alphabet, tape_alphabet: Alphabet) -> Self {
        TuringMachine {
            states: HashSet::new(),
            input_alphabet,
            tape_alphabet,
            transitions: HashMap::new(),
            initial_state: State("q0".to_string()),
            blank_symbol: 'B',
            accepting_states: HashSet::new(),
        }
    }
    
    pub fn add_transition(&mut self, from: State, read: char, to: State, write: char, direction: Direction) {
        self.transitions.insert((from, read), (to, write, direction));
    }
    
    pub fn run(&self, input: &str) -> bool {
        let mut tape = Tape::new(input, self.blank_symbol);
        let mut current_state = self.initial_state.clone();
        
        loop {
            let current_symbol = tape.read();
            
            if let Some((next_state, write_symbol, direction)) = self.transitions.get(&(current_state.clone(), current_symbol)) {
                tape.write(*write_symbol);
                tape.move_head(*direction);
                current_state = next_state.clone();
            } else {
                return self.accepting_states.contains(&current_state);
            }
        }
    }
}

impl Tape {
    pub fn new(input: &str, blank: char) -> Self {
        let symbols: Vec<char> = input.chars().collect();
        Tape {
            left: Vec::new(),
            current: symbols.first().copied().unwrap_or(blank),
            right: symbols.into_iter().skip(1).collect(),
        }
    }
    
    pub fn read(&self) -> char {
        self.current
    }
    
    pub fn write(&mut self, symbol: char) {
        self.current = symbol;
    }
    
    pub fn move_head(&mut self, direction: Direction) {
        match direction {
            Direction::Left => {
                self.right.insert(0, self.current);
                self.current = self.left.pop().unwrap_or('B');
            }
            Direction::Right => {
                self.left.push(self.current);
                self.current = self.right.remove(0);
            }
        }
    }
}
```

## 8.0 计算复杂性理论

### 8.1 时间复杂度

**定义 8.1.1 (时间复杂度)**
算法的时间复杂度是输入规模 $n$ 的函数 $T(n)$，表示算法在最坏情况下的执行时间。

**定义 8.1.2 (大O记号)**
函数 $f(n) = O(g(n))$ 当且仅当存在常数 $c > 0$ 和 $n_0 > 0$，使得对于所有 $n \geq n_0$，有 $f(n) \leq c \cdot g(n)$。

**常见复杂度类**：

- $O(1)$：常数时间
- $O(\log n)$：对数时间
- $O(n)$：线性时间
- $O(n \log n)$：线性对数时间
- $O(n^2)$：平方时间
- $O(2^n)$：指数时间

### 8.2 空间复杂度

**定义 8.2.1 (空间复杂度)**
算法的空间复杂度是输入规模 $n$ 的函数 $S(n)$，表示算法在最坏情况下使用的额外空间。

**定义 8.2.2 (空间复杂度类)**

- $O(1)$：常数空间
- $O(n)$：线性空间
- $O(n^2)$：平方空间

### 8.3 复杂性类

**定义 8.3.1 (P类)**
P类是多项式时间内可判定的语言集合：
$$P = \{L \mid \exists \text{ TM } M: L(M) = L \text{ and } M \text{ runs in } O(n^k) \text{ time}\}$$

**定义 8.3.2 (NP类)**
NP类是非确定性多项式时间内可判定的语言集合：
$$NP = \{L \mid \exists \text{ NTM } M: L(M) = L \text{ and } M \text{ runs in } O(n^k) \text{ time}\}$$

**定义 8.3.3 (NP完全问题)**
语言 $L$ 是NP完全的，如果：

1. $L \in NP$
2. 对于任意 $L' \in NP$，有 $L' \leq_p L$

```go
// Go实现：复杂度分析
type ComplexityAnalyzer struct {
    algorithms map[string]Algorithm
}

type Algorithm struct {
    name     string
    timeFunc func(int) int
    spaceFunc func(int) int
}

func (ca *ComplexityAnalyzer) AnalyzeTimeComplexity(algorithm string, inputSize int) int {
    if algo, exists := ca.algorithms[algorithm]; exists {
        return algo.timeFunc(inputSize)
    }
    return 0
}

func (ca *ComplexityAnalyzer) AnalyzeSpaceComplexity(algorithm string, inputSize int) int {
    if algo, exists := ca.algorithms[algorithm]; exists {
        return algo.spaceFunc(inputSize)
    }
    return 0
}

// 示例算法复杂度
func linearSearch(n int) int {
    return n // O(n)
}

func binarySearch(n int) int {
    return int(math.Log2(float64(n))) // O(log n)
}

func bubbleSort(n int) int {
    return n * n // O(n^2)
}

func quickSort(n int) int {
    return n * int(math.Log2(float64(n))) // O(n log n)
}
```

## 9.0 实践应用

### 9.1 编译器理论

**定义 9.1.1 (编译器)**
编译器是一个将高级语言程序转换为机器代码的程序。

**编译阶段**：

1. **词法分析**：将源代码转换为词法单元
2. **语法分析**：构建抽象语法树
3. **语义分析**：类型检查和语义验证
4. **中间代码生成**：生成中间表示
5. **代码优化**：优化中间代码
6. **目标代码生成**：生成机器代码

### 9.2 正则表达式引擎

**定义 9.2.1 (正则表达式引擎)**
正则表达式引擎是解析和执行正则表达式的程序。

**实现方法**：

1. **NFA模拟**：直接模拟NFA
2. **DFA模拟**：转换为DFA后模拟
3. **回溯算法**：使用递归回溯

### 9.3 总结

形式语言理论为计算机科学提供了重要的理论基础，涵盖了从简单的正则语言到复杂的递归可枚举语言。

**关键要点**：

1. **语言层次**：Chomsky层次结构
2. **自动机理论**：从DFA到图灵机
3. **文法理论**：从正则表达式到上下文无关文法
4. **计算复杂性**：时间复杂度和空间复杂度
5. **实践应用**：编译器和正则表达式引擎

**下一步工作**：

1. 完善更多语言理论
2. 增加算法分析
3. 开发更多实践工具
4. 建立完整的测试体系

---

**文档版本**：v1.0  
**创建时间**：2024-12-19  
**最后更新**：2024-12-19  
**状态**：完成

**相关链接**：

- [02-数学理论体系](../02-数学理论体系/01-集合论基础.md)
- [02-自动机理论](./02-自动机理论.md)
- [03-计算理论](./03-计算理论.md)
