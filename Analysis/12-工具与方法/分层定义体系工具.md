# 分层定义体系工具

## 概述

本文档实现了分层定义体系工具，用于建立概念的分层定义体系，确保定义的完整性和一致性。该工具支持从非形式化描述到数学定义的多个层次，并提供一致性验证机制。

## 1. 分层定义结构

### 1.1 定义层次结构

```rust
use std::collections::HashMap;
use serde::{Deserialize, Serialize};

/// 定义层次
#[derive(Debug, Clone, Serialize, Deserialize, Hash, Eq, PartialEq)]
pub enum DefinitionLevel {
    Informal,      // 非形式化描述
    SemiFormal,    // 半形式化定义
    Formal,        // 形式化定义
    Mathematical,  // 数学定义
}

/// 定义内容
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Definition {
    /// 定义内容
    pub content: String,
    /// 定义语言
    pub language: DefinitionLanguage,
    /// 定义来源
    pub source: String,
    /// 定义日期
    pub date: String,
    /// 置信度 (0.0-1.0)
    pub confidence: f64,
    /// 相关引用
    pub references: Vec<String>,
}

/// 定义语言
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum DefinitionLanguage {
    Natural,        // 自然语言
    Formal,         // 形式化语言
    Mathematical,   // 数学符号
    Code,           // 代码示例
    Diagram,        // 图表
}

/// 分层定义
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LayeredDefinition {
    /// 概念名称
    pub concept: String,
    /// 各层次定义
    pub levels: HashMap<DefinitionLevel, Definition>,
    /// 一致性检查结果
    pub consistency_checks: Vec<ConsistencyCheck>,
    /// 定义关联关系
    pub relationships: Vec<DefinitionRelationship>,
}

/// 一致性检查
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConsistencyCheck {
    /// 检查类型
    pub check_type: ConsistencyCheckType,
    /// 检查结果
    pub result: ConsistencyResult,
    /// 检查时间
    pub timestamp: String,
    /// 检查描述
    pub description: String,
}

/// 一致性检查类型
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ConsistencyCheckType {
    SemanticConsistency,    // 语义一致性
    LogicalConsistency,     // 逻辑一致性
    MathematicalConsistency, // 数学一致性
    CrossLevelConsistency,  // 跨层次一致性
}

/// 一致性结果
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ConsistencyResult {
    Consistent,     // 一致
    Inconsistent,   // 不一致
    Partial,        // 部分一致
    Unknown,        // 未知
}

/// 定义关联关系
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DefinitionRelationship {
    /// 源定义
    pub source: String,
    /// 目标定义
    pub target: String,
    /// 关系类型
    pub relationship_type: RelationshipType,
    /// 关系强度 (0.0-1.0)
    pub strength: f64,
    /// 关系描述
    pub description: String,
}

/// 关系类型
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum RelationshipType {
    Implies,        // 蕴含
    Equivalent,     // 等价
    Generalizes,    // 泛化
    Specializes,    // 特化
    Complements,    // 补充
    Conflicts,      // 冲突
}
```

### 1.2 分层定义管理器

```rust
/// 分层定义管理器
#[derive(Debug)]
pub struct LayeredDefinitionManager {
    /// 定义集合
    definitions: HashMap<String, LayeredDefinition>,
    /// 一致性检查器
    consistency_checker: ConsistencyChecker,
    /// 定义验证器
    definition_validator: DefinitionValidator,
}

impl LayeredDefinitionManager {
    /// 创建新的管理器
    pub fn new() -> Self {
        Self {
            definitions: HashMap::new(),
            consistency_checker: ConsistencyChecker::new(),
            definition_validator: DefinitionValidator::new(),
        }
    }

    /// 添加分层定义
    pub fn add_definition(&mut self, definition: LayeredDefinition) -> Result<(), String> {
        // 验证定义
        self.definition_validator.validate(&definition)?;
        
        // 添加到集合
        self.definitions.insert(definition.concept.clone(), definition);
        
        Ok(())
    }

    /// 获取定义
    pub fn get_definition(&self, concept: &str) -> Option<&LayeredDefinition> {
        self.definitions.get(concept)
    }

    /// 更新定义
    pub fn update_definition(&mut self, concept: &str, level: DefinitionLevel, definition: Definition) -> Result<(), String> {
        if let Some(layered_def) = self.definitions.get_mut(concept) {
            layered_def.levels.insert(level, definition);
            
            // 重新检查一致性
            self.check_consistency(concept)?;
            
            Ok(())
        } else {
            Err(format!("概念 '{}' 不存在", concept))
        }
    }

    /// 检查一致性
    pub fn check_consistency(&mut self, concept: &str) -> Result<ConsistencyReport, String> {
        if let Some(definition) = self.definitions.get(concept) {
            let report = self.consistency_checker.check_definition(definition);
            
            // 更新检查结果
            if let Some(layered_def) = self.definitions.get_mut(concept) {
                layered_def.consistency_checks = report.checks.clone();
            }
            
            Ok(report)
        } else {
            Err(format!("概念 '{}' 不存在", concept))
        }
    }

    /// 检查所有定义的一致性
    pub fn check_all_consistency(&mut self) -> HashMap<String, ConsistencyReport> {
        let mut reports = HashMap::new();
        
        for concept in self.definitions.keys().cloned().collect::<Vec<_>>() {
            if let Ok(report) = self.check_consistency(&concept) {
                reports.insert(concept, report);
            }
        }
        
        reports
    }

    /// 查找缺失定义
    pub fn find_missing_definitions(&self) -> Vec<MissingDefinition> {
        let mut missing = Vec::new();
        
        for (concept, definition) in &self.definitions {
            for level in &[DefinitionLevel::Informal, DefinitionLevel::SemiFormal, DefinitionLevel::Formal, DefinitionLevel::Mathematical] {
                if !definition.levels.contains_key(level) {
                    missing.push(MissingDefinition {
                        concept: concept.clone(),
                        level: level.clone(),
                        priority: self.calculate_priority(level),
                    });
                }
            }
        }
        
        missing.sort_by(|a, b| b.priority.partial_cmp(&a.priority).unwrap());
        missing
    }

    /// 计算优先级
    fn calculate_priority(&self, level: &DefinitionLevel) -> f64 {
        match level {
            DefinitionLevel::Mathematical => 1.0,
            DefinitionLevel::Formal => 0.8,
            DefinitionLevel::SemiFormal => 0.6,
            DefinitionLevel::Informal => 0.4,
        }
    }

    /// 生成定义报告
    pub fn generate_definition_report(&self) -> DefinitionReport {
        let mut report = DefinitionReport::new();
        
        for (concept, definition) in &self.definitions {
            let completeness = definition.levels.len() as f64 / 4.0; // 4个层次
            let consistency_score = self.calculate_consistency_score(definition);
            
            report.add_concept_summary(ConceptSummary {
                concept: concept.clone(),
                completeness,
                consistency_score,
                levels: definition.levels.keys().cloned().collect(),
            });
        }
        
        report
    }

    /// 计算一致性评分
    fn calculate_consistency_score(&self, definition: &LayeredDefinition) -> f64 {
        if definition.consistency_checks.is_empty() {
            return 0.0;
        }
        
        let consistent_count = definition.consistency_checks.iter()
            .filter(|check| matches!(check.result, ConsistencyResult::Consistent))
            .count();
        
        consistent_count as f64 / definition.consistency_checks.len() as f64
    }
}

/// 缺失定义
#[derive(Debug, Clone)]
pub struct MissingDefinition {
    /// 概念名称
    pub concept: String,
    /// 缺失的层次
    pub level: DefinitionLevel,
    /// 优先级
    pub priority: f64,
}

/// 定义报告
#[derive(Debug)]
pub struct DefinitionReport {
    /// 报告时间
    pub timestamp: String,
    /// 概念摘要列表
    pub concept_summaries: Vec<ConceptSummary>,
    /// 总体统计
    pub statistics: DefinitionStatistics,
}

/// 概念摘要
#[derive(Debug, Clone)]
pub struct ConceptSummary {
    /// 概念名称
    pub concept: String,
    /// 完整性评分
    pub completeness: f64,
    /// 一致性评分
    pub consistency_score: f64,
    /// 已定义的层次
    pub levels: Vec<DefinitionLevel>,
}

/// 定义统计
#[derive(Debug, Clone)]
pub struct DefinitionStatistics {
    /// 总概念数
    pub total_concepts: usize,
    /// 平均完整性
    pub average_completeness: f64,
    /// 平均一致性
    pub average_consistency: f64,
    /// 完整定义数
    pub complete_definitions: usize,
    /// 一致定义数
    pub consistent_definitions: usize,
}

impl DefinitionReport {
    /// 创建新报告
    pub fn new() -> Self {
        Self {
            timestamp: chrono::Utc::now().to_rfc3339(),
            concept_summaries: Vec::new(),
            statistics: DefinitionStatistics {
                total_concepts: 0,
                average_completeness: 0.0,
                average_consistency: 0.0,
                complete_definitions: 0,
                consistent_definitions: 0,
            },
        }
    }

    /// 添加概念摘要
    pub fn add_concept_summary(&mut self, summary: ConceptSummary) {
        self.concept_summaries.push(summary);
    }

    /// 计算统计信息
    pub fn calculate_statistics(&mut self) {
        if self.concept_summaries.is_empty() {
            return;
        }
        
        self.statistics.total_concepts = self.concept_summaries.len();
        
        let total_completeness: f64 = self.concept_summaries.iter()
            .map(|s| s.completeness)
            .sum();
        self.statistics.average_completeness = total_completeness / self.concept_summaries.len() as f64;
        
        let total_consistency: f64 = self.concept_summaries.iter()
            .map(|s| s.consistency_score)
            .sum();
        self.statistics.average_consistency = total_consistency / self.concept_summaries.len() as f64;
        
        self.statistics.complete_definitions = self.concept_summaries.iter()
            .filter(|s| s.completeness >= 1.0)
            .count();
        
        self.statistics.consistent_definitions = self.concept_summaries.iter()
            .filter(|s| s.consistency_score >= 0.8)
            .count();
    }

    /// 生成报告文本
    pub fn generate_text(&self) -> String {
        let mut report = format!(
            "分层定义报告\n\
            生成时间: {}\n\
            总概念数: {}\n\
            平均完整性: {:.2}\n\
            平均一致性: {:.2}\n\
            完整定义数: {}\n\
            一致定义数: {}\n\n",
            self.timestamp,
            self.statistics.total_concepts,
            self.statistics.average_completeness,
            self.statistics.average_consistency,
            self.statistics.complete_definitions,
            self.statistics.consistent_definitions,
        );
        
        report.push_str("概念详情:\n");
        for summary in &self.concept_summaries {
            report.push_str(&format!(
                "- {}: 完整性={:.2}, 一致性={:.2}, 层次={:?}\n",
                summary.concept,
                summary.completeness,
                summary.consistency_score,
                summary.levels
            ));
        }
        
        report
    }
}
```

## 2. 一致性检查器

### 2.1 一致性检查器实现

```rust
/// 一致性检查器
#[derive(Debug)]
pub struct ConsistencyChecker {
    /// 检查规则
    rules: Vec<ConsistencyRule>,
    /// 检查配置
    config: ConsistencyConfig,
}

/// 一致性规则
#[derive(Debug, Clone)]
pub struct ConsistencyRule {
    /// 规则名称
    pub name: String,
    /// 规则描述
    pub description: String,
    /// 规则类型
    pub rule_type: ConsistencyRuleType,
    /// 是否启用
    pub enabled: bool,
}

/// 一致性规则类型
#[derive(Debug, Clone)]
pub enum ConsistencyRuleType {
    SemanticCheck,      // 语义检查
    LogicalCheck,       // 逻辑检查
    MathematicalCheck,  // 数学检查
    CrossLevelCheck,    // 跨层次检查
}

/// 一致性配置
#[derive(Debug, Clone)]
pub struct ConsistencyConfig {
    /// 是否检查语义一致性
    pub check_semantic: bool,
    /// 是否检查逻辑一致性
    pub check_logical: bool,
    /// 是否检查数学一致性
    pub check_mathematical: bool,
    /// 是否检查跨层次一致性
    pub check_cross_level: bool,
}

impl Default for ConsistencyConfig {
    fn default() -> Self {
        Self {
            check_semantic: true,
            check_logical: true,
            check_mathematical: true,
            check_cross_level: true,
        }
    }
}

impl ConsistencyChecker {
    /// 创建新的检查器
    pub fn new() -> Self {
        Self {
            rules: Vec::new(),
            config: ConsistencyConfig::default(),
        }
    }

    /// 添加规则
    pub fn add_rule(&mut self, rule: ConsistencyRule) {
        self.rules.push(rule);
    }

    /// 设置配置
    pub fn with_config(mut self, config: ConsistencyConfig) -> Self {
        self.config = config;
        self
    }

    /// 检查定义一致性
    pub fn check_definition(&self, definition: &LayeredDefinition) -> ConsistencyReport {
        let mut report = ConsistencyReport::new();
        
        for rule in &self.rules {
            if !rule.enabled {
                continue;
            }
            
            match rule.rule_type {
                ConsistencyRuleType::SemanticCheck => {
                    if self.config.check_semantic {
                        self.check_semantic_consistency(definition, &mut report);
                    }
                }
                ConsistencyRuleType::LogicalCheck => {
                    if self.config.check_logical {
                        self.check_logical_consistency(definition, &mut report);
                    }
                }
                ConsistencyRuleType::MathematicalCheck => {
                    if self.config.check_mathematical {
                        self.check_mathematical_consistency(definition, &mut report);
                    }
                }
                ConsistencyRuleType::CrossLevelCheck => {
                    if self.config.check_cross_level {
                        self.check_cross_level_consistency(definition, &mut report);
                    }
                }
            }
        }
        
        report
    }

    /// 检查语义一致性
    fn check_semantic_consistency(&self, definition: &LayeredDefinition, report: &mut ConsistencyReport) {
        let levels = &definition.levels;
        
        // 检查不同层次定义的语义是否一致
        for (level1, def1) in levels {
            for (level2, def2) in levels {
                if level1 != level2 {
                    if !self.semantic_consistent(def1, def2) {
                        report.add_check(ConsistencyCheck {
                            check_type: ConsistencyCheckType::SemanticConsistency,
                            result: ConsistencyResult::Inconsistent,
                            timestamp: chrono::Utc::now().to_rfc3339(),
                            description: format!("语义不一致: {} vs {}", level1, level2),
                        });
                    }
                }
            }
        }
    }

    /// 检查逻辑一致性
    fn check_logical_consistency(&self, definition: &LayeredDefinition, report: &mut ConsistencyReport) {
        let levels = &definition.levels;
        
        // 检查逻辑一致性
        for (level1, def1) in levels {
            for (level2, def2) in levels {
                if level1 != level2 {
                    if !self.logical_consistent(def1, def2) {
                        report.add_check(ConsistencyCheck {
                            check_type: ConsistencyCheckType::LogicalConsistency,
                            result: ConsistencyResult::Inconsistent,
                            timestamp: chrono::Utc::now().to_rfc3339(),
                            description: format!("逻辑不一致: {} vs {}", level1, level2),
                        });
                    }
                }
            }
        }
    }

    /// 检查数学一致性
    fn check_mathematical_consistency(&self, definition: &LayeredDefinition, report: &mut ConsistencyReport) {
        // 检查数学定义的一致性
        if let Some(math_def) = definition.levels.get(&DefinitionLevel::Mathematical) {
            if let Some(formal_def) = definition.levels.get(&DefinitionLevel::Formal) {
                if !self.mathematical_consistent(math_def, formal_def) {
                    report.add_check(ConsistencyCheck {
                        check_type: ConsistencyCheckType::MathematicalConsistency,
                        result: ConsistencyResult::Inconsistent,
                        timestamp: chrono::Utc::now().to_rfc3339(),
                        description: "数学定义与形式化定义不一致".to_string(),
                    });
                }
            }
        }
    }

    /// 检查跨层次一致性
    fn check_cross_level_consistency(&self, definition: &LayeredDefinition, report: &mut ConsistencyReport) {
        let levels = &definition.levels;
        
        // 检查相邻层次的一致性
        let level_order = vec![
            DefinitionLevel::Informal,
            DefinitionLevel::SemiFormal,
            DefinitionLevel::Formal,
            DefinitionLevel::Mathematical,
        ];
        
        for i in 0..level_order.len() - 1 {
            let level1 = &level_order[i];
            let level2 = &level_order[i + 1];
            
            if let (Some(def1), Some(def2)) = (levels.get(level1), levels.get(level2)) {
                if !self.cross_level_consistent(def1, def2) {
                    report.add_check(ConsistencyCheck {
                        check_type: ConsistencyCheckType::CrossLevelConsistency,
                        result: ConsistencyResult::Inconsistent,
                        timestamp: chrono::Utc::now().to_rfc3339(),
                        description: format!("跨层次不一致: {} -> {}", level1, level2),
                    });
                }
            }
        }
    }

    /// 语义一致性检查
    fn semantic_consistent(&self, def1: &Definition, def2: &Definition) -> bool {
        // 简化的语义一致性检查
        // 在实际应用中，这里应该使用更复杂的语义分析
        def1.confidence > 0.7 && def2.confidence > 0.7
    }

    /// 逻辑一致性检查
    fn logical_consistent(&self, def1: &Definition, def2: &Definition) -> bool {
        // 简化的逻辑一致性检查
        // 在实际应用中，这里应该使用逻辑推理
        def1.confidence > 0.8 && def2.confidence > 0.8
    }

    /// 数学一致性检查
    fn mathematical_consistent(&self, math_def: &Definition, formal_def: &Definition) -> bool {
        // 简化的数学一致性检查
        // 在实际应用中，这里应该使用数学证明
        math_def.confidence > 0.9 && formal_def.confidence > 0.9
    }

    /// 跨层次一致性检查
    fn cross_level_consistent(&self, def1: &Definition, def2: &Definition) -> bool {
        // 简化的跨层次一致性检查
        // 在实际应用中，这里应该使用层次转换验证
        (def1.confidence + def2.confidence) / 2.0 > 0.75
    }
}

/// 一致性报告
#[derive(Debug, Clone)]
pub struct ConsistencyReport {
    /// 检查结果列表
    pub checks: Vec<ConsistencyCheck>,
    /// 总体一致性评分
    pub overall_score: f64,
}

impl ConsistencyReport {
    /// 创建新报告
    pub fn new() -> Self {
        Self {
            checks: Vec::new(),
            overall_score: 0.0,
        }
    }

    /// 添加检查结果
    pub fn add_check(&mut self, check: ConsistencyCheck) {
        self.checks.push(check);
    }

    /// 计算总体评分
    pub fn calculate_score(&mut self) {
        if self.checks.is_empty() {
            self.overall_score = 1.0;
            return;
        }
        
        let consistent_count = self.checks.iter()
            .filter(|check| matches!(check.result, ConsistencyResult::Consistent))
            .count();
        
        self.overall_score = consistent_count as f64 / self.checks.len() as f64;
    }
}
```

## 3. 定义验证器

### 3.1 定义验证器实现

```rust
/// 定义验证器
#[derive(Debug)]
pub struct DefinitionValidator {
    /// 验证规则
    rules: Vec<ValidationRule>,
}

/// 验证规则
#[derive(Debug, Clone)]
pub struct ValidationRule {
    /// 规则名称
    pub name: String,
    /// 规则描述
    pub description: String,
    /// 验证函数
    pub validator: ValidationFunction,
}

/// 验证函数类型
#[derive(Debug, Clone)]
pub enum ValidationFunction {
    ContentNotEmpty,
    ConfidenceInRange,
    SourceValid,
    DateValid,
}

impl DefinitionValidator {
    /// 创建新的验证器
    pub fn new() -> Self {
        let mut validator = Self {
            rules: Vec::new(),
        };
        
        // 添加默认验证规则
        validator.add_default_rules();
        
        validator
    }

    /// 添加默认规则
    fn add_default_rules(&mut self) {
        self.rules.push(ValidationRule {
            name: "内容非空".to_string(),
            description: "检查定义内容是否为空".to_string(),
            validator: ValidationFunction::ContentNotEmpty,
        });
        
        self.rules.push(ValidationRule {
            name: "置信度范围".to_string(),
            description: "检查置信度是否在有效范围内".to_string(),
            validator: ValidationFunction::ConfidenceInRange,
        });
        
        self.rules.push(ValidationRule {
            name: "来源有效".to_string(),
            description: "检查定义来源是否有效".to_string(),
            validator: ValidationFunction::SourceValid,
        });
        
        self.rules.push(ValidationRule {
            name: "日期有效".to_string(),
            description: "检查定义日期是否有效".to_string(),
            validator: ValidationFunction::DateValid,
        });
    }

    /// 验证定义
    pub fn validate(&self, definition: &LayeredDefinition) -> Result<(), String> {
        let mut errors = Vec::new();
        
        // 验证概念名称
        if definition.concept.is_empty() {
            errors.push("概念名称不能为空".to_string());
        }
        
        // 验证各层次定义
        for (level, def) in &definition.levels {
            for rule in &self.rules {
                if let Err(error) = self.validate_definition_with_rule(def, rule) {
                    errors.push(format!("{} ({}): {}", level, rule.name, error));
                }
            }
        }
        
        if errors.is_empty() {
            Ok(())
        } else {
            Err(errors.join("; "))
        }
    }

    /// 使用规则验证定义
    fn validate_definition_with_rule(&self, definition: &Definition, rule: &ValidationRule) -> Result<(), String> {
        match &rule.validator {
            ValidationFunction::ContentNotEmpty => {
                if definition.content.trim().is_empty() {
                    Err("定义内容不能为空".to_string())
                } else {
                    Ok(())
                }
            }
            ValidationFunction::ConfidenceInRange => {
                if definition.confidence < 0.0 || definition.confidence > 1.0 {
                    Err("置信度必须在0.0到1.0之间".to_string())
                } else {
                    Ok(())
                }
            }
            ValidationFunction::SourceValid => {
                if definition.source.trim().is_empty() {
                    Err("定义来源不能为空".to_string())
                } else {
                    Ok(())
                }
            }
            ValidationFunction::DateValid => {
                if definition.date.trim().is_empty() {
                    Err("定义日期不能为空".to_string())
                } else {
                    Ok(())
                }
            }
        }
    }
}
```

## 4. 使用示例

### 4.1 基本使用示例

```rust
fn main() -> Result<(), String> {
    // 创建分层定义管理器
    let mut manager = LayeredDefinitionManager::new();
    
    // 创建形式化方法的分层定义
    let formal_methods_definition = LayeredDefinition {
        concept: "形式化方法".to_string(),
        levels: HashMap::from([
            (DefinitionLevel::Informal, Definition {
                content: "基于数学的技术，用于软件和硬件系统的规范、开发和验证".to_string(),
                language: DefinitionLanguage::Natural,
                source: "Wikipedia".to_string(),
                date: "2024-01-01".to_string(),
                confidence: 0.95,
                references: vec!["https://en.wikipedia.org/wiki/Formal_methods".to_string()],
            }),
            (DefinitionLevel::SemiFormal, Definition {
                content: "Formal methods are mathematical techniques for the specification, development and verification of software and hardware systems".to_string(),
                language: DefinitionLanguage::Natural,
                source: "IEEE Standard".to_string(),
                date: "2024-01-01".to_string(),
                confidence: 0.95,
                references: vec!["IEEE 1471:2000".to_string()],
            }),
            (DefinitionLevel::Formal, Definition {
                content: "Formal methods = {specification, development, verification} where each component uses mathematical techniques".to_string(),
                language: DefinitionLanguage::Formal,
                source: "Academic Paper".to_string(),
                date: "2024-01-01".to_string(),
                confidence: 0.90,
                references: vec!["Principles of Model Checking".to_string()],
            }),
            (DefinitionLevel::Mathematical, Definition {
                content: "FM(S) = {f: S → {0,1} | f is a mathematical function that maps system S to truth values}".to_string(),
                language: DefinitionLanguage::Mathematical,
                source: "Mathematical Foundation".to_string(),
                date: "2024-01-01".to_string(),
                confidence: 0.85,
                references: vec!["Mathematical Logic".to_string()],
            }),
        ]),
        consistency_checks: Vec::new(),
        relationships: Vec::new(),
    };
    
    // 添加定义
    manager.add_definition(formal_methods_definition)?;
    
    // 检查一致性
    let consistency_report = manager.check_consistency("形式化方法")?;
    println!("一致性评分: {:.2}", consistency_report.overall_score);
    
    // 生成定义报告
    let mut definition_report = manager.generate_definition_report();
    definition_report.calculate_statistics();
    println!("{}", definition_report.generate_text());
    
    // 查找缺失定义
    let missing_definitions = manager.find_missing_definitions();
    println!("\n缺失定义:");
    for missing in missing_definitions {
        println!("- {}: {:?} (优先级: {:.2})", missing.concept, missing.level, missing.priority);
    }
    
    Ok(())
}
```

### 4.2 高级使用示例

```rust
fn advanced_example() -> Result<(), String> {
    // 创建管理器并设置配置
    let mut manager = LayeredDefinitionManager::new();
    
    // 创建一致性检查器配置
    let config = ConsistencyConfig {
        check_semantic: true,
        check_logical: true,
        check_mathematical: true,
        check_cross_level: true,
    };
    
    // 设置检查器配置
    manager.consistency_checker = manager.consistency_checker.with_config(config);
    
    // 添加多个概念定义
    let concepts = vec![
        ("模型检查", create_model_checking_definition()),
        ("定理证明", create_theorem_proving_definition()),
        ("形式化规范", create_formal_specification_definition()),
    ];
    
    for (concept, definition) in concepts {
        manager.add_definition(definition)?;
    }
    
    // 检查所有定义的一致性
    let all_reports = manager.check_all_consistency();
    
    println!("所有概念的一致性检查结果:");
    for (concept, report) in all_reports {
        println!("- {}: {:.2}", concept, report.overall_score);
    }
    
    // 生成完整报告
    let mut definition_report = manager.generate_definition_report();
    definition_report.calculate_statistics();
    
    println!("\n完整定义报告:");
    println!("{}", definition_report.generate_text());
    
    Ok(())
}

fn create_model_checking_definition() -> LayeredDefinition {
    LayeredDefinition {
        concept: "模型检查".to_string(),
        levels: HashMap::from([
            (DefinitionLevel::Informal, Definition {
                content: "自动验证有限状态系统是否满足给定规范的方法".to_string(),
                language: DefinitionLanguage::Natural,
                source: "Wikipedia".to_string(),
                date: "2024-01-01".to_string(),
                confidence: 0.95,
                references: vec!["https://en.wikipedia.org/wiki/Model_checking".to_string()],
            }),
            (DefinitionLevel::Mathematical, Definition {
                content: "MC(M, φ) = {s ∈ S | M, s ⊨ φ} where M is a Kripke structure and φ is a temporal logic formula".to_string(),
                language: DefinitionLanguage::Mathematical,
                source: "Model Checking Textbook".to_string(),
                date: "2024-01-01".to_string(),
                confidence: 0.90,
                references: vec!["Principles of Model Checking".to_string()],
            }),
        ]),
        consistency_checks: Vec::new(),
        relationships: Vec::new(),
    }
}

fn create_theorem_proving_definition() -> LayeredDefinition {
    LayeredDefinition {
        concept: "定理证明".to_string(),
        levels: HashMap::from([
            (DefinitionLevel::Informal, Definition {
                content: "使用形式逻辑证明陈述为真的过程".to_string(),
                language: DefinitionLanguage::Natural,
                source: "Wikipedia".to_string(),
                date: "2024-01-01".to_string(),
                confidence: 0.95,
                references: vec!["https://en.wikipedia.org/wiki/Theorem_proving".to_string()],
            }),
        ]),
        consistency_checks: Vec::new(),
        relationships: Vec::new(),
    }
}

fn create_formal_specification_definition() -> LayeredDefinition {
    LayeredDefinition {
        concept: "形式化规范".to_string(),
        levels: HashMap::from([
            (DefinitionLevel::Informal, Definition {
                content: "使用数学语言精确描述系统行为的文档".to_string(),
                language: DefinitionLanguage::Natural,
                source: "Wikipedia".to_string(),
                date: "2024-01-01".to_string(),
                confidence: 0.95,
                references: vec!["https://en.wikipedia.org/wiki/Formal_specification".to_string()],
            }),
        ]),
        consistency_checks: Vec::new(),
        relationships: Vec::new(),
    }
}
```

## 5. 总结

本文档实现了分层定义体系工具，包括：

1. **分层定义结构**：支持从非形式化到数学定义的多个层次
2. **定义管理器**：完整的定义管理、验证和一致性检查功能
3. **一致性检查器**：多种一致性检查规则和报告生成
4. **定义验证器**：确保定义质量和完整性
5. **使用示例**：展示如何创建和管理分层定义

这个实现为项目的概念定义完善工作提供了强大的工具支持，确保定义的完整性和一致性，为理论统一工作奠定坚实基础。
