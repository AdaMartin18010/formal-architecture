# 概念映射关系工具 - 第一部分

## 概述

本文档实现了概念映射关系工具的核心部分，用于建立理论到实现、跨语言的映射关系，确保概念定义的一致性和语义一致性。

## 1. 概念映射结构

### 1.1 映射关系定义

```rust
use std::collections::{HashMap, HashSet};
use serde::{Deserialize, Serialize};

/// 概念映射关系
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConceptMapping {
    /// 映射ID
    pub id: String,
    /// 源概念
    pub source_concept: Concept,
    /// 目标概念
    pub target_concept: Concept,
    /// 映射类型
    pub mapping_type: MappingType,
    /// 映射强度 (0.0-1.0)
    pub strength: f64,
    /// 映射描述
    pub description: String,
    /// 映射证据
    pub evidence: Vec<String>,
    /// 置信度 (0.0-1.0)
    pub confidence: f64,
}

/// 概念定义
#[derive(Debug, Clone, Serialize, Deserialize, Hash, Eq, PartialEq)]
pub struct Concept {
    /// 概念名称
    pub name: String,
    /// 概念域
    pub domain: ConceptDomain,
    /// 概念类型
    pub concept_type: ConceptType,
    /// 定义描述
    pub definition: String,
    /// 上下文信息
    pub context: String,
}

/// 概念域
#[derive(Debug, Clone, Serialize, Deserialize, Hash, Eq, PartialEq)]
pub enum ConceptDomain {
    Theory,           // 理论域
    Implementation,   // 实现域
    Language,         // 语言域
    Standard,         // 标准域
    Academic,         // 学术域
}

/// 概念类型
#[derive(Debug, Clone, Serialize, Deserialize, Hash, Eq, PartialEq)]
pub enum ConceptType {
    Abstract,         // 抽象概念
    Concrete,         // 具体概念
    Algorithm,        // 算法
    DataStructure,    // 数据结构
    Pattern,          // 模式
    Mechanism,        // 机制
    Principle,        // 原理
    Method,           // 方法
}

/// 映射类型
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum MappingType {
    Equivalent,       // 等价映射
    Subset,           // 子集映射
    Superset,         // 超集映射
    Implementation,   // 实现映射
    Abstraction,      // 抽象映射
    Specialization,   // 特化映射
    Generalization,   // 泛化映射
    Related,          // 相关映射
}
```

### 1.2 映射数据库结构

```rust
/// 概念映射数据库
#[derive(Debug, Clone)]
pub struct ConceptMappingDatabase {
    /// 映射关系集合
    mappings: HashMap<String, ConceptMapping>,
    /// 概念索引
    concept_index: HashMap<Concept, HashSet<String>>,
    /// 域索引
    domain_index: HashMap<ConceptDomain, HashSet<String>>,
    /// 类型索引
    type_index: HashMap<ConceptType, HashSet<String>>,
    /// 映射类型索引
    mapping_type_index: HashMap<MappingType, HashSet<String>>,
}

impl ConceptMappingDatabase {
    /// 创建新的映射数据库
    pub fn new() -> Self {
        Self {
            mappings: HashMap::new(),
            concept_index: HashMap::new(),
            domain_index: HashMap::new(),
            type_index: HashMap::new(),
            mapping_type_index: HashMap::new(),
        }
    }

    /// 添加映射关系
    pub fn add_mapping(&mut self, mapping: ConceptMapping) -> Result<(), String> {
        let id = mapping.id.clone();
        
        // 验证映射关系
        self.validate_mapping(&mapping)?;
        
        // 添加到主映射
        self.mappings.insert(id.clone(), mapping.clone());
        
        // 更新概念索引
        self.concept_index
            .entry(mapping.source_concept.clone())
            .or_insert_with(HashSet::new)
            .insert(id.clone());
        self.concept_index
            .entry(mapping.target_concept.clone())
            .or_insert_with(HashSet::new)
            .insert(id.clone());
        
        // 更新域索引
        self.domain_index
            .entry(mapping.source_concept.domain.clone())
            .or_insert_with(HashSet::new)
            .insert(id.clone());
        self.domain_index
            .entry(mapping.target_concept.domain.clone())
            .or_insert_with(HashSet::new)
            .insert(id.clone());
        
        // 更新类型索引
        self.type_index
            .entry(mapping.source_concept.concept_type.clone())
            .or_insert_with(HashSet::new)
            .insert(id.clone());
        self.type_index
            .entry(mapping.target_concept.concept_type.clone())
            .or_insert_with(HashSet::new)
            .insert(id.clone());
        
        // 更新映射类型索引
        self.mapping_type_index
            .entry(mapping.mapping_type.clone())
            .or_insert_with(HashSet::new)
            .insert(id.clone());
        
        Ok(())
    }

    /// 验证映射关系
    fn validate_mapping(&self, mapping: &ConceptMapping) -> Result<(), String> {
        if mapping.id.is_empty() {
            return Err("映射ID不能为空".to_string());
        }
        
        if mapping.source_concept.name.is_empty() {
            return Err("源概念名称不能为空".to_string());
        }
        
        if mapping.target_concept.name.is_empty() {
            return Err("目标概念名称不能为空".to_string());
        }
        
        if mapping.strength < 0.0 || mapping.strength > 1.0 {
            return Err("映射强度必须在0.0到1.0之间".to_string());
        }
        
        if mapping.confidence < 0.0 || mapping.confidence > 1.0 {
            return Err("置信度必须在0.0到1.0之间".to_string());
        }
        
        Ok(())
    }

    /// 查找概念的所有映射
    pub fn find_mappings_for_concept(&self, concept: &Concept) -> Vec<&ConceptMapping> {
        if let Some(mapping_ids) = self.concept_index.get(concept) {
            mapping_ids
                .iter()
                .filter_map(|id| self.mappings.get(id))
                .collect()
        } else {
            Vec::new()
        }
    }

    /// 查找两个概念之间的映射
    pub fn find_mapping_between(&self, source: &Concept, target: &Concept) -> Option<&ConceptMapping> {
        for mapping in self.mappings.values() {
            if (&mapping.source_concept == source && &mapping.target_concept == target) ||
               (&mapping.source_concept == target && &mapping.target_concept == source) {
                return Some(mapping);
            }
        }
        None
    }

    /// 按域查找映射
    pub fn find_mappings_by_domain(&self, domain: &ConceptDomain) -> Vec<&ConceptMapping> {
        if let Some(mapping_ids) = self.domain_index.get(domain) {
            mapping_ids
                .iter()
                .filter_map(|id| self.mappings.get(id))
                .collect()
        } else {
            Vec::new()
        }
    }

    /// 按类型查找映射
    pub fn find_mappings_by_type(&self, concept_type: &ConceptType) -> Vec<&ConceptMapping> {
        if let Some(mapping_ids) = self.type_index.get(concept_type) {
            mapping_ids
                .iter()
                .filter_map(|id| self.mappings.get(id))
                .collect()
        } else {
            Vec::new()
        }
    }

    /// 按映射类型查找
    pub fn find_mappings_by_mapping_type(&self, mapping_type: &MappingType) -> Vec<&ConceptMapping> {
        if let Some(mapping_ids) = self.mapping_type_index.get(mapping_type) {
            mapping_ids
                .iter()
                .filter_map(|id| self.mappings.get(id))
                .collect()
        } else {
            Vec::new()
        }
    }

    /// 搜索映射
    pub fn search_mappings(&self, query: &str) -> Vec<&ConceptMapping> {
        let query_lower = query.to_lowercase();
        let mut results = Vec::new();
        
        for mapping in self.mappings.values() {
            if mapping.source_concept.name.to_lowercase().contains(&query_lower) ||
               mapping.target_concept.name.to_lowercase().contains(&query_lower) ||
               mapping.description.to_lowercase().contains(&query_lower) {
                results.push(mapping);
            }
        }
        
        results
    }

    /// 获取所有映射
    pub fn get_all_mappings(&self) -> Vec<&ConceptMapping> {
        self.mappings.values().collect()
    }

    /// 获取映射总数
    pub fn mapping_count(&self) -> usize {
        self.mappings.len()
    }
}
```

## 2. 理论到实现映射示例

### 2.1 形式化方法映射

```rust
/// 形式化方法映射数据
pub struct FormalMethodsMappings;

impl FormalMethodsMappings {
    /// 获取形式化方法相关映射
    pub fn get_mappings() -> Vec<ConceptMapping> {
        vec![
            ConceptMapping {
                id: "fm_001".to_string(),
                source_concept: Concept {
                    name: "形式化方法".to_string(),
                    domain: ConceptDomain::Theory,
                    concept_type: ConceptType::Method,
                    definition: "基于数学的技术，用于软件和硬件系统的规范、开发和验证".to_string(),
                    context: "Software Engineering Theory".to_string(),
                },
                target_concept: Concept {
                    name: "Formal Methods".to_string(),
                    domain: ConceptDomain::Standard,
                    concept_type: ConceptType::Method,
                    definition: "Mathematical techniques for the specification, development and verification of software and hardware systems".to_string(),
                    context: "IEEE Standard".to_string(),
                },
                mapping_type: MappingType::Equivalent,
                strength: 0.95,
                description: "形式化方法在IEEE标准中的等价定义".to_string(),
                evidence: vec![
                    "IEEE 1471:2000".to_string(),
                    "ISO/IEC 12207".to_string(),
                ],
                confidence: 0.95,
            },
            ConceptMapping {
                id: "fm_002".to_string(),
                source_concept: Concept {
                    name: "模型检查".to_string(),
                    domain: ConceptDomain::Theory,
                    concept_type: ConceptType::Method,
                    definition: "自动验证有限状态系统是否满足给定规范的方法".to_string(),
                    context: "Formal Verification".to_string(),
                },
                target_concept: Concept {
                    name: "Model Checking".to_string(),
                    domain: ConceptDomain::Implementation,
                    concept_type: ConceptType::Algorithm,
                    definition: "Algorithm for automatically checking whether a finite-state model of a system meets a given specification".to_string(),
                    context: "SPIN Model Checker".to_string(),
                },
                mapping_type: MappingType::Implementation,
                strength: 0.90,
                description: "模型检查理论在SPIN工具中的实现".to_string(),
                evidence: vec![
                    "SPIN Model Checker Documentation".to_string(),
                    "Principles of Model Checking".to_string(),
                ],
                confidence: 0.90,
            },
        ]
    }
}
```

## 3. 使用示例

```rust
fn main() -> Result<(), String> {
    // 创建映射数据库
    let mut database = ConceptMappingDatabase::new();
    
    // 导入形式化方法映射
    let formal_methods_mappings = FormalMethodsMappings::get_mappings();
    for mapping in formal_methods_mappings {
        database.add_mapping(mapping)?;
    }
    
    // 输出统计信息
    println!("映射数据库统计:");
    println!("- 总映射数: {}", database.mapping_count());
    
    // 搜索示例
    println!("\n搜索'形式化'的结果:");
    let search_results = database.search_mappings("形式化");
    for mapping in search_results {
        println!("- {} -> {} (强度: {:.2})", 
            mapping.source_concept.name, 
            mapping.target_concept.name, 
            mapping.strength);
    }
    
    // 按域查找示例
    println!("\n理论域映射:");
    let theory_mappings = database.find_mappings_by_domain(&ConceptDomain::Theory);
    for mapping in theory_mappings {
        println!("- {} -> {} ({})", 
            mapping.source_concept.name, 
            mapping.target_concept.name, 
            mapping.mapping_type);
    }
    
    Ok(())
}
```

## 4. 总结

本文档实现了概念映射关系工具的第一部分，包括：

1. **概念映射结构**：完整的映射关系定义，支持多种映射类型
2. **映射数据库**：高效的映射存储和查询机制
3. **理论到实现映射示例**：形式化方法的具体映射示例
4. **使用示例**：展示如何创建和使用映射数据库

这个实现为项目的概念统一工作提供了坚实的基础，确保理论概念与实现概念之间的一致性和语义一致性。
