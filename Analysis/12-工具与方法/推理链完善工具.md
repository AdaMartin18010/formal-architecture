# 推理链完善工具

## 概述

本文档实现了推理链完善工具，用于完善理论推理链，确保逻辑推理的完整性和正确性。
该工具支持推理步骤建模、推理链验证、缺失步骤识别和推理规则管理。

## 1. 推理链结构

### 1.1 核心数据结构

```rust
use std::collections::{HashMap, HashSet};
use serde::{Deserialize, Serialize};

/// 推理链
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReasoningChain {
    /// 推理链ID
    pub id: String,
    /// 推理链名称
    pub name: String,
    /// 推理步骤列表
    pub steps: Vec<ReasoningStep>,
    /// 前提条件
    pub premises: Vec<Proposition>,
    /// 结论
    pub conclusions: Vec<Proposition>,
    /// 推理规则
    pub inference_rules: Vec<InferenceRule>,
    /// 推理链描述
    pub description: String,
    /// 推理链状态
    pub status: ReasoningStatus,
    /// 元数据
    pub metadata: HashMap<String, String>,
}

/// 推理步骤
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReasoningStep {
    /// 步骤ID
    pub id: String,
    /// 步骤名称
    pub name: String,
    /// 输入命题
    pub input: Vec<Proposition>,
    /// 输出命题
    pub output: Proposition,
    /// 使用的推理规则
    pub rule: InferenceRule,
    /// 推理依据
    pub justification: Justification,
    /// 步骤顺序
    pub order: usize,
    /// 步骤状态
    pub status: StepStatus,
}

/// 命题
#[derive(Debug, Clone, Serialize, Deserialize, Hash, Eq, PartialEq)]
pub struct Proposition {
    /// 命题ID
    pub id: String,
    /// 命题内容
    pub content: String,
    /// 命题类型
    pub proposition_type: PropositionType,
    /// 命题真值
    pub truth_value: Option<bool>,
    /// 命题来源
    pub source: String,
    /// 命题置信度
    pub confidence: f64,
}

/// 命题类型
#[derive(Debug, Clone, Serialize, Deserialize, Hash, Eq, PartialEq)]
pub enum PropositionType {
    Axiom,          // 公理
    Theorem,        // 定理
    Lemma,          // 引理
    Corollary,      // 推论
    Hypothesis,     // 假设
    Conclusion,     // 结论
    Definition,     // 定义
    Other,          // 其他
}

/// 推理规则
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InferenceRule {
    /// 规则ID
    pub id: String,
    /// 规则名称
    pub name: String,
    /// 规则描述
    pub description: String,
    /// 规则类型
    pub rule_type: RuleType,
    /// 规则模式
    pub pattern: RulePattern,
    /// 规则有效性
    pub validity: RuleValidity,
}

/// 规则类型
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum RuleType {
    ModusPonens,        // 假言推理
    ModusTollens,       // 否定后件
    HypotheticalSyllogism, // 假言三段论
    DisjunctiveSyllogism,  // 选言三段论
    Conjunction,        // 合取
    Simplification,     // 简化
    Addition,           // 附加
    UniversalGeneralization, // 全称概括
    UniversalInstantiation,  // 全称例化
    ExistentialGeneralization, // 存在概括
    ExistentialInstantiation,  // 存在例化
    MathematicalInduction,     // 数学归纳
    Other,              // 其他
}

/// 规则模式
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RulePattern {
    /// 前提模式
    pub premises: Vec<String>,
    /// 结论模式
    pub conclusion: String,
    /// 约束条件
    pub constraints: Vec<String>,
}

/// 规则有效性
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum RuleValidity {
    Valid,         // 有效
    Invalid,       // 无效
    Conditional,   // 条件有效
    Unknown,       // 未知
}

/// 推理依据
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Justification {
    /// 依据类型
    pub justification_type: JustificationType,
    /// 依据内容
    pub content: String,
    /// 依据来源
    pub source: String,
    /// 依据强度
    pub strength: f64,
    /// 相关引用
    pub references: Vec<String>,
}

/// 依据类型
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum JustificationType {
    Logical,       // 逻辑推理
    Empirical,     // 经验证据
    Axiomatic,     // 公理基础
    Definitional,  // 定义基础
    Theorematical, // 定理基础
    Other,         // 其他
}

/// 推理状态
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ReasoningStatus {
    Valid,         // 有效
    Invalid,       // 无效
    Incomplete,    // 不完整
    UnderReview,   // 审查中
    Experimental,  // 实验性
}

/// 步骤状态
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum StepStatus {
    Valid,         // 有效
    Invalid,       // 无效
    Questionable,  // 可疑
    Missing,       // 缺失
    Pending,       // 待定
}
```

### 1.2 推理链管理器

```rust
/// 推理链管理器
#[derive(Debug)]
pub struct ReasoningChainManager {
    /// 推理链集合
    chains: HashMap<String, ReasoningChain>,
    /// 推理规则库
    rule_library: HashMap<String, InferenceRule>,
    /// 有效性检查器
    validity_checker: ValidityChecker,
    /// 完整性分析器
    completeness_analyzer: CompletenessAnalyzer,
}

impl ReasoningChainManager {
    /// 创建新的管理器
    pub fn new() -> Self {
        let mut manager = Self {
            chains: HashMap::new(),
            rule_library: HashMap::new(),
            validity_checker: ValidityChecker::new(),
            completeness_analyzer: CompletenessAnalyzer::new(),
        };
        
        // 初始化默认推理规则
        manager.initialize_default_rules();
        
        manager
    }

    /// 初始化默认推理规则
    fn initialize_default_rules(&mut self) {
        // 假言推理规则
        let modus_ponens = InferenceRule {
            id: "modus_ponens".to_string(),
            name: "假言推理".to_string(),
            description: "如果P蕴含Q，且P为真，则Q为真".to_string(),
            rule_type: RuleType::ModusPonens,
            pattern: RulePattern {
                premises: vec!["P → Q".to_string(), "P".to_string()],
                conclusion: "Q".to_string(),
                constraints: Vec::new(),
            },
            validity: RuleValidity::Valid,
        };
        
        // 否定后件规则
        let modus_tollens = InferenceRule {
            id: "modus_tollens".to_string(),
            name: "否定后件".to_string(),
            description: "如果P蕴含Q，且Q为假，则P为假".to_string(),
            rule_type: RuleType::ModusTollens,
            pattern: RulePattern {
                premises: vec!["P → Q".to_string(), "¬Q".to_string()],
                conclusion: "¬P".to_string(),
                constraints: Vec::new(),
            },
            validity: RuleValidity::Valid,
        };
        
        // 假言三段论规则
        let hypothetical_syllogism = InferenceRule {
            id: "hypothetical_syllogism".to_string(),
            name: "假言三段论".to_string(),
            description: "如果P蕴含Q，且Q蕴含R，则P蕴含R".to_string(),
            rule_type: RuleType::HypotheticalSyllogism,
            pattern: RulePattern {
                premises: vec!["P → Q".to_string(), "Q → R".to_string()],
                conclusion: "P → R".to_string(),
                constraints: Vec::new(),
            },
            validity: RuleValidity::Valid,
        };
        
        self.rule_library.insert(modus_ponens.id.clone(), modus_ponens);
        self.rule_library.insert(modus_tollens.id.clone(), modus_tollens);
        self.rule_library.insert(hypothetical_syllogism.id.clone(), hypothetical_syllogism);
    }

    /// 添加推理链
    pub fn add_chain(&mut self, chain: ReasoningChain) -> Result<(), String> {
        // 验证推理链
        self.validate_chain(&chain)?;
        
        // 添加到集合
        self.chains.insert(chain.id.clone(), chain);
        
        Ok(())
    }

    /// 验证推理链
    fn validate_chain(&self, chain: &ReasoningChain) -> Result<(), String> {
        if chain.id.is_empty() {
            return Err("推理链ID不能为空".to_string());
        }
        
        if chain.name.is_empty() {
            return Err("推理链名称不能为空".to_string());
        }
        
        if chain.steps.is_empty() {
            return Err("推理链必须包含至少一个推理步骤".to_string());
        }
        
        // 验证步骤顺序
        let mut step_orders: Vec<usize> = chain.steps.iter().map(|s| s.order).collect();
        step_orders.sort();
        for (i, &order) in step_orders.iter().enumerate() {
            if order != i {
                return Err(format!("推理步骤顺序不正确，期望{}，实际{}", i, order));
            }
        }
        
        Ok(())
    }

    /// 获取推理链
    pub fn get_chain(&self, chain_id: &str) -> Option<&ReasoningChain> {
        self.chains.get(chain_id)
    }

    /// 验证推理链有效性
    pub fn validate_chain_validity(&self, chain_id: &str) -> Result<ValidityResult, String> {
        if let Some(chain) = self.chains.get(chain_id) {
            self.validity_checker.check_chain(chain)
        } else {
            Err(format!("推理链 '{}' 不存在", chain_id))
        }
    }

    /// 分析推理链完整性
    pub fn analyze_chain_completeness(&self, chain_id: &str) -> Result<CompletenessReport, String> {
        if let Some(chain) = self.chains.get(chain_id) {
            self.completeness_analyzer.analyze_chain(chain)
        } else {
            Err(format!("推理链 '{}' 不存在", chain_id))
        }
    }

    /// 查找缺失的推理步骤
    pub fn find_missing_steps(&self, chain_id: &str) -> Result<Vec<MissingStep>, String> {
        if let Some(chain) = self.chains.get(chain_id) {
            self.completeness_analyzer.find_missing_steps(chain)
        } else {
            Err(format!("推理链 '{}' 不存在", chain_id))
        }
    }

    /// 添加推理规则
    pub fn add_rule(&mut self, rule: InferenceRule) -> Result<(), String> {
        if rule.id.is_empty() {
            return Err("推理规则ID不能为空".to_string());
        }
        
        if self.rule_library.contains_key(&rule.id) {
            return Err(format!("推理规则 '{}' 已存在", rule.id));
        }
        
        self.rule_library.insert(rule.id.clone(), rule);
        Ok(())
    }

    /// 获取推理规则
    pub fn get_rule(&self, rule_id: &str) -> Option<&InferenceRule> {
        self.rule_library.get(rule_id)
    }

    /// 生成推理链报告
    pub fn generate_chain_report(&self, chain_id: &str) -> Result<ReasoningChainReport, String> {
        if let Some(chain) = self.chains.get(chain_id) {
            let validity_result = self.validity_checker.check_chain(chain)?;
            let completeness_report = self.completeness_analyzer.analyze_chain(chain)?;
            
            Ok(ReasoningChainReport {
                chain_id: chain_id.to_string(),
                chain_name: chain.name.clone(),
                validity_result,
                completeness_report,
                step_details: chain.steps.clone(),
                timestamp: chrono::Utc::now().to_rfc3339(),
            })
        } else {
            Err(format!("推理链 '{}' 不存在", chain_id))
        }
    }

    /// 获取所有推理链
    pub fn get_all_chains(&self) -> Vec<&ReasoningChain> {
        self.chains.values().collect()
    }

    /// 按状态查找推理链
    pub fn find_chains_by_status(&self, status: &ReasoningStatus) -> Vec<&ReasoningChain> {
        self.chains.values()
            .filter(|chain| &chain.status == status)
            .collect()
    }

    /// 搜索推理链
    pub fn search_chains(&self, query: &str) -> Vec<&ReasoningChain> {
        let query_lower = query.to_lowercase();
        self.chains.values()
            .filter(|chain| {
                chain.name.to_lowercase().contains(&query_lower) ||
                chain.description.to_lowercase().contains(&query_lower)
            })
            .collect()
    }
}

/// 缺失步骤
#[derive(Debug, Clone)]
pub struct MissingStep {
    /// 步骤位置
    pub position: usize,
    /// 缺失步骤描述
    pub description: String,
    /// 建议的推理规则
    pub suggested_rule: Option<String>,
    /// 优先级
    pub priority: f64,
}

/// 推理链报告
#[derive(Debug, Clone)]
pub struct ReasoningChainReport {
    /// 推理链ID
    pub chain_id: String,
    /// 推理链名称
    pub chain_name: String,
    /// 有效性结果
    pub validity_result: ValidityResult,
    /// 完整性报告
    pub completeness_report: CompletenessReport,
    /// 步骤详情
    pub step_details: Vec<ReasoningStep>,
    /// 生成时间
    pub timestamp: String,
}
```

## 2. 有效性检查器

### 2.1 有效性检查器实现

```rust
/// 有效性检查器
#[derive(Debug)]
pub struct ValidityChecker {
    /// 检查规则
    rules: Vec<ValidityRule>,
}

/// 有效性规则
#[derive(Debug, Clone)]
pub struct ValidityRule {
    /// 规则名称
    pub name: String,
    /// 规则描述
    pub description: String,
    /// 检查函数
    pub checker: ValidityCheckFunction,
}

/// 有效性检查函数类型
#[derive(Debug, Clone)]
pub enum ValidityCheckFunction {
    LogicalConsistency,
    RuleApplication,
    PropositionValidity,
    StepSequence,
}

impl ValidityChecker {
    /// 创建新的检查器
    pub fn new() -> Self {
        let mut checker = Self {
            rules: Vec::new(),
        };
        
        // 添加默认检查规则
        checker.add_default_rules();
        
        checker
    }

    /// 添加默认规则
    fn add_default_rules(&mut self) {
        self.rules.push(ValidityRule {
            name: "逻辑一致性检查".to_string(),
            description: "检查推理链的逻辑一致性".to_string(),
            checker: ValidityCheckFunction::LogicalConsistency,
        });
        
        self.rules.push(ValidityRule {
            name: "规则应用检查".to_string(),
            description: "检查推理规则的正确应用".to_string(),
            checker: ValidityCheckFunction::RuleApplication,
        });
        
        self.rules.push(ValidityRule {
            name: "命题有效性检查".to_string(),
            description: "检查命题的有效性".to_string(),
            checker: ValidityCheckFunction::PropositionValidity,
        });
        
        self.rules.push(ValidityRule {
            name: "步骤序列检查".to_string(),
            description: "检查推理步骤的序列有效性".to_string(),
            checker: ValidityCheckFunction::StepSequence,
        });
    }

    /// 检查推理链有效性
    pub fn check_chain(&self, chain: &ReasoningChain) -> Result<ValidityResult, String> {
        let mut result = ValidityResult::new();
        
        for rule in &self.rules {
            match &rule.checker {
                ValidityCheckFunction::LogicalConsistency => {
                    self.check_logical_consistency(chain, &mut result);
                }
                ValidityCheckFunction::RuleApplication => {
                    self.check_rule_application(chain, &mut result);
                }
                ValidityCheckFunction::PropositionValidity => {
                    self.check_proposition_validity(chain, &mut result);
                }
                ValidityCheckFunction::StepSequence => {
                    self.check_step_sequence(chain, &mut result);
                }
            }
        }
        
        result.calculate_overall_validity();
        Ok(result)
    }

    /// 检查逻辑一致性
    fn check_logical_consistency(&self, chain: &ReasoningChain, result: &mut ValidityResult) {
        // 检查前提和结论的一致性
        let mut all_propositions = HashSet::new();
        
        // 收集所有命题
        for premise in &chain.premises {
            all_propositions.insert(premise.content.clone());
        }
        
        for step in &chain.steps {
            for prop in &step.input {
                all_propositions.insert(prop.content.clone());
            }
            all_propositions.insert(step.output.content.clone());
        }
        
        for conclusion in &chain.conclusions {
            all_propositions.insert(conclusion.content.clone());
        }
        
        // 检查是否存在矛盾
        let mut contradictions = Vec::new();
        for prop1 in &all_propositions {
            for prop2 in &all_propositions {
                if prop1 != prop2 {
                    if self.is_contradictory(prop1, prop2) {
                        contradictions.push(format!("{} 与 {} 矛盾", prop1, prop2));
                    }
                }
            }
        }
        
        if !contradictions.is_empty() {
            result.add_issue(ValidityIssue {
                issue_type: ValidityIssueType::LogicalContradiction,
                description: format!("发现逻辑矛盾: {}", contradictions.join(", ")),
                severity: IssueSeverity::Error,
                step_id: None,
            });
        }
    }

    /// 检查规则应用
    fn check_rule_application(&self, chain: &ReasoningChain, result: &mut ValidityResult) {
        for step in &chain.steps {
            // 检查推理规则是否正确应用
            if !self.is_rule_correctly_applied(&step.rule, &step.input, &step.output) {
                result.add_issue(ValidityIssue {
                    issue_type: ValidityIssueType::IncorrectRuleApplication,
                    description: format!("步骤 {} 的推理规则应用不正确", step.id),
                    severity: IssueSeverity::Error,
                    step_id: Some(step.id.clone()),
                });
            }
        }
    }

    /// 检查命题有效性
    fn check_proposition_validity(&self, chain: &ReasoningChain, result: &mut ValidityResult) {
        for step in &chain.steps {
            // 检查输入命题的有效性
            for prop in &step.input {
                if !self.is_proposition_valid(prop) {
                    result.add_issue(ValidityIssue {
                        issue_type: ValidityIssueType::InvalidProposition,
                        description: format!("命题 '{}' 无效", prop.content),
                        severity: IssueSeverity::Warning,
                        step_id: Some(step.id.clone()),
                    });
                }
            }
            
            // 检查输出命题的有效性
            if !self.is_proposition_valid(&step.output) {
                result.add_issue(ValidityIssue {
                    issue_type: ValidityIssueType::InvalidProposition,
                    description: format!("输出命题 '{}' 无效", step.output.content),
                    severity: IssueSeverity::Warning,
                    step_id: Some(step.id.clone()),
                });
            }
        }
    }

    /// 检查步骤序列
    fn check_step_sequence(&self, chain: &ReasoningChain, result: &mut ValidityResult) {
        // 检查步骤之间的依赖关系
        for i in 0..chain.steps.len() - 1 {
            let current_step = &chain.steps[i];
            let next_step = &chain.steps[i + 1];
            
            // 检查当前步骤的输出是否被下一步骤使用
            let mut output_used = false;
            for input_prop in &next_step.input {
                if input_prop.content == current_step.output.content {
                    output_used = true;
                    break;
                }
            }
            
            if !output_used {
                result.add_issue(ValidityIssue {
                    issue_type: ValidityIssueType::UnusedOutput,
                    description: format!("步骤 {} 的输出未被后续步骤使用", current_step.id),
                    severity: IssueSeverity::Warning,
                    step_id: Some(current_step.id.clone()),
                });
            }
        }
    }

    /// 检查是否矛盾
    fn is_contradictory(&self, prop1: &str, prop2: &str) -> bool {
        // 简化的矛盾检查
        // 在实际应用中，这里应该使用更复杂的逻辑分析
        prop1.contains("¬") && prop2.contains(&prop1.replace("¬", "")) ||
        prop2.contains("¬") && prop1.contains(&prop2.replace("¬", ""))
    }

    /// 检查规则是否正确应用
    fn is_rule_correctly_applied(&self, rule: &InferenceRule, input: &[Proposition], output: &Proposition) -> bool {
        // 简化的规则应用检查
        // 在实际应用中，这里应该使用更复杂的模式匹配
        match rule.rule_type {
            RuleType::ModusPonens => {
                input.len() == 2 && 
                input[0].content.contains("→") && 
                input[1].content == input[0].content.split("→").next().unwrap().trim()
            }
            RuleType::ModusTollens => {
                input.len() == 2 && 
                input[0].content.contains("→") && 
                input[1].content.starts_with("¬")
            }
            _ => true, // 其他规则暂时返回true
        }
    }

    /// 检查命题是否有效
    fn is_proposition_valid(&self, prop: &Proposition) -> bool {
        !prop.content.is_empty() && prop.confidence > 0.0
    }
}

/// 有效性结果
#[derive(Debug, Clone)]
pub struct ValidityResult {
    /// 有效性问题列表
    pub issues: Vec<ValidityIssue>,
    /// 总体有效性
    pub overall_validity: ValidityLevel,
    /// 有效性评分
    pub validity_score: f64,
}

/// 有效性级别
#[derive(Debug, Clone)]
pub enum ValidityLevel {
    Valid,      // 有效
    Invalid,    // 无效
    Partial,    // 部分有效
    Unknown,    // 未知
}

/// 有效性问题
#[derive(Debug, Clone)]
pub struct ValidityIssue {
    /// 问题类型
    pub issue_type: ValidityIssueType,
    /// 问题描述
    pub description: String,
    /// 严重程度
    pub severity: IssueSeverity,
    /// 相关步骤ID
    pub step_id: Option<String>,
}

/// 有效性问题类型
#[derive(Debug, Clone)]
pub enum ValidityIssueType {
    LogicalContradiction,      // 逻辑矛盾
    IncorrectRuleApplication,  // 规则应用错误
    InvalidProposition,        // 无效命题
    UnusedOutput,             // 未使用的输出
    MissingPremise,           // 缺失前提
    CircularReasoning,        // 循环推理
}

/// 问题严重程度
#[derive(Debug, Clone)]
pub enum IssueSeverity {
    Error,     // 错误
    Warning,   // 警告
    Info,      // 信息
}

impl ValidityResult {
    /// 创建新结果
    pub fn new() -> Self {
        Self {
            issues: Vec::new(),
            overall_validity: ValidityLevel::Unknown,
            validity_score: 0.0,
        }
    }

    /// 添加问题
    pub fn add_issue(&mut self, issue: ValidityIssue) {
        self.issues.push(issue);
    }

    /// 计算总体有效性
    pub fn calculate_overall_validity(&mut self) {
        if self.issues.is_empty() {
            self.overall_validity = ValidityLevel::Valid;
            self.validity_score = 1.0;
            return;
        }
        
        let error_count = self.issues.iter()
            .filter(|issue| matches!(issue.severity, IssueSeverity::Error))
            .count();
        
        let warning_count = self.issues.iter()
            .filter(|issue| matches!(issue.severity, IssueSeverity::Warning))
            .count();
        
        let total_issues = self.issues.len();
        
        if error_count > 0 {
            self.overall_validity = ValidityLevel::Invalid;
            self.validity_score = 0.0;
        } else if warning_count > 0 {
            self.overall_validity = ValidityLevel::Partial;
            self.validity_score = 0.5;
        } else {
            self.overall_validity = ValidityLevel::Valid;
            self.validity_score = 1.0;
        }
    }
}
```

## 3. 完整性分析器

### 3.1 完整性分析器实现

```rust
/// 完整性分析器
#[derive(Debug)]
pub struct CompletenessAnalyzer {
    /// 分析规则
    rules: Vec<CompletenessRule>,
}

/// 完整性规则
#[derive(Debug, Clone)]
pub struct CompletenessRule {
    /// 规则名称
    pub name: String,
    /// 规则描述
    pub description: String,
    /// 分析函数
    pub analyzer: CompletenessAnalysisFunction,
}

/// 完整性分析函数类型
#[derive(Debug, Clone)]
pub enum CompletenessAnalysisFunction {
    MissingSteps,
    GapAnalysis,
    DependencyCheck,
    CoverageAnalysis,
}

impl CompletenessAnalyzer {
    /// 创建新的分析器
    pub fn new() -> Self {
        let mut analyzer = Self {
            rules: Vec::new(),
        };
        
        // 添加默认分析规则
        analyzer.add_default_rules();
        
        analyzer
    }

    /// 添加默认规则
    fn add_default_rules(&mut self) {
        self.rules.push(CompletenessRule {
            name: "缺失步骤分析".to_string(),
            description: "分析推理链中缺失的步骤".to_string(),
            analyzer: CompletenessAnalysisFunction::MissingSteps,
        });
        
        self.rules.push(CompletenessRule {
            name: "间隙分析".to_string(),
            description: "分析推理链中的逻辑间隙".to_string(),
            analyzer: CompletenessAnalysisFunction::GapAnalysis,
        });
        
        self.rules.push(CompletenessRule {
            name: "依赖检查".to_string(),
            description: "检查推理步骤的依赖关系".to_string(),
            analyzer: CompletenessAnalysisFunction::DependencyCheck,
        });
        
        self.rules.push(CompletenessRule {
            name: "覆盖分析".to_string(),
            description: "分析推理链的覆盖范围".to_string(),
            analyzer: CompletenessAnalysisFunction::CoverageAnalysis,
        });
    }

    /// 分析推理链完整性
    pub fn analyze_chain(&self, chain: &ReasoningChain) -> Result<CompletenessReport, String> {
        let mut report = CompletenessReport::new();
        
        for rule in &self.rules {
            match &rule.analyzer {
                CompletenessAnalysisFunction::MissingSteps => {
                    self.analyze_missing_steps(chain, &mut report);
                }
                CompletenessAnalysisFunction::GapAnalysis => {
                    self.analyze_gaps(chain, &mut report);
                }
                CompletenessAnalysisFunction::DependencyCheck => {
                    self.check_dependencies(chain, &mut report);
                }
                CompletenessAnalysisFunction::CoverageAnalysis => {
                    self.analyze_coverage(chain, &mut report);
                }
            }
        }
        
        report.calculate_completeness_score();
        Ok(report)
    }

    /// 查找缺失步骤
    pub fn find_missing_steps(&self, chain: &ReasoningChain) -> Result<Vec<MissingStep>, String> {
        let mut missing_steps = Vec::new();
        
        // 分析步骤之间的间隙
        for i in 0..chain.steps.len() - 1 {
            let current_step = &chain.steps[i];
            let next_step = &chain.steps[i + 1];
            
            // 检查是否需要中间步骤
            if self.needs_intermediate_step(current_step, next_step) {
                missing_steps.push(MissingStep {
                    position: i + 1,
                    description: format!("在步骤 {} 和 {} 之间需要中间推理步骤", 
                        current_step.id, next_step.id),
                    suggested_rule: Some("hypothetical_syllogism".to_string()),
                    priority: 0.8,
                });
            }
        }
        
        // 检查从前提到第一个步骤的间隙
        if !chain.steps.is_empty() {
            let first_step = &chain.steps[0];
            if !self.premises_connect_to_step(&chain.premises, first_step) {
                missing_steps.push(MissingStep {
                    position: 0,
                    description: "需要从前提到第一个推理步骤的连接".to_string(),
                    suggested_rule: Some("modus_ponens".to_string()),
                    priority: 0.9,
                });
            }
        }
        
        // 检查从最后一个步骤到结论的间隙
        if !chain.steps.is_empty() {
            let last_step = &chain.steps[chain.steps.len() - 1];
            if !self.step_connects_to_conclusions(last_step, &chain.conclusions) {
                missing_steps.push(MissingStep {
                    position: chain.steps.len(),
                    description: "需要从最后一个推理步骤到结论的连接".to_string(),
                    suggested_rule: Some("simplification".to_string()),
                    priority: 0.9,
                });
            }
        }
        
        Ok(missing_steps)
    }

    /// 分析缺失步骤
    fn analyze_missing_steps(&self, chain: &ReasoningChain, report: &mut CompletenessReport) {
        if let Ok(missing_steps) = self.find_missing_steps(chain) {
            for step in missing_steps {
                report.add_issue(CompletenessIssue {
                    issue_type: CompletenessIssueType::MissingStep,
                    description: step.description,
                    severity: IssueSeverity::Warning,
                    position: step.position,
                    priority: step.priority,
                });
            }
        }
    }

    /// 分析间隙
    fn analyze_gaps(&self, chain: &ReasoningChain, report: &mut CompletenessReport) {
        // 检查推理链中的逻辑间隙
        for i in 0..chain.steps.len() - 1 {
            let current_step = &chain.steps[i];
            let next_step = &chain.steps[i + 1];
            
            if self.has_logical_gap(current_step, next_step) {
                report.add_issue(CompletenessIssue {
                    issue_type: CompletenessIssueType::LogicalGap,
                    description: format!("步骤 {} 和 {} 之间存在逻辑间隙", 
                        current_step.id, next_step.id),
                    severity: IssueSeverity::Warning,
                    position: i + 1,
                    priority: 0.7,
                });
            }
        }
    }

    /// 检查依赖关系
    fn check_dependencies(&self, chain: &ReasoningChain, report: &mut CompletenessReport) {
        // 检查推理步骤的依赖关系
        for (i, step) in chain.steps.iter().enumerate() {
            for input_prop in &step.input {
                if !self.proposition_is_available(input_prop, &chain.steps[..i]) {
                    report.add_issue(CompletenessIssue {
                        issue_type: CompletenessIssueType::MissingDependency,
                        description: format!("步骤 {} 的输入命题 '{}' 不可用", 
                            step.id, input_prop.content),
                        severity: IssueSeverity::Error,
                        position: i,
                        priority: 0.9,
                    });
                }
            }
        }
    }

    /// 分析覆盖范围
    fn analyze_coverage(&self, chain: &ReasoningChain, report: &mut CompletenessReport) {
        // 分析推理链的覆盖范围
        let total_premises = chain.premises.len();
        let used_premises = self.count_used_premises(chain);
        
        if used_premises < total_premises {
            report.add_issue(CompletenessIssue {
                issue_type: CompletenessIssueType::IncompleteCoverage,
                description: format!("推理链未使用所有前提，使用了 {}/{} 个前提", 
                    used_premises, total_premises),
                severity: IssueSeverity::Info,
                position: 0,
                priority: 0.5,
            });
        }
    }

    /// 检查是否需要中间步骤
    fn needs_intermediate_step(&self, step1: &ReasoningStep, step2: &ReasoningStep) -> bool {
        // 简化的中间步骤检查
        // 在实际应用中，这里应该使用更复杂的逻辑分析
        step1.output.content != step2.input[0].content
    }

    /// 检查前提是否连接到步骤
    fn premises_connect_to_step(&self, premises: &[Proposition], step: &ReasoningStep) -> bool {
        for premise in premises {
            for input_prop in &step.input {
                if premise.content == input_prop.content {
                    return true;
                }
            }
        }
        false
    }

    /// 检查步骤是否连接到结论
    fn step_connects_to_conclusions(&self, step: &ReasoningStep, conclusions: &[Proposition]) -> bool {
        for conclusion in conclusions {
            if step.output.content == conclusion.content {
                return true;
            }
        }
        false
    }

    /// 检查是否有逻辑间隙
    fn has_logical_gap(&self, step1: &ReasoningStep, step2: &ReasoningStep) -> bool {
        // 简化的逻辑间隙检查
        step1.output.content != step2.input[0].content
    }

    /// 检查命题是否可用
    fn proposition_is_available(&self, prop: &Proposition, previous_steps: &[ReasoningStep]) -> bool {
        for step in previous_steps {
            if step.output.content == prop.content {
                return true;
            }
        }
        false
    }

    /// 计算使用的前提数量
    fn count_used_premises(&self, chain: &ReasoningChain) -> usize {
        let mut used_count = 0;
        for premise in &chain.premises {
            for step in &chain.steps {
                for input_prop in &step.input {
                    if premise.content == input_prop.content {
                        used_count += 1;
                        break;
                    }
                }
            }
        }
        used_count
    }
}

/// 完整性报告
#[derive(Debug, Clone)]
pub struct CompletenessReport {
    /// 完整性问题列表
    pub issues: Vec<CompletenessIssue>,
    /// 完整性评分
    pub completeness_score: f64,
    /// 缺失步骤数量
    pub missing_steps_count: usize,
    /// 间隙数量
    pub gaps_count: usize,
}

/// 完整性问题
#[derive(Debug, Clone)]
pub struct CompletenessIssue {
    /// 问题类型
    pub issue_type: CompletenessIssueType,
    /// 问题描述
    pub description: String,
    /// 严重程度
    pub severity: IssueSeverity,
    /// 位置
    pub position: usize,
    /// 优先级
    pub priority: f64,
}

/// 完整性问题类型
#[derive(Debug, Clone)]
pub enum CompletenessIssueType {
    MissingStep,           // 缺失步骤
    LogicalGap,           // 逻辑间隙
    MissingDependency,    // 缺失依赖
    IncompleteCoverage,   // 不完整覆盖
    UnusedPremise,        // 未使用前提
}

impl CompletenessReport {
    /// 创建新报告
    pub fn new() -> Self {
        Self {
            issues: Vec::new(),
            completeness_score: 0.0,
            missing_steps_count: 0,
            gaps_count: 0,
        }
    }

    /// 添加问题
    pub fn add_issue(&mut self, issue: CompletenessIssue) {
        self.issues.push(issue.clone());
        
        match issue.issue_type {
            CompletenessIssueType::MissingStep => self.missing_steps_count += 1,
            CompletenessIssueType::LogicalGap => self.gaps_count += 1,
            _ => {}
        }
    }

    /// 计算完整性评分
    pub fn calculate_completeness_score(&mut self) {
        if self.issues.is_empty() {
            self.completeness_score = 1.0;
            return;
        }
        
        let total_issues = self.issues.len();
        let error_count = self.issues.iter()
            .filter(|issue| matches!(issue.severity, IssueSeverity::Error))
            .count();
        
        let warning_count = self.issues.iter()
            .filter(|issue| matches!(issue.severity, IssueSeverity::Warning))
            .count();
        
        // 计算评分：错误权重0.3，警告权重0.1
        let penalty = (error_count as f64 * 0.3) + (warning_count as f64 * 0.1);
        self.completeness_score = (1.0 - penalty).max(0.0);
    }
}
```

## 4. 使用示例

### 4.1 基本使用示例

```rust
fn main() -> Result<(), String> {
    // 创建推理链管理器
    let mut manager = ReasoningChainManager::new();
    
    // 创建推理链
    let chain = ReasoningChain {
        id: "chain_001".to_string(),
        name: "形式化方法推理链".to_string(),
        steps: vec![
            ReasoningStep {
                id: "step_001".to_string(),
                name: "前提1".to_string(),
                input: vec![
                    Proposition {
                        id: "p1".to_string(),
                        content: "P → Q".to_string(),
                        proposition_type: PropositionType::Axiom,
                        truth_value: Some(true),
                        source: "形式化方法定义".to_string(),
                        confidence: 0.95,
                    },
                    Proposition {
                        id: "p2".to_string(),
                        content: "P".to_string(),
                        proposition_type: PropositionType::Axiom,
                        truth_value: Some(true),
                        source: "系统假设".to_string(),
                        confidence: 0.90,
                    },
                ],
                output: Proposition {
                    id: "p3".to_string(),
                    content: "Q".to_string(),
                    proposition_type: PropositionType::Conclusion,
                    truth_value: Some(true),
                    source: "推理结果".to_string(),
                    confidence: 0.85,
                },
                rule: InferenceRule {
                    id: "modus_ponens".to_string(),
                    name: "假言推理".to_string(),
                    description: "如果P蕴含Q，且P为真，则Q为真".to_string(),
                    rule_type: RuleType::ModusPonens,
                    pattern: RulePattern {
                        premises: vec!["P → Q".to_string(), "P".to_string()],
                        conclusion: "Q".to_string(),
                        constraints: Vec::new(),
                    },
                    validity: RuleValidity::Valid,
                },
                justification: Justification {
                    justification_type: JustificationType::Logical,
                    content: "应用假言推理规则".to_string(),
                    source: "逻辑推理".to_string(),
                    strength: 0.95,
                    references: vec!["形式逻辑".to_string()],
                },
                order: 0,
                status: StepStatus::Valid,
            },
        ],
        premises: vec![
            Proposition {
                id: "premise_001".to_string(),
                content: "P → Q".to_string(),
                proposition_type: PropositionType::Axiom,
                truth_value: Some(true),
                source: "形式化方法定义".to_string(),
                confidence: 0.95,
            },
            Proposition {
                id: "premise_002".to_string(),
                content: "P".to_string(),
                proposition_type: PropositionType::Axiom,
                truth_value: Some(true),
                source: "系统假设".to_string(),
                confidence: 0.90,
            },
        ],
        conclusions: vec![
            Proposition {
                id: "conclusion_001".to_string(),
                content: "Q".to_string(),
                proposition_type: PropositionType::Conclusion,
                truth_value: Some(true),
                source: "推理结果".to_string(),
                confidence: 0.85,
            },
        ],
        inference_rules: vec![],
        description: "演示形式化方法的基本推理过程".to_string(),
        status: ReasoningStatus::Valid,
        metadata: HashMap::new(),
    };
    
    // 添加推理链
    manager.add_chain(chain)?;
    
    // 验证推理链有效性
    let validity_result = manager.validate_chain_validity("chain_001")?;
    println!("有效性评分: {:.2}", validity_result.validity_score);
    
    // 分析推理链完整性
    let completeness_report = manager.analyze_chain_completeness("chain_001")?;
    println!("完整性评分: {:.2}", completeness_report.completeness_score);
    
    // 查找缺失步骤
    let missing_steps = manager.find_missing_steps("chain_001")?;
    println!("缺失步骤数: {}", missing_steps.len());
    
    // 生成推理链报告
    let chain_report = manager.generate_chain_report("chain_001")?;
    println!("推理链报告:");
    println!("- 名称: {}", chain_report.chain_name);
    println!("- 有效性: {:?}", chain_report.validity_result.overall_validity);
    println!("- 完整性评分: {:.2}", chain_report.completeness_report.completeness_score);
    println!("- 步骤数: {}", chain_report.step_details.len());
    
    Ok(())
}
```

## 5. 总结

本文档实现了推理链完善工具，包括：

1. **推理链结构**：完整的推理链、步骤、命题、规则定义
2. **推理链管理器**：支持推理链的创建、验证、分析和报告生成
3. **有效性检查器**：多种有效性检查规则和问题识别
4. **完整性分析器**：缺失步骤识别、间隙分析、依赖检查
5. **使用示例**：展示如何创建和分析推理链

这个实现为项目的推理链完善工作提供了强大的工具支持，确保逻辑推理的完整性和正确性。
