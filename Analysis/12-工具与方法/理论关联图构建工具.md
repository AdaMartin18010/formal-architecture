# 理论关联图构建工具

## 概述

本文档实现了理论关联图构建工具，用于构建完整的理论关联图，建立理论间的系统关联关系。该工具支持理论节点、关联边、关系类型的管理，并提供关联分析和可视化功能。

## 1. 理论关联图结构

### 1.1 核心数据结构

```rust
use std::collections::{HashMap, HashSet};
use serde::{Deserialize, Serialize};

/// 理论节点
#[derive(Debug, Clone, Serialize, Deserialize, Hash, Eq, PartialEq)]
pub struct TheoryNode {
    /// 节点ID
    pub id: String,
    /// 理论名称
    pub name: String,
    /// 理论类别
    pub category: TheoryCategory,
    /// 理论描述
    pub description: String,
    /// 理论来源
    pub source: String,
    /// 理论状态
    pub status: TheoryStatus,
    /// 理论权重
    pub weight: f64,
    /// 相关概念
    pub concepts: Vec<String>,
    /// 元数据
    pub metadata: HashMap<String, String>,
}

/// 理论类别
#[derive(Debug, Clone, Serialize, Deserialize, Hash, Eq, PartialEq)]
pub enum TheoryCategory {
    FormalMethods,      // 形式化方法
    ProgrammingLanguage, // 编程语言
    SoftwareArchitecture, // 软件架构
    Concurrency,        // 并发理论
    Verification,       // 形式化验证
    Mathematics,        // 数学理论
    Philosophy,         // 哲学基础
    UnifiedTheory,      // 统一理论
    Other,              // 其他
}

/// 理论状态
#[derive(Debug, Clone, Serialize, Deserialize, Hash, Eq, PartialEq)]
pub enum TheoryStatus {
    Active,         // 活跃
    Inactive,       // 非活跃
    Deprecated,     // 已废弃
    Experimental,   // 实验性
    Standard,       // 标准
}

/// 理论关联边
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TheoryEdge {
    /// 边ID
    pub id: String,
    /// 源节点ID
    pub source_id: String,
    /// 目标节点ID
    pub target_id: String,
    /// 关系类型
    pub relationship_type: RelationshipType,
    /// 关系强度 (0.0-1.0)
    pub strength: f64,
    /// 关系描述
    pub description: String,
    /// 关系证据
    pub evidence: Vec<String>,
    /// 关系方向
    pub direction: EdgeDirection,
    /// 元数据
    pub metadata: HashMap<String, String>,
}

/// 关系类型
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum RelationshipType {
    Implies,        // 蕴含
    Equivalent,     // 等价
    Generalizes,    // 泛化
    Specializes,    // 特化
    Complements,    // 补充
    Conflicts,      // 冲突
    Extends,        // 扩展
    Implements,     // 实现
    Unifies,        // 统一
    Related,        // 相关
}

/// 边方向
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum EdgeDirection {
    Directed,       // 有向
    Undirected,     // 无向
    Bidirectional,  // 双向
}

/// 理论关联图
#[derive(Debug, Clone)]
pub struct TheoryGraph {
    /// 节点集合
    nodes: HashMap<String, TheoryNode>,
    /// 边集合
    edges: HashMap<String, TheoryEdge>,
    /// 邻接表
    adjacency_list: HashMap<String, Vec<String>>,
    /// 反向邻接表
    reverse_adjacency_list: HashMap<String, Vec<String>>,
    /// 图元数据
    metadata: GraphMetadata,
}

/// 图元数据
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GraphMetadata {
    /// 图名称
    pub name: String,
    /// 图描述
    pub description: String,
    /// 创建时间
    pub created_at: String,
    /// 最后更新时间
    pub updated_at: String,
    /// 版本
    pub version: String,
    /// 统计信息
    pub statistics: GraphStatistics,
}

/// 图统计信息
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GraphStatistics {
    /// 节点总数
    pub node_count: usize,
    /// 边总数
    pub edge_count: usize,
    /// 连通分量数
    pub connected_components: usize,
    /// 平均度
    pub average_degree: f64,
    /// 最大度
    pub max_degree: usize,
    /// 密度
    pub density: f64,
}
```

### 1.2 理论关联图管理器

```rust
impl TheoryGraph {
    /// 创建新的理论关联图
    pub fn new(name: String, description: String) -> Self {
        Self {
            nodes: HashMap::new(),
            edges: HashMap::new(),
            adjacency_list: HashMap::new(),
            reverse_adjacency_list: HashMap::new(),
            metadata: GraphMetadata {
                name,
                description,
                created_at: chrono::Utc::now().to_rfc3339(),
                updated_at: chrono::Utc::now().to_rfc3339(),
                version: "1.0.0".to_string(),
                statistics: GraphStatistics {
                    node_count: 0,
                    edge_count: 0,
                    connected_components: 0,
                    average_degree: 0.0,
                    max_degree: 0,
                    density: 0.0,
                },
            },
        }
    }

    /// 添加理论节点
    pub fn add_node(&mut self, node: TheoryNode) -> Result<(), String> {
        // 验证节点
        self.validate_node(&node)?;
        
        // 添加到节点集合
        self.nodes.insert(node.id.clone(), node.clone());
        
        // 初始化邻接表
        self.adjacency_list.insert(node.id.clone(), Vec::new());
        self.reverse_adjacency_list.insert(node.id.clone(), Vec::new());
        
        // 更新统计信息
        self.update_statistics();
        
        Ok(())
    }

    /// 添加理论关联边
    pub fn add_edge(&mut self, edge: TheoryEdge) -> Result<(), String> {
        // 验证边
        self.validate_edge(&edge)?;
        
        // 添加到边集合
        self.edges.insert(edge.id.clone(), edge.clone());
        
        // 更新邻接表
        self.adjacency_list
            .entry(edge.source_id.clone())
            .or_insert_with(Vec::new)
            .push(edge.target_id.clone());
        
        // 更新反向邻接表
        self.reverse_adjacency_list
            .entry(edge.target_id.clone())
            .or_insert_with(Vec::new)
            .push(edge.source_id.clone());
        
        // 如果是双向边，添加反向边
        if matches!(edge.direction, EdgeDirection::Bidirectional) {
            self.reverse_adjacency_list
                .entry(edge.source_id.clone())
                .or_insert_with(Vec::new)
                .push(edge.target_id.clone());
        }
        
        // 更新统计信息
        self.update_statistics();
        
        Ok(())
    }

    /// 验证节点
    fn validate_node(&self, node: &TheoryNode) -> Result<(), String> {
        if node.id.is_empty() {
            return Err("节点ID不能为空".to_string());
        }
        
        if node.name.is_empty() {
            return Err("节点名称不能为空".to_string());
        }
        
        if node.weight < 0.0 || node.weight > 1.0 {
            return Err("节点权重必须在0.0到1.0之间".to_string());
        }
        
        if self.nodes.contains_key(&node.id) {
            return Err(format!("节点ID '{}' 已存在", node.id));
        }
        
        Ok(())
    }

    /// 验证边
    fn validate_edge(&self, edge: &TheoryEdge) -> Result<(), String> {
        if edge.id.is_empty() {
            return Err("边ID不能为空".to_string());
        }
        
        if edge.source_id.is_empty() || edge.target_id.is_empty() {
            return Err("源节点ID和目标节点ID不能为空".to_string());
        }
        
        if !self.nodes.contains_key(&edge.source_id) {
            return Err(format!("源节点 '{}' 不存在", edge.source_id));
        }
        
        if !self.nodes.contains_key(&edge.target_id) {
            return Err(format!("目标节点 '{}' 不存在", edge.target_id));
        }
        
        if edge.strength < 0.0 || edge.strength > 1.0 {
            return Err("边强度必须在0.0到1.0之间".to_string());
        }
        
        if self.edges.contains_key(&edge.id) {
            return Err(format!("边ID '{}' 已存在", edge.id));
        }
        
        Ok(())
    }

    /// 获取节点
    pub fn get_node(&self, node_id: &str) -> Option<&TheoryNode> {
        self.nodes.get(node_id)
    }

    /// 获取边
    pub fn get_edge(&self, edge_id: &str) -> Option<&TheoryEdge> {
        self.edges.get(edge_id)
    }

    /// 获取节点的邻居
    pub fn get_neighbors(&self, node_id: &str) -> Vec<&TheoryNode> {
        if let Some(neighbor_ids) = self.adjacency_list.get(node_id) {
            neighbor_ids
                .iter()
                .filter_map(|id| self.nodes.get(id))
                .collect()
        } else {
            Vec::new()
        }
    }

    /// 获取节点的入边
    pub fn get_incoming_edges(&self, node_id: &str) -> Vec<&TheoryEdge> {
        if let Some(neighbor_ids) = self.reverse_adjacency_list.get(node_id) {
            neighbor_ids
                .iter()
                .filter_map(|id| {
                    self.edges.values().find(|edge| {
                        edge.source_id == *id && edge.target_id == node_id
                    })
                })
                .collect()
        } else {
            Vec::new()
        }
    }

    /// 获取节点的出边
    pub fn get_outgoing_edges(&self, node_id: &str) -> Vec<&TheoryEdge> {
        if let Some(neighbor_ids) = self.adjacency_list.get(node_id) {
            neighbor_ids
                .iter()
                .filter_map(|id| {
                    self.edges.values().find(|edge| {
                        edge.source_id == node_id && edge.target_id == *id
                    })
                })
                .collect()
        } else {
            Vec::new()
        }
    }

    /// 查找路径
    pub fn find_path(&self, source_id: &str, target_id: &str) -> Option<Vec<String>> {
        if !self.nodes.contains_key(source_id) || !self.nodes.contains_key(target_id) {
            return None;
        }
        
        let mut visited = HashSet::new();
        let mut queue = std::collections::VecDeque::new();
        let mut parent = HashMap::new();
        
        queue.push_back(source_id.to_string());
        visited.insert(source_id.to_string());
        
        while let Some(current) = queue.pop_front() {
            if current == target_id {
                // 重建路径
                let mut path = Vec::new();
                let mut current_id = target_id;
                
                while current_id != source_id {
                    path.push(current_id.to_string());
                    current_id = parent.get(current_id).unwrap();
                }
                path.push(source_id.to_string());
                path.reverse();
                return Some(path);
            }
            
            if let Some(neighbors) = self.adjacency_list.get(&current) {
                for neighbor in neighbors {
                    if !visited.contains(neighbor) {
                        visited.insert(neighbor.clone());
                        parent.insert(neighbor.clone(), current.clone());
                        queue.push_back(neighbor.clone());
                    }
                }
            }
        }
        
        None
    }

    /// 计算连通分量
    pub fn find_connected_components(&self) -> Vec<Vec<String>> {
        let mut visited = HashSet::new();
        let mut components = Vec::new();
        
        for node_id in self.nodes.keys() {
            if !visited.contains(node_id) {
                let mut component = Vec::new();
                self.dfs_component(node_id, &mut visited, &mut component);
                components.push(component);
            }
        }
        
        components
    }

    /// DFS查找连通分量
    fn dfs_component(&self, node_id: &str, visited: &mut HashSet<String>, component: &mut Vec<String>) {
        visited.insert(node_id.to_string());
        component.push(node_id.to_string());
        
        if let Some(neighbors) = self.adjacency_list.get(node_id) {
            for neighbor in neighbors {
                if !visited.contains(neighbor) {
                    self.dfs_component(neighbor, visited, component);
                }
            }
        }
    }

    /// 更新统计信息
    fn update_statistics(&mut self) {
        let node_count = self.nodes.len();
        let edge_count = self.edges.len();
        
        // 计算平均度和最大度
        let mut total_degree = 0;
        let mut max_degree = 0;
        
        for node_id in self.nodes.keys() {
            let degree = self.adjacency_list.get(node_id).map_or(0, |neighbors| neighbors.len());
            total_degree += degree;
            max_degree = max_degree.max(degree);
        }
        
        let average_degree = if node_count > 0 {
            total_degree as f64 / node_count as f64
        } else {
            0.0
        };
        
        // 计算密度
        let density = if node_count > 1 {
            edge_count as f64 / (node_count * (node_count - 1)) as f64
        } else {
            0.0
        };
        
        // 计算连通分量数
        let connected_components = self.find_connected_components().len();
        
        self.metadata.statistics = GraphStatistics {
            node_count,
            edge_count,
            connected_components,
            average_degree,
            max_degree,
            density,
        };
        
        self.metadata.updated_at = chrono::Utc::now().to_rfc3339();
    }

    /// 获取统计信息
    pub fn get_statistics(&self) -> &GraphStatistics {
        &self.metadata.statistics
    }

    /// 按类别查找节点
    pub fn find_nodes_by_category(&self, category: &TheoryCategory) -> Vec<&TheoryNode> {
        self.nodes.values()
            .filter(|node| &node.category == category)
            .collect()
    }

    /// 按状态查找节点
    pub fn find_nodes_by_status(&self, status: &TheoryStatus) -> Vec<&TheoryNode> {
        self.nodes.values()
            .filter(|node| &node.status == status)
            .collect()
    }

    /// 按关系类型查找边
    pub fn find_edges_by_relationship_type(&self, relationship_type: &RelationshipType) -> Vec<&TheoryEdge> {
        self.edges.values()
            .filter(|edge| &edge.relationship_type == relationship_type)
            .collect()
    }

    /// 搜索节点
    pub fn search_nodes(&self, query: &str) -> Vec<&TheoryNode> {
        let query_lower = query.to_lowercase();
        self.nodes.values()
            .filter(|node| {
                node.name.to_lowercase().contains(&query_lower) ||
                node.description.to_lowercase().contains(&query_lower) ||
                node.concepts.iter().any(|concept| concept.to_lowercase().contains(&query_lower))
            })
            .collect()
    }

    /// 生成图报告
    pub fn generate_graph_report(&self) -> GraphReport {
        let mut report = GraphReport::new();
        
        // 添加基本统计信息
        report.add_section("基本统计", format!(
            "节点数: {}\n边数: {}\n连通分量数: {}\n平均度: {:.2}\n最大度: {}\n密度: {:.4}",
            self.metadata.statistics.node_count,
            self.metadata.statistics.edge_count,
            self.metadata.statistics.connected_components,
            self.metadata.statistics.average_degree,
            self.metadata.statistics.max_degree,
            self.metadata.statistics.density,
        ));
        
        // 按类别统计节点
        let mut category_stats = HashMap::new();
        for node in self.nodes.values() {
            *category_stats.entry(&node.category).or_insert(0) += 1;
        }
        
        let mut category_section = "节点类别分布:\n".to_string();
        for (category, count) in category_stats {
            category_section.push_str(&format!("- {:?}: {}\n", category, count));
        }
        report.add_section("类别分布", category_section);
        
        // 按关系类型统计边
        let mut relationship_stats = HashMap::new();
        for edge in self.edges.values() {
            *relationship_stats.entry(&edge.relationship_type).or_insert(0) += 1;
        }
        
        let mut relationship_section = "关系类型分布:\n".to_string();
        for (relationship, count) in relationship_stats {
            relationship_section.push_str(&format!("- {:?}: {}\n", relationship, count));
        }
        report.add_section("关系分布", relationship_section);
        
        // 连通分量分析
        let components = self.find_connected_components();
        let mut component_section = format!("连通分量分析 (共{}个):\n", components.len());
        for (i, component) in components.iter().enumerate() {
            component_section.push_str(&format!("- 分量{}: {}个节点\n", i + 1, component.len()));
        }
        report.add_section("连通分量", component_section);
        
        report
    }
}

/// 图报告
#[derive(Debug)]
pub struct GraphReport {
    /// 报告时间
    pub timestamp: String,
    /// 报告章节
    pub sections: Vec<ReportSection>,
}

/// 报告章节
#[derive(Debug, Clone)]
pub struct ReportSection {
    /// 章节标题
    pub title: String,
    /// 章节内容
    pub content: String,
}

impl GraphReport {
    /// 创建新报告
    pub fn new() -> Self {
        Self {
            timestamp: chrono::Utc::now().to_rfc3339(),
            sections: Vec::new(),
        }
    }

    /// 添加章节
    pub fn add_section(&mut self, title: String, content: String) {
        self.sections.push(ReportSection { title, content });
    }

    /// 生成报告文本
    pub fn generate_text(&self) -> String {
        let mut report = format!("理论关联图报告\n生成时间: {}\n\n", self.timestamp);
        
        for section in &self.sections {
            report.push_str(&format!("## {}\n{}\n\n", section.title, section.content));
        }
        
        report
    }
}
```

## 2. 使用示例

### 2.1 基本使用示例

```rust
fn main() -> Result<(), String> {
    // 创建理论关联图
    let mut graph = TheoryGraph::new(
        "形式化架构理论关联图".to_string(),
        "描述形式化架构理论之间的关联关系".to_string(),
    );
    
    // 添加理论节点
    let formal_methods = TheoryNode {
        id: "fm".to_string(),
        name: "形式化方法".to_string(),
        category: TheoryCategory::FormalMethods,
        description: "基于数学的技术，用于软件和硬件系统的规范、开发和验证".to_string(),
        source: "Wikipedia".to_string(),
        status: TheoryStatus::Standard,
        weight: 0.95,
        concepts: vec!["形式化规范".to_string(), "形式化验证".to_string()],
        metadata: HashMap::new(),
    };
    
    let model_checking = TheoryNode {
        id: "mc".to_string(),
        name: "模型检查".to_string(),
        category: TheoryCategory::FormalMethods,
        description: "自动验证有限状态系统是否满足给定规范的方法".to_string(),
        source: "SPIN Model Checker".to_string(),
        status: TheoryStatus::Active,
        weight: 0.90,
        concepts: vec!["状态机".to_string(), "时态逻辑".to_string()],
        metadata: HashMap::new(),
    };
    
    let theorem_proving = TheoryNode {
        id: "tp".to_string(),
        name: "定理证明".to_string(),
        category: TheoryCategory::FormalMethods,
        description: "使用形式逻辑证明陈述为真的过程".to_string(),
        source: "Coq Proof Assistant".to_string(),
        status: TheoryStatus::Active,
        weight: 0.90,
        concepts: vec!["逻辑证明".to_string(), "形式逻辑".to_string()],
        metadata: HashMap::new(),
    };
    
    // 添加节点到图
    graph.add_node(formal_methods)?;
    graph.add_node(model_checking)?;
    graph.add_node(theorem_proving)?;
    
    // 添加关联边
    let edge1 = TheoryEdge {
        id: "fm-mc".to_string(),
        source_id: "fm".to_string(),
        target_id: "mc".to_string(),
        relationship_type: RelationshipType::Implements,
        strength: 0.85,
        description: "形式化方法通过模型检查实现验证".to_string(),
        evidence: vec!["SPIN Model Checker".to_string()],
        direction: EdgeDirection::Directed,
        metadata: HashMap::new(),
    };
    
    let edge2 = TheoryEdge {
        id: "fm-tp".to_string(),
        source_id: "fm".to_string(),
        target_id: "tp".to_string(),
        relationship_type: RelationshipType::Implements,
        strength: 0.85,
        description: "形式化方法通过定理证明实现验证".to_string(),
        evidence: vec!["Coq Proof Assistant".to_string()],
        direction: EdgeDirection::Directed,
        metadata: HashMap::new(),
    };
    
    let edge3 = TheoryEdge {
        id: "mc-tp".to_string(),
        source_id: "mc".to_string(),
        target_id: "tp".to_string(),
        relationship_type: RelationshipType::Complements,
        strength: 0.75,
        description: "模型检查和定理证明相互补充".to_string(),
        evidence: vec!["Formal Verification Methods".to_string()],
        direction: EdgeDirection::Undirected,
        metadata: HashMap::new(),
    };
    
    // 添加边到图
    graph.add_edge(edge1)?;
    graph.add_edge(edge2)?;
    graph.add_edge(edge3)?;
    
    // 生成图报告
    let report = graph.generate_graph_report();
    println!("{}", report.generate_text());
    
    // 查找路径
    if let Some(path) = graph.find_path("fm", "tp") {
        println!("从形式化方法到定理证明的路径: {:?}", path);
    }
    
    // 查找连通分量
    let components = graph.find_connected_components();
    println!("连通分量数: {}", components.len());
    
    // 搜索节点
    let search_results = graph.search_nodes("验证");
    println!("包含'验证'的节点数: {}", search_results.len());
    
    Ok(())
}
```

## 3. 总结

本文档实现了理论关联图构建工具，包括：

1. **理论关联图结构**：完整的节点、边、关系类型定义
2. **图管理器**：支持图的构建、查询、分析和报告生成
3. **路径查找**：支持节点间路径查找和连通分量分析
4. **统计功能**：提供详细的图统计信息和分析报告
5. **使用示例**：展示如何构建和分析理论关联图

这个实现为项目的理论关联完善工作提供了强大的工具支持，确保理论间关系的系统性和完整性。
