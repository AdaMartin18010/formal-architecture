# 主题索引

## 主题索引概述

主题索引是形式化架构理论项目的主题组织系统，通过系统性的主题分类和关联，为用户提供基于主题的内容查找和导航支持。

### 索引结构

- **理论主题**: 哲学、数学、形式语言等理论主题
- **应用主题**: 软件架构、编程语言、形式模型等应用主题
- **工具主题**: 开发工具、验证工具、设计工具等工具主题

## 理论主题索引

### 1. 哲学理论主题

```rust
// 哲学主题索引器
pub struct PhilosophyTopicIndexer {
    ontology_topics: HashMap<String, TopicEntry>,
    epistemology_topics: HashMap<String, TopicEntry>,
    logic_topics: HashMap<String, TopicEntry>,
}

impl PhilosophyTopicIndexer {
    pub fn new() -> Self {
        let mut ontology_topics = HashMap::new();
        
        // 本体论主题
        ontology_topics.insert("存在论".to_string(), TopicEntry {
            topic: "存在论".to_string(),
            description: "研究存在的基本性质和规律".to_string(),
            documents: vec![
                "01-哲学基础理论/01-本体论基础".to_string(),
                "01-哲学基础理论/00-哲学基础理论总论".to_string(),
            ],
            related_topics: vec!["实体论".to_string(), "属性论".to_string()],
            keywords: vec!["存在".to_string(), "实体".to_string(), "属性".to_string()],
        });
        
        ontology_topics.insert("实体论".to_string(), TopicEntry {
            topic: "实体论".to_string(),
            description: "研究实体的本质和分类".to_string(),
            documents: vec![
                "01-哲学基础理论/01-本体论基础".to_string(),
            ],
            related_topics: vec!["存在论".to_string(), "关系论".to_string()],
            keywords: vec!["实体".to_string(), "本质".to_string(), "分类".to_string()],
        });
        
        let mut epistemology_topics = HashMap::new();
        
        // 认识论主题
        epistemology_topics.insert("知识论".to_string(), TopicEntry {
            topic: "知识论".to_string(),
            description: "研究知识的本质、来源和有效性".to_string(),
            documents: vec![
                "01-哲学基础理论/02-认识论基础".to_string(),
            ],
            related_topics: vec!["真理论".to_string(), "方法论".to_string()],
            keywords: vec!["知识".to_string(), "真理".to_string(), "验证".to_string()],
        });
        
        epistemology_topics.insert("方法论".to_string(), TopicEntry {
            topic: "方法论".to_string(),
            description: "研究获得知识的方法和途径".to_string(),
            documents: vec![
                "01-哲学基础理论/02-认识论基础".to_string(),
            ],
            related_topics: vec!["知识论".to_string(), "逻辑学".to_string()],
            keywords: vec!["方法".to_string(), "推理".to_string(), "证明".to_string()],
        });
        
        let mut logic_topics = HashMap::new();
        
        // 逻辑学主题
        logic_topics.insert("形式逻辑".to_string(), TopicEntry {
            topic: "形式逻辑".to_string(),
            description: "研究推理的形式结构和有效性".to_string(),
            documents: vec![
                "01-哲学基础理论/03-逻辑学基础".to_string(),
            ],
            related_topics: vec!["数理逻辑".to_string(), "模态逻辑".to_string()],
            keywords: vec!["推理".to_string(), "有效性".to_string(), "形式".to_string()],
        });
        
        logic_topics.insert("数理逻辑".to_string(), TopicEntry {
            topic: "数理逻辑".to_string(),
            description: "用数学方法研究逻辑问题".to_string(),
            documents: vec![
                "01-哲学基础理论/03-逻辑学基础".to_string(),
            ],
            related_topics: vec!["形式逻辑".to_string(), "集合论".to_string()],
            keywords: vec!["数学".to_string(), "逻辑".to_string(), "形式化".to_string()],
        });
        
        Self {
            ontology_topics,
            epistemology_topics,
            logic_topics,
        }
    }
    
    pub fn search_topic(&self, query: &str) -> Option<TopicEntry> {
        self.ontology_topics.get(query)
            .or_else(|| self.epistemology_topics.get(query))
            .or_else(|| self.logic_topics.get(query))
            .cloned()
    }
    
    pub fn find_related_topics(&self, topic: &str) -> Vec<TopicEntry> {
        let mut related = Vec::new();
        
        if let Some(topic_entry) = self.search_topic(topic) {
            for related_topic in &topic_entry.related_topics {
                if let Some(related_entry) = self.search_topic(related_topic) {
                    related.push(related_entry);
                }
            }
        }
        
        related
    }
}
```

### 2. 数学理论主题

```rust
// 数学主题索引器
pub struct MathematicsTopicIndexer {
    set_theory_topics: HashMap<String, TopicEntry>,
    algebra_topics: HashMap<String, TopicEntry>,
    analysis_topics: HashMap<String, TopicEntry>,
}

impl MathematicsTopicIndexer {
    pub fn new() -> Self {
        let mut set_theory_topics = HashMap::new();
        
        // 集合论主题
        set_theory_topics.insert("集合论基础".to_string(), TopicEntry {
            topic: "集合论基础".to_string(),
            description: "研究集合的基本概念和运算".to_string(),
            documents: vec![
                "02-数学理论体系/01-集合论基础".to_string(),
                "02-数学理论体系/00-数学理论体系总论".to_string(),
            ],
            related_topics: vec!["关系论".to_string(), "函数论".to_string()],
            keywords: vec!["集合".to_string(), "元素".to_string(), "运算".to_string()],
        });
        
        set_theory_topics.insert("关系论".to_string(), TopicEntry {
            topic: "关系论".to_string(),
            description: "研究集合间的关系和性质".to_string(),
            documents: vec![
                "02-数学理论体系/01-集合论基础".to_string(),
            ],
            related_topics: vec!["集合论基础".to_string(), "函数论".to_string()],
            keywords: vec!["关系".to_string(), "等价关系".to_string(), "序关系".to_string()],
        });
        
        let mut algebra_topics = HashMap::new();
        
        // 代数主题
        algebra_topics.insert("群论".to_string(), TopicEntry {
            topic: "群论".to_string(),
            description: "研究群的结构和性质".to_string(),
            documents: vec![
                "02-数学理论体系/02-代数理论".to_string(),
            ],
            related_topics: vec!["环论".to_string(), "域论".to_string()],
            keywords: vec!["群".to_string(), "运算".to_string(), "同构".to_string()],
        });
        
        algebra_topics.insert("环论".to_string(), TopicEntry {
            topic: "环论".to_string(),
            description: "研究环的结构和性质".to_string(),
            documents: vec![
                "02-数学理论体系/02-代数理论".to_string(),
            ],
            related_topics: vec!["群论".to_string(), "域论".to_string()],
            keywords: vec!["环".to_string(), "理想".to_string(), "同态".to_string()],
        });
        
        let mut analysis_topics = HashMap::new();
        
        // 分析主题
        analysis_topics.insert("实分析".to_string(), TopicEntry {
            topic: "实分析".to_string(),
            description: "研究实数函数的性质".to_string(),
            documents: vec![
                "02-数学理论体系/04-分析理论".to_string(),
            ],
            related_topics: vec!["复分析".to_string(), "泛函分析".to_string()],
            keywords: vec!["极限".to_string(), "连续性".to_string(), "可微性".to_string()],
        });
        
        analysis_topics.insert("泛函分析".to_string(), TopicEntry {
            topic: "泛函分析".to_string(),
            description: "研究函数空间和算子理论".to_string(),
            documents: vec![
                "02-数学理论体系/04-分析理论".to_string(),
            ],
            related_topics: vec!["实分析".to_string(), "算子论".to_string()],
            keywords: vec!["函数空间".to_string(), "算子".to_string(), "范数".to_string()],
        });
        
        Self {
            set_theory_topics,
            algebra_topics,
            analysis_topics,
        }
    }
}
```

## 应用主题索引

### 1. 软件架构主题

```rust
// 软件架构主题索引器
pub struct ArchitectureTopicIndexer {
    pattern_topics: HashMap<String, TopicEntry>,
    service_topics: HashMap<String, TopicEntry>,
    component_topics: HashMap<String, TopicEntry>,
}

impl ArchitectureTopicIndexer {
    pub fn new() -> Self {
        let mut pattern_topics = HashMap::new();
        
        // 设计模式主题
        pattern_topics.insert("设计模式".to_string(), TopicEntry {
            topic: "设计模式".to_string(),
            description: "软件设计中常见问题的标准解决方案".to_string(),
            documents: vec![
                "04-软件架构理论/01-设计模式理论".to_string(),
                "04-软件架构理论/00-软件架构理论总论".to_string(),
            ],
            related_topics: vec!["创建型模式".to_string(), "结构型模式".to_string(), "行为型模式".to_string()],
            keywords: vec!["模式".to_string(), "设计".to_string(), "解决方案".to_string()],
        });
        
        pattern_topics.insert("微服务架构".to_string(), TopicEntry {
            topic: "微服务架构".to_string(),
            description: "将应用程序分解为小型、独立的服务单元".to_string(),
            documents: vec![
                "04-软件架构理论/02-微服务架构理论".to_string(),
            ],
            related_topics: vec!["服务网格".to_string(), "容器化".to_string()],
            keywords: vec!["微服务".to_string(), "分布式".to_string(), "服务".to_string()],
        });
        
        let mut service_topics = HashMap::new();
        
        // 服务主题
        service_topics.insert("服务治理".to_string(), TopicEntry {
            topic: "服务治理".to_string(),
            description: "管理和协调分布式服务的机制".to_string(),
            documents: vec![
                "04-软件架构理论/02-微服务架构理论".to_string(),
            ],
            related_topics: vec!["服务发现".to_string(), "负载均衡".to_string()],
            keywords: vec!["治理".to_string(), "管理".to_string(), "协调".to_string()],
        });
        
        service_topics.insert("事件驱动架构".to_string(), TopicEntry {
            topic: "事件驱动架构".to_string(),
            description: "基于事件的生产、检测、消费和反应的架构模式".to_string(),
            documents: vec![
                "04-软件架构理论/02-微服务架构理论".to_string(),
            ],
            related_topics: vec!["消息队列".to_string(), "发布订阅".to_string()],
            keywords: vec!["事件".to_string(), "驱动".to_string(), "异步".to_string()],
        });
        
        let mut component_topics = HashMap::new();
        
        // 组件主题
        component_topics.insert("组件化设计".to_string(), TopicEntry {
            topic: "组件化设计".to_string(),
            description: "将系统分解为可重用组件的设计方法".to_string(),
            documents: vec![
                "04-软件架构理论/03-组件化架构理论".to_string(),
            ],
            related_topics: vec!["模块化".to_string(), "依赖注入".to_string()],
            keywords: vec!["组件".to_string(), "重用".to_string(), "模块".to_string()],
        });
        
        component_topics.insert("云原生架构".to_string(), TopicEntry {
            topic: "云原生架构".to_string(),
            description: "专为云环境设计的应用程序架构".to_string(),
            documents: vec![
                "04-软件架构理论/04-云原生架构理论".to_string(),
            ],
            related_topics: vec!["容器化".to_string(), "微服务".to_string()],
            keywords: vec!["云原生".to_string(), "容器".to_string(), "编排".to_string()],
        });
        
        Self {
            pattern_topics,
            service_topics,
            component_topics,
        }
    }
}
```

### 2. 形式模型主题

```rust
// 形式模型主题索引器
pub struct FormalModelTopicIndexer {
    petri_topics: HashMap<String, TopicEntry>,
    control_topics: HashMap<String, TopicEntry>,
    state_topics: HashMap<String, TopicEntry>,
}

impl FormalModelTopicIndexer {
    pub fn new() -> Self {
        let mut petri_topics = HashMap::new();
        
        // Petri网主题
        petri_topics.insert("Petri网理论".to_string(), TopicEntry {
            topic: "Petri网理论".to_string(),
            description: "用于建模并发系统的数学工具".to_string(),
            documents: vec![
                "06-形式模型理论/01-Petri网理论".to_string(),
                "06-形式模型理论/00-形式模型理论总论".to_string(),
            ],
            related_topics: vec!["库所".to_string(), "变迁".to_string(), "标记".to_string()],
            keywords: vec!["Petri网".to_string(), "并发".to_string(), "建模".to_string()],
        });
        
        petri_topics.insert("工作流Petri网".to_string(), TopicEntry {
            topic: "工作流Petri网".to_string(),
            description: "用于建模工作流程的Petri网变体".to_string(),
            documents: vec![
                "06-形式模型理论/01-Petri网理论".to_string(),
            ],
            related_topics: vec!["Petri网理论".to_string(), "工作流".to_string()],
            keywords: vec!["工作流".to_string(), "流程".to_string(), "建模".to_string()],
        });
        
        let mut control_topics = HashMap::new();
        
        // 控制理论主题
        control_topics.insert("控制理论".to_string(), TopicEntry {
            topic: "控制理论".to_string(),
            description: "研究系统控制和调节的理论".to_string(),
            documents: vec![
                "06-形式模型理论/02-控制理论".to_string(),
            ],
            related_topics: vec!["状态空间".to_string(), "可达性".to_string()],
            keywords: vec!["控制".to_string(), "系统".to_string(), "调节".to_string()],
        });
        
        control_topics.insert("可达性分析".to_string(), TopicEntry {
            topic: "可达性分析".to_string(),
            description: "分析系统状态可达性的方法".to_string(),
            documents: vec![
                "06-形式模型理论/02-控制理论".to_string(),
            ],
            related_topics: vec!["控制理论".to_string(), "状态空间".to_string()],
            keywords: vec!["可达性".to_string(), "分析".to_string(), "状态".to_string()],
        });
        
        let mut state_topics = HashMap::new();
        
        // 状态机主题
        state_topics.insert("状态机理论".to_string(), TopicEntry {
            topic: "状态机理论".to_string(),
            description: "研究状态转换系统的理论".to_string(),
            documents: vec![
                "06-形式模型理论/03-状态机理论".to_string(),
            ],
            related_topics: vec!["有限状态机".to_string(), "状态转换".to_string()],
            keywords: vec!["状态机".to_string(), "状态".to_string(), "转换".to_string()],
        });
        
        state_topics.insert("时序逻辑".to_string(), TopicEntry {
            topic: "时序逻辑".to_string(),
            description: "描述系统时间相关性质的逻辑".to_string(),
            documents: vec![
                "06-形式模型理论/04-时序逻辑理论".to_string(),
            ],
            related_topics: vec!["时态算子".to_string(), "模型检查".to_string()],
            keywords: vec!["时序".to_string(), "逻辑".to_string(), "时间".to_string()],
        });
        
        Self {
            petri_topics,
            control_topics,
            state_topics,
        }
    }
}
```

## 工具主题索引

### 1. 开发工具主题

```rust
// 开发工具主题索引器
pub struct DevelopmentToolTopicIndexer {
    rust_tools: HashMap<String, TopicEntry>,
    go_tools: HashMap<String, TopicEntry>,
    verification_tools: HashMap<String, TopicEntry>,
}

impl DevelopmentToolTopicIndexer {
    pub fn new() -> Self {
        let mut rust_tools = HashMap::new();
        
        // Rust工具主题
        rust_tools.insert("Rust形式化工具".to_string(), TopicEntry {
            topic: "Rust形式化工具".to_string(),
            description: "基于Rust语言构建的形式化验证和代码生成工具".to_string(),
            documents: vec![
                "08-实践应用开发/01-Rust形式化工具".to_string(),
                "08-实践应用开发/00-实践应用开发总论".to_string(),
            ],
            related_topics: vec!["形式化验证".to_string(), "代码生成".to_string()],
            keywords: vec!["Rust".to_string(), "形式化".to_string(), "工具".to_string()],
        });
        
        rust_tools.insert("Rust类型系统".to_string(), TopicEntry {
            topic: "Rust类型系统".to_string(),
            description: "Rust语言的类型系统和所有权模型".to_string(),
            documents: vec![
                "08-实践应用开发/01-Rust形式化工具".to_string(),
            ],
            related_topics: vec!["所有权".to_string(), "借用检查".to_string()],
            keywords: vec!["类型系统".to_string(), "所有权".to_string(), "安全".to_string()],
        });
        
        let mut go_tools = HashMap::new();
        
        // Go工具主题
        go_tools.insert("Go形式化工具".to_string(), TopicEntry {
            topic: "Go形式化工具".to_string(),
            description: "基于Go语言构建的形式化验证工具".to_string(),
            documents: vec![
                "08-实践应用开发/02-Go形式化工具".to_string(),
            ],
            related_topics: vec!["并发".to_string(), "goroutine".to_string()],
            keywords: vec!["Go".to_string(), "并发".to_string(), "工具".to_string()],
        });
        
        go_tools.insert("Go并发模型".to_string(), TopicEntry {
            topic: "Go并发模型".to_string(),
            description: "Go语言的并发编程模型和原语".to_string(),
            documents: vec![
                "08-实践应用开发/02-Go形式化工具".to_string(),
            ],
            related_topics: vec!["goroutine".to_string(), "channel".to_string()],
            keywords: vec!["并发".to_string(), "goroutine".to_string(), "channel".to_string()],
        });
        
        let mut verification_tools = HashMap::new();
        
        // 验证工具主题
        verification_tools.insert("理论验证工具".to_string(), TopicEntry {
            topic: "理论验证工具".to_string(),
            description: "用于验证形式化理论正确性的工具".to_string(),
            documents: vec![
                "08-实践应用开发/03-理论验证工具".to_string(),
            ],
            related_topics: vec!["形式化证明".to_string(), "模型检查".to_string()],
            keywords: vec!["验证".to_string(), "理论".to_string(), "正确性".to_string()],
        });
        
        verification_tools.insert("模型检测工具".to_string(), TopicEntry {
            topic: "模型检测工具".to_string(),
            description: "用于检测软件模型是否满足特定属性的工具".to_string(),
            documents: vec![
                "08-实践应用开发/05-模型检测工具".to_string(),
            ],
            related_topics: vec!["状态空间".to_string(), "属性检查".to_string()],
            keywords: vec!["模型检测".to_string(), "状态空间".to_string(), "属性".to_string()],
        });
        
        Self {
            rust_tools,
            go_tools,
            verification_tools,
        }
    }
}
```

### 2. 设计工具主题

```rust
// 设计工具主题索引器
pub struct DesignToolTopicIndexer {
    architecture_tools: HashMap<String, TopicEntry>,
    code_generation_tools: HashMap<String, TopicEntry>,
}

impl DesignToolTopicIndexer {
    pub fn new() -> Self {
        let mut architecture_tools = HashMap::new();
        
        // 架构设计工具主题
        architecture_tools.insert("架构设计工具".to_string(), TopicEntry {
            topic: "架构设计工具".to_string(),
            description: "辅助软件架构设计的工具集".to_string(),
            documents: vec![
                "08-实践应用开发/04-架构设计工具".to_string(),
            ],
            related_topics: vec!["架构建模".to_string(), "模式识别".to_string()],
            keywords: vec!["架构".to_string(), "设计".to_string(), "工具".to_string()],
        });
        
        architecture_tools.insert("架构建模".to_string(), TopicEntry {
            topic: "架构建模".to_string(),
            description: "使用形式化方法构建软件架构模型".to_string(),
            documents: vec![
                "08-实践应用开发/04-架构设计工具".to_string(),
            ],
            related_topics: vec!["架构设计工具".to_string(), "形式化建模".to_string()],
            keywords: vec!["建模".to_string(), "架构".to_string(), "形式化".to_string()],
        });
        
        let mut code_generation_tools = HashMap::new();
        
        // 代码生成工具主题
        code_generation_tools.insert("代码生成工具".to_string(), TopicEntry {
            topic: "代码生成工具".to_string(),
            description: "从形式化规范自动生成代码的工具".to_string(),
            documents: vec![
                "08-实践应用开发/06-代码生成工具".to_string(),
            ],
            related_topics: vec!["模板引擎".to_string(), "代码优化".to_string()],
            keywords: vec!["代码生成".to_string(), "自动化".to_string(), "工具".to_string()],
        });
        
        code_generation_tools.insert("模板引擎".to_string(), TopicEntry {
            topic: "模板引擎".to_string(),
            description: "基于模板的代码生成引擎".to_string(),
            documents: vec![
                "08-实践应用开发/06-代码生成工具".to_string(),
            ],
            related_topics: vec!["代码生成工具".to_string(), "模板".to_string()],
            keywords: vec!["模板".to_string(), "引擎".to_string(), "生成".to_string()],
        });
        
        Self {
            architecture_tools,
            code_generation_tools,
        }
    }
}
```

## 主题搜索系统

### 1. 多维度主题搜索

```rust
// 主题搜索系统
pub struct TopicSearchSystem {
    topic_indexers: Vec<Box<dyn TopicIndexer>>,
    search_engine: TopicSearchEngine,
}

impl TopicSearchSystem {
    pub fn new() -> Self {
        let mut indexers: Vec<Box<dyn TopicIndexer>> = Vec::new();
        indexers.push(Box::new(PhilosophyTopicIndexer::new()));
        indexers.push(Box::new(MathematicsTopicIndexer::new()));
        indexers.push(Box::new(ArchitectureTopicIndexer::new()));
        indexers.push(Box::new(FormalModelTopicIndexer::new()));
        indexers.push(Box::new(DevelopmentToolTopicIndexer::new()));
        indexers.push(Box::new(DesignToolTopicIndexer::new()));
        
        Self {
            topic_indexers: indexers,
            search_engine: TopicSearchEngine::new(),
        }
    }
    
    pub fn search_topic(&self, query: &str) -> Vec<TopicSearchResult> {
        let mut results = Vec::new();
        
        for indexer in &self.topic_indexers {
            if let Some(topic) = indexer.search_topic(query) {
                results.push(TopicSearchResult {
                    topic,
                    relevance_score: self.search_engine.calculate_relevance(query, &topic),
                    source_indexer: indexer.name(),
                });
            }
        }
        
        results.sort_by(|a, b| b.relevance_score.partial_cmp(&a.relevance_score).unwrap());
        results
    }
    
    pub fn search_by_category(&self, category: TopicCategory, query: &str) -> Vec<TopicEntry> {
        let mut results = Vec::new();
        
        for indexer in &self.topic_indexers {
            if indexer.category() == category {
                if let Some(topic) = indexer.search_topic(query) {
                    results.push(topic);
                }
            }
        }
        
        results
    }
    
    pub fn find_related_topics(&self, topic_name: &str) -> Vec<TopicEntry> {
        let mut related = Vec::new();
        
        for indexer in &self.topic_indexers {
            related.extend(indexer.find_related_topics(topic_name));
        }
        
        // 去重
        related.sort_by(|a, b| a.topic.cmp(&b.topic));
        related.dedup_by(|a, b| a.topic == b.topic);
        
        related
    }
    
    pub fn browse_topics(&self, category: Option<TopicCategory>) -> Vec<TopicEntry> {
        let mut all_topics = Vec::new();
        
        for indexer in &self.topic_indexers {
            if let Some(cat) = category {
                if indexer.category() == cat {
                    all_topics.extend(indexer.get_all_topics());
                }
            } else {
                all_topics.extend(indexer.get_all_topics());
            }
        }
        
        all_topics.sort_by(|a, b| a.topic.cmp(&b.topic));
        all_topics
    }
}

// 主题搜索引擎
pub struct TopicSearchEngine {
    fuzzy_matcher: FuzzyMatcher,
    semantic_analyzer: SemanticAnalyzer,
}

impl TopicSearchEngine {
    pub fn new() -> Self {
        Self {
            fuzzy_matcher: FuzzyMatcher::new(),
            semantic_analyzer: SemanticAnalyzer::new(),
        }
    }
    
    pub fn calculate_relevance(&self, query: &str, topic: &TopicEntry) -> f64 {
        let exact_match = if topic.topic == query { 1.0 } else { 0.0 };
        let fuzzy_match = self.fuzzy_matcher.calculate_similarity(query, &topic.topic);
        let semantic_match = self.semantic_analyzer.calculate_similarity(query, &topic.description);
        
        // 检查关键词匹配
        let keyword_match = self.calculate_keyword_match(query, &topic.keywords);
        
        // 加权组合
        0.4 * exact_match + 0.3 * fuzzy_match + 0.2 * semantic_match + 0.1 * keyword_match
    }
    
    fn calculate_keyword_match(&self, query: &str, keywords: &[String]) -> f64 {
        let query_lower = query.to_lowercase();
        let mut match_count = 0;
        
        for keyword in keywords {
            if query_lower.contains(&keyword.to_lowercase()) {
                match_count += 1;
            }
        }
        
        if keywords.is_empty() {
            0.0
        } else {
            match_count as f64 / keywords.len() as f64
        }
    }
}
```

### 2. 主题关系图

```rust
// 主题关系图
pub struct TopicRelationshipGraph {
    nodes: HashMap<String, TopicNode>,
    edges: HashMap<String, Vec<RelationshipEdge>>,
}

impl TopicRelationshipGraph {
    pub fn new() -> Self {
        Self {
            nodes: HashMap::new(),
            edges: HashMap::new(),
        }
    }
    
    pub fn add_topic(&mut self, topic: TopicEntry) {
        let node = TopicNode {
            topic: topic.topic.clone(),
            description: topic.description,
            category: self.categorize_topic(&topic),
            document_count: topic.documents.len(),
        };
        
        self.nodes.insert(topic.topic.clone(), node);
        
        // 添加关系边
        for related_topic in &topic.related_topics {
            self.add_relationship(&topic.topic, related_topic, RelationshipType::Related);
        }
    }
    
    pub fn add_relationship(&mut self, from: &str, to: &str, relationship_type: RelationshipType) {
        let edge = RelationshipEdge {
            source: from.to_string(),
            target: to.to_string(),
            relationship_type,
            strength: 1.0,
        };
        
        self.edges.entry(from.to_string())
            .or_insert_with(Vec::new)
            .push(edge);
    }
    
    pub fn find_topic_cluster(&self, topic: &str) -> Vec<TopicNode> {
        let mut cluster = Vec::new();
        let mut visited = HashSet::new();
        
        self.dfs_traverse(topic, &mut cluster, &mut visited);
        cluster
    }
    
    pub fn find_central_topics(&self) -> Vec<TopicNode> {
        let mut centrality_scores = Vec::new();
        
        for (topic_name, _) in &self.nodes {
            let centrality = self.calculate_centrality(topic_name);
            centrality_scores.push((topic_name.clone(), centrality));
        }
        
        centrality_scores.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap());
        
        centrality_scores.into_iter()
            .take(10)
            .filter_map(|(topic_name, _)| self.nodes.get(&topic_name).cloned())
            .collect()
    }
    
    fn calculate_centrality(&self, topic: &str) -> f64 {
        // 简单的度中心性计算
        let in_degree = self.edges.values()
            .flatten()
            .filter(|edge| edge.target == topic)
            .count();
        
        let out_degree = self.edges.get(topic)
            .map(|edges| edges.len())
            .unwrap_or(0);
        
        (in_degree + out_degree) as f64
    }
    
    fn categorize_topic(&self, topic: &TopicEntry) -> TopicCategory {
        // 基于主题内容和文档位置进行分类
        if topic.documents.iter().any(|doc| doc.contains("哲学")) {
            TopicCategory::Philosophy
        } else if topic.documents.iter().any(|doc| doc.contains("数学")) {
            TopicCategory::Mathematics
        } else if topic.documents.iter().any(|doc| doc.contains("软件架构")) {
            TopicCategory::Architecture
        } else if topic.documents.iter().any(|doc| doc.contains("形式模型")) {
            TopicCategory::FormalModel
        } else if topic.documents.iter().any(|doc| doc.contains("实践应用开发")) {
            TopicCategory::Tools
        } else {
            TopicCategory::Other
        }
    }
}
```

## 交叉引用

- [[00-索引与导航总论|索引与导航总论]]
- [[01-快速导航指南|快速导航指南]]
- [[02-概念索引|概念索引]]
- [[04-工具索引|工具索引]]

## 导航

- [返回总目录](../README.md)
- [返回索引与导航总论](00-索引与导航总论.md)
- [01-快速导航指南](01-快速导航指南.md)
- [02-概念索引](02-概念索引.md)
- [04-工具索引](04-工具索引.md)
