# 概念索引

## 概念索引概述

概念索引是形式化架构理论项目的核心概念组织系统，通过系统性的概念分类和关联，为用户提供快速的概念查找和理解支持。

### 索引结构

- **基础概念**: 基本定义、公理、定理等基础理论概念
- **核心概念**: 关键理论概念、重要定义等核心内容
- **专业概念**: 特定领域的专业术语和概念

## 基础概念索引

### 1. 哲学基础概念

```rust
// 哲学概念索引器
pub struct PhilosophyConceptIndexer {
    ontology_concepts: HashMap<String, ConceptEntry>,
    epistemology_concepts: HashMap<String, ConceptEntry>,
    logic_concepts: HashMap<String, ConceptEntry>,
}

impl PhilosophyConceptIndexer {
    pub fn new() -> Self {
        let mut ontology_concepts = HashMap::new();
        
        // 本体论概念
        ontology_concepts.insert("存在".to_string(), ConceptEntry {
            term: "存在".to_string(),
            definition: "事物在现实世界中的实际存在状态".to_string(),
            location: "01-哲学基础理论/01-本体论基础".to_string(),
            related_concepts: vec!["实体".to_string(), "属性".to_string(), "关系".to_string()],
            examples: vec!["软件系统的存在".to_string(), "数据的存在".to_string()],
        });
        
        ontology_concepts.insert("实体".to_string(), ConceptEntry {
            term: "实体".to_string(),
            definition: "具有独立存在性的基本单位".to_string(),
            location: "01-哲学基础理论/01-本体论基础".to_string(),
            related_concepts: vec!["存在".to_string(), "属性".to_string()],
            examples: vec!["软件组件".to_string(), "数据对象".to_string()],
        });
        
        let mut epistemology_concepts = HashMap::new();
        
        // 认识论概念
        epistemology_concepts.insert("知识".to_string(), ConceptEntry {
            term: "知识".to_string(),
            definition: "经过验证的真实信念".to_string(),
            location: "01-哲学基础理论/02-认识论基础".to_string(),
            related_concepts: vec!["信念".to_string(), "真理".to_string(), "验证".to_string()],
            examples: vec!["软件架构知识".to_string(), "编程语言知识".to_string()],
        });
        
        epistemology_concepts.insert("真理".to_string(), ConceptEntry {
            term: "真理".to_string(),
            definition: "与客观现实相符合的认识".to_string(),
            location: "01-哲学基础理论/02-认识论基础".to_string(),
            related_concepts: vec!["知识".to_string(), "客观性".to_string()],
            examples: vec!["数学定理".to_string(), "逻辑推理".to_string()],
        });
        
        let mut logic_concepts = HashMap::new();
        
        // 逻辑学概念
        logic_concepts.insert("推理".to_string(), ConceptEntry {
            term: "推理".to_string(),
            definition: "从已知前提得出结论的思维过程".to_string(),
            location: "01-哲学基础理论/03-逻辑学基础".to_string(),
            related_concepts: vec!["前提".to_string(), "结论".to_string(), "有效性".to_string()],
            examples: vec!["演绎推理".to_string(), "归纳推理".to_string()],
        });
        
        logic_concepts.insert("有效性".to_string(), ConceptEntry {
            term: "有效性".to_string(),
            definition: "推理形式保证结论真实性的性质".to_string(),
            location: "01-哲学基础理论/03-逻辑学基础".to_string(),
            related_concepts: vec!["推理".to_string(), "逻辑形式".to_string()],
            examples: vec!["形式化验证".to_string(), "定理证明".to_string()],
        });
        
        Self {
            ontology_concepts,
            epistemology_concepts,
            logic_concepts,
        }
    }
    
    pub fn search_concept(&self, term: &str) -> Option<ConceptEntry> {
        self.ontology_concepts.get(term)
            .or_else(|| self.epistemology_concepts.get(term))
            .or_else(|| self.logic_concepts.get(term))
            .cloned()
    }
    
    pub fn find_related_concepts(&self, term: &str) -> Vec<ConceptEntry> {
        let mut related = Vec::new();
        
        if let Some(concept) = self.search_concept(term) {
            for related_term in &concept.related_concepts {
                if let Some(related_concept) = self.search_concept(related_term) {
                    related.push(related_concept);
                }
            }
        }
        
        related
    }
}
```

### 2. 数学基础概念

```rust
// 数学概念索引器
pub struct MathematicsConceptIndexer {
    set_theory_concepts: HashMap<String, ConceptEntry>,
    algebra_concepts: HashMap<String, ConceptEntry>,
    analysis_concepts: HashMap<String, ConceptEntry>,
}

impl MathematicsConceptIndexer {
    pub fn new() -> Self {
        let mut set_theory_concepts = HashMap::new();
        
        // 集合论概念
        set_theory_concepts.insert("集合".to_string(), ConceptEntry {
            term: "集合".to_string(),
            definition: "具有某种共同特征的事物的总体".to_string(),
            location: "02-数学理论体系/01-集合论基础".to_string(),
            related_concepts: vec!["元素".to_string(), "子集".to_string(), "并集".to_string()],
            examples: vec!["数据类型集合".to_string(), "函数集合".to_string()],
        });
        
        set_theory_concepts.insert("函数".to_string(), ConceptEntry {
            term: "函数".to_string(),
            definition: "从一个集合到另一个集合的映射关系".to_string(),
            location: "02-数学理论体系/01-集合论基础".to_string(),
            related_concepts: vec!["定义域".to_string(), "值域".to_string(), "映射".to_string()],
            examples: vec!["数学函数".to_string(), "程序函数".to_string()],
        });
        
        let mut algebra_concepts = HashMap::new();
        
        // 代数概念
        algebra_concepts.insert("群".to_string(), ConceptEntry {
            term: "群".to_string(),
            definition: "具有二元运算的代数结构，满足封闭性、结合律、单位元和逆元".to_string(),
            location: "02-数学理论体系/02-代数理论".to_string(),
            related_concepts: vec!["运算".to_string(), "单位元".to_string(), "逆元".to_string()],
            examples: vec!["整数加法群".to_string(), "对称群".to_string()],
        });
        
        algebra_concepts.insert("环".to_string(), ConceptEntry {
            term: "环".to_string(),
            definition: "具有两种运算的代数结构，满足特定公理".to_string(),
            location: "02-数学理论体系/02-代数理论".to_string(),
            related_concepts: vec!["加法".to_string(), "乘法".to_string(), "分配律".to_string()],
            examples: vec!["整数环".to_string(), "多项式环".to_string()],
        });
        
        let mut analysis_concepts = HashMap::new();
        
        // 分析概念
        analysis_concepts.insert("极限".to_string(), ConceptEntry {
            term: "极限".to_string(),
            definition: "函数在某个点的趋近值".to_string(),
            location: "02-数学理论体系/04-分析理论".to_string(),
            related_concepts: vec!["连续性".to_string(), "收敛".to_string()],
            examples: vec!["数列极限".to_string(), "函数极限".to_string()],
        });
        
        analysis_concepts.insert("连续性".to_string(), ConceptEntry {
            term: "连续性".to_string(),
            definition: "函数在某个点的极限值等于函数值".to_string(),
            location: "02-数学理论体系/04-分析理论".to_string(),
            related_concepts: vec!["极限".to_string(), "间断点".to_string()],
            examples: vec!["连续函数".to_string(), "分段连续".to_string()],
        });
        
        Self {
            set_theory_concepts,
            algebra_concepts,
            analysis_concepts,
        }
    }
}
```

## 核心概念索引

### 1. 形式语言核心概念

```rust
// 形式语言核心概念索引器
pub struct FormalLanguageConceptIndexer {
    language_concepts: HashMap<String, ConceptEntry>,
    automata_concepts: HashMap<String, ConceptEntry>,
    grammar_concepts: HashMap<String, ConceptEntry>,
}

impl FormalLanguageConceptIndexer {
    pub fn new() -> Self {
        let mut language_concepts = HashMap::new();
        
        // 形式语言概念
        language_concepts.insert("形式语言".to_string(), ConceptEntry {
            term: "形式语言".to_string(),
            definition: "由符号组成的有限序列的集合".to_string(),
            location: "03-形式语言理论/01-形式语言基础".to_string(),
            related_concepts: vec!["字母表".to_string(), "字符串".to_string(), "语法".to_string()],
            examples: vec!["编程语言".to_string(), "标记语言".to_string()],
        });
        
        language_concepts.insert("语法".to_string(), ConceptEntry {
            term: "语法".to_string(),
            definition: "定义语言结构的规则系统".to_string(),
            location: "03-形式语言理论/03-语法分析理论".to_string(),
            related_concepts: vec!["产生式".to_string(), "语法树".to_string(), "解析".to_string()],
            examples: vec!["上下文无关语法".to_string(), "正则语法".to_string()],
        });
        
        let mut automata_concepts = HashMap::new();
        
        // 自动机概念
        automata_concepts.insert("有限自动机".to_string(), ConceptEntry {
            term: "有限自动机".to_string(),
            definition: "具有有限状态和转移规则的抽象计算模型".to_string(),
            location: "03-形式语言理论/02-自动机理论".to_string(),
            related_concepts: vec!["状态".to_string(), "转移".to_string(), "接受状态".to_string()],
            examples: vec!["确定性有限自动机".to_string(), "非确定性有限自动机".to_string()],
        });
        
        automata_concepts.insert("图灵机".to_string(), ConceptEntry {
            term: "图灵机".to_string(),
            definition: "具有无限存储能力的抽象计算模型".to_string(),
            location: "03-形式语言理论/05-计算理论".to_string(),
            related_concepts: vec!["磁带".to_string(), "读写头".to_string(), "可计算性".to_string()],
            examples: vec!["通用图灵机".to_string(), "图灵等价".to_string()],
        });
        
        let mut grammar_concepts = HashMap::new();
        
        // 语法分析概念
        grammar_concepts.insert("上下文无关语法".to_string(), ConceptEntry {
            term: "上下文无关语法".to_string(),
            definition: "产生式左部只包含单个非终结符的语法".to_string(),
            location: "03-形式语言理论/03-语法分析理论".to_string(),
            related_concepts: vec!["产生式".to_string(), "非终结符".to_string(), "终结符".to_string()],
            examples: vec!["BNF语法".to_string(), "EBNF语法".to_string()],
        });
        
        grammar_concepts.insert("语义分析".to_string(), ConceptEntry {
            term: "语义分析".to_string(),
            definition: "分析程序语义正确性的过程".to_string(),
            location: "03-形式语言理论/04-语义分析理论".to_string(),
            related_concepts: vec!["类型检查".to_string(), "作用域".to_string(), "语义规则".to_string()],
            examples: vec!["静态语义分析".to_string(), "动态语义分析".to_string()],
        });
        
        Self {
            language_concepts,
            automata_concepts,
            grammar_concepts,
        }
    }
}
```

### 2. 软件架构核心概念

```rust
// 软件架构核心概念索引器
pub struct ArchitectureConceptIndexer {
    pattern_concepts: HashMap<String, ConceptEntry>,
    service_concepts: HashMap<String, ConceptEntry>,
    component_concepts: HashMap<String, ConceptEntry>,
}

impl ArchitectureConceptIndexer {
    pub fn new() -> Self {
        let mut pattern_concepts = HashMap::new();
        
        // 设计模式概念
        pattern_concepts.insert("设计模式".to_string(), ConceptEntry {
            term: "设计模式".to_string(),
            definition: "解决软件设计中常见问题的标准解决方案".to_string(),
            location: "04-软件架构理论/01-设计模式理论".to_string(),
            related_concepts: vec!["创建型模式".to_string(), "结构型模式".to_string(), "行为型模式".to_string()],
            examples: vec!["单例模式".to_string(), "工厂模式".to_string()],
        });
        
        pattern_concepts.insert("微服务".to_string(), ConceptEntry {
            term: "微服务".to_string(),
            definition: "将应用程序分解为小型、独立的服务单元".to_string(),
            location: "04-软件架构理论/02-微服务架构理论".to_string(),
            related_concepts: vec!["服务".to_string(), "分布式".to_string(), "容器化".to_string()],
            examples: vec!["REST微服务".to_string(), "事件驱动微服务".to_string()],
        });
        
        let mut service_concepts = HashMap::new();
        
        // 服务概念
        service_concepts.insert("服务".to_string(), ConceptEntry {
            term: "服务".to_string(),
            definition: "提供特定功能的软件组件".to_string(),
            location: "04-软件架构理论/02-微服务架构理论".to_string(),
            related_concepts: vec!["接口".to_string(), "契约".to_string(), "发现".to_string()],
            examples: vec!["Web服务".to_string(), "API服务".to_string()],
        });
        
        service_concepts.insert("服务网格".to_string(), ConceptEntry {
            term: "服务网格".to_string(),
            definition: "管理服务间通信的基础设施层".to_string(),
            location: "04-软件架构理论/02-微服务架构理论".to_string(),
            related_concepts: vec!["代理".to_string(), "路由".to_string(), "负载均衡".to_string()],
            examples: vec!["Istio".to_string(), "Linkerd".to_string()],
        });
        
        let mut component_concepts = HashMap::new();
        
        // 组件概念
        component_concepts.insert("组件".to_string(), ConceptEntry {
            term: "组件".to_string(),
            definition: "可重用的软件模块".to_string(),
            location: "04-软件架构理论/03-组件化架构理论".to_string(),
            related_concepts: vec!["接口".to_string(), "依赖".to_string(), "组合".to_string()],
            examples: vec!["UI组件".to_string(), "业务组件".to_string()],
        });
        
        component_concepts.insert("依赖注入".to_string(), ConceptEntry {
            term: "依赖注入".to_string(),
            definition: "通过外部提供依赖对象的设计模式".to_string(),
            location: "04-软件架构理论/03-组件化架构理论".to_string(),
            related_concepts: vec!["依赖".to_string(), "注入".to_string(), "控制反转".to_string()],
            examples: vec!["构造函数注入".to_string(), "属性注入".to_string()],
        });
        
        Self {
            pattern_concepts,
            service_concepts,
            component_concepts,
        }
    }
}
```

## 专业概念索引

### 1. 形式模型专业概念

```rust
// 形式模型专业概念索引器
pub struct FormalModelConceptIndexer {
    petri_concepts: HashMap<String, ConceptEntry>,
    control_concepts: HashMap<String, ConceptEntry>,
    state_concepts: HashMap<String, ConceptEntry>,
}

impl FormalModelConceptIndexer {
    pub fn new() -> Self {
        let mut petri_concepts = HashMap::new();
        
        // Petri网概念
        petri_concepts.insert("Petri网".to_string(), ConceptEntry {
            term: "Petri网".to_string(),
            definition: "用于建模并发系统的数学工具".to_string(),
            location: "06-形式模型理论/01-Petri网理论".to_string(),
            related_concepts: vec!["库所".to_string(), "变迁".to_string(), "标记".to_string()],
            examples: vec!["工作流Petri网".to_string(), "通信Petri网".to_string()],
        });
        
        petri_concepts.insert("库所".to_string(), ConceptEntry {
            term: "库所".to_string(),
            definition: "Petri网中表示状态的节点".to_string(),
            location: "06-形式模型理论/01-Petri网理论".to_string(),
            related_concepts: vec!["标记".to_string(), "容量".to_string()],
            examples: vec!["资源库所".to_string(), "条件库所".to_string()],
        });
        
        let mut control_concepts = HashMap::new();
        
        // 控制理论概念
        control_concepts.insert("状态空间".to_string(), ConceptEntry {
            term: "状态空间".to_string(),
            definition: "系统所有可能状态的集合".to_string(),
            location: "06-形式模型理论/02-控制理论".to_string(),
            related_concepts: vec!["状态".to_string(), "转移".to_string(), "可达性".to_string()],
            examples: vec!["有限状态空间".to_string(), "无限状态空间".to_string()],
        });
        
        control_concepts.insert("可达性".to_string(), ConceptEntry {
            term: "可达性".to_string(),
            definition: "从初始状态能否到达目标状态的性质".to_string(),
            location: "06-形式模型理论/02-控制理论".to_string(),
            related_concepts: vec!["状态空间".to_string(), "路径".to_string()],
            examples: vec!["可达性分析".to_string(), "可达性验证".to_string()],
        });
        
        let mut state_concepts = HashMap::new();
        
        // 状态机概念
        state_concepts.insert("有限状态机".to_string(), ConceptEntry {
            term: "有限状态机".to_string(),
            definition: "具有有限状态和转移规则的抽象机器".to_string(),
            location: "06-形式模型理论/03-状态机理论".to_string(),
            related_concepts: vec!["状态".to_string(), "事件".to_string(), "动作".to_string()],
            examples: vec!["Moore机".to_string(), "Mealy机".to_string()],
        });
        
        state_concepts.insert("时序逻辑".to_string(), ConceptEntry {
            term: "时序逻辑".to_string(),
            definition: "描述系统时间相关性质的逻辑".to_string(),
            location: "06-形式模型理论/04-时序逻辑理论".to_string(),
            related_concepts: vec!["时态算子".to_string(), "路径".to_string(), "模型检查".to_string()],
            examples: vec!["线性时序逻辑".to_string(), "分支时序逻辑".to_string()],
        });
        
        Self {
            petri_concepts,
            control_concepts,
            state_concepts,
        }
    }
}
```

### 2. 编程语言专业概念

```rust
// 编程语言专业概念索引器
pub struct ProgrammingLanguageConceptIndexer {
    language_design_concepts: HashMap<String, ConceptEntry>,
    compiler_concepts: HashMap<String, ConceptEntry>,
}

impl ProgrammingLanguageConceptIndexer {
    pub fn new() -> Self {
        let mut language_design_concepts = HashMap::new();
        
        // 语言设计概念
        language_design_concepts.insert("语法".to_string(), ConceptEntry {
            term: "语法".to_string(),
            definition: "编程语言的结构规则".to_string(),
            location: "05-编程语言理论/01-语言设计理论".to_string(),
            related_concepts: vec!["词法".to_string(), "语义".to_string(), "BNF".to_string()],
            examples: vec!["C语法".to_string(), "Python语法".to_string()],
        });
        
        language_design_concepts.insert("语义".to_string(), ConceptEntry {
            term: "语义".to_string(),
            definition: "编程语言的含义规则".to_string(),
            location: "05-编程语言理论/01-语言设计理论".to_string(),
            related_concepts: vec!["操作语义".to_string(), "指称语义".to_string(), "公理语义".to_string()],
            examples: vec!["静态语义".to_string(), "动态语义".to_string()],
        });
        
        let mut compiler_concepts = HashMap::new();
        
        // 编译器概念
        compiler_concepts.insert("词法分析".to_string(), ConceptEntry {
            term: "词法分析".to_string(),
            definition: "将源代码转换为词法单元的过程".to_string(),
            location: "05-编程语言理论/02-编译器理论".to_string(),
            related_concepts: vec!["词法单元".to_string(), "正则表达式".to_string(), "有限自动机".to_string()],
            examples: vec!["Flex".to_string(), "词法扫描器".to_string()],
        });
        
        compiler_concepts.insert("语法分析".to_string(), ConceptEntry {
            term: "语法分析".to_string(),
            definition: "将词法单元转换为语法树的过程".to_string(),
            location: "05-编程语言理论/02-编译器理论".to_string(),
            related_concepts: vec!["语法树".to_string(), "解析器".to_string(), "语法错误".to_string()],
            examples: vec!["递归下降解析".to_string(), "LR解析".to_string()],
        });
        
        Self {
            language_design_concepts,
            compiler_concepts,
        }
    }
}
```

## 概念搜索系统

### 1. 多维度概念搜索

```rust
// 概念搜索系统
pub struct ConceptSearchSystem {
    concept_indexers: Vec<Box<dyn ConceptIndexer>>,
    search_engine: ConceptSearchEngine,
}

impl ConceptSearchSystem {
    pub fn new() -> Self {
        let mut indexers: Vec<Box<dyn ConceptIndexer>> = Vec::new();
        indexers.push(Box::new(PhilosophyConceptIndexer::new()));
        indexers.push(Box::new(MathematicsConceptIndexer::new()));
        indexers.push(Box::new(FormalLanguageConceptIndexer::new()));
        indexers.push(Box::new(ArchitectureConceptIndexer::new()));
        indexers.push(Box::new(FormalModelConceptIndexer::new()));
        indexers.push(Box::new(ProgrammingLanguageConceptIndexer::new()));
        
        Self {
            concept_indexers: indexers,
            search_engine: ConceptSearchEngine::new(),
        }
    }
    
    pub fn search_concept(&self, query: &str) -> Vec<ConceptSearchResult> {
        let mut results = Vec::new();
        
        for indexer in &self.concept_indexers {
            if let Some(concept) = indexer.search_concept(query) {
                results.push(ConceptSearchResult {
                    concept,
                    relevance_score: self.search_engine.calculate_relevance(query, &concept),
                    source_indexer: indexer.name(),
                });
            }
        }
        
        results.sort_by(|a, b| b.relevance_score.partial_cmp(&a.relevance_score).unwrap());
        results
    }
    
    pub fn search_by_category(&self, category: ConceptCategory, query: &str) -> Vec<ConceptEntry> {
        let mut results = Vec::new();
        
        for indexer in &self.concept_indexers {
            if indexer.category() == category {
                if let Some(concept) = indexer.search_concept(query) {
                    results.push(concept);
                }
            }
        }
        
        results
    }
    
    pub fn find_related_concepts(&self, concept_term: &str) -> Vec<ConceptEntry> {
        let mut related = Vec::new();
        
        for indexer in &self.concept_indexers {
            related.extend(indexer.find_related_concepts(concept_term));
        }
        
        // 去重
        related.sort_by(|a, b| a.term.cmp(&b.term));
        related.dedup_by(|a, b| a.term == b.term);
        
        related
    }
}

// 概念搜索引擎
pub struct ConceptSearchEngine {
    fuzzy_matcher: FuzzyMatcher,
    semantic_analyzer: SemanticAnalyzer,
}

impl ConceptSearchEngine {
    pub fn new() -> Self {
        Self {
            fuzzy_matcher: FuzzyMatcher::new(),
            semantic_analyzer: SemanticAnalyzer::new(),
        }
    }
    
    pub fn calculate_relevance(&self, query: &str, concept: &ConceptEntry) -> f64 {
        let exact_match = if concept.term == query { 1.0 } else { 0.0 };
        let fuzzy_match = self.fuzzy_matcher.calculate_similarity(query, &concept.term);
        let semantic_match = self.semantic_analyzer.calculate_similarity(query, &concept.definition);
        
        // 加权组合
        0.5 * exact_match + 0.3 * fuzzy_match + 0.2 * semantic_match
    }
}
```

### 2. 概念关系图

```rust
// 概念关系图
pub struct ConceptRelationshipGraph {
    nodes: HashMap<String, ConceptNode>,
    edges: HashMap<String, Vec<RelationshipEdge>>,
}

impl ConceptRelationshipGraph {
    pub fn new() -> Self {
        Self {
            nodes: HashMap::new(),
            edges: HashMap::new(),
        }
    }
    
    pub fn add_concept(&mut self, concept: ConceptEntry) {
        let node = ConceptNode {
            term: concept.term.clone(),
            definition: concept.definition,
            category: self.categorize_concept(&concept),
        };
        
        self.nodes.insert(concept.term.clone(), node);
        
        // 添加关系边
        for related_term in &concept.related_concepts {
            self.add_relationship(&concept.term, related_term, RelationshipType::Related);
        }
    }
    
    pub fn add_relationship(&mut self, from: &str, to: &str, relationship_type: RelationshipType) {
        let edge = RelationshipEdge {
            source: from.to_string(),
            target: to.to_string(),
            relationship_type,
            strength: 1.0,
        };
        
        self.edges.entry(from.to_string())
            .or_insert_with(Vec::new)
            .push(edge);
    }
    
    pub fn find_concept_cluster(&self, concept: &str) -> Vec<ConceptNode> {
        let mut cluster = Vec::new();
        let mut visited = HashSet::new();
        
        self.dfs_traverse(concept, &mut cluster, &mut visited);
        cluster
    }
    
    fn dfs_traverse(&self, concept: &str, cluster: &mut Vec<ConceptNode>, visited: &mut HashSet<String>) {
        if visited.contains(concept) {
            return;
        }
        
        visited.insert(concept.to_string());
        
        if let Some(node) = self.nodes.get(concept) {
            cluster.push(node.clone());
        }
        
        if let Some(edges) = self.edges.get(concept) {
            for edge in edges {
                self.dfs_traverse(&edge.target, cluster, visited);
            }
        }
    }
    
    fn categorize_concept(&self, concept: &ConceptEntry) -> ConceptCategory {
        // 基于概念位置和内容进行分类
        if concept.location.contains("哲学") {
            ConceptCategory::Philosophy
        } else if concept.location.contains("数学") {
            ConceptCategory::Mathematics
        } else if concept.location.contains("形式语言") {
            ConceptCategory::FormalLanguage
        } else if concept.location.contains("软件架构") {
            ConceptCategory::Architecture
        } else if concept.location.contains("形式模型") {
            ConceptCategory::FormalModel
        } else if concept.location.contains("编程语言") {
            ConceptCategory::ProgrammingLanguage
        } else {
            ConceptCategory::Other
        }
    }
}
```

## 交叉引用

- [[00-索引与导航总论|索引与导航总论]]
- [[01-快速导航指南|快速导航指南]]
- [[03-主题索引|主题索引]]
- [[04-工具索引|工具索引]]

## 导航

- [返回总目录](../README.md)
- [返回索引与导航总论](00-索引与导航总论.md)
- [01-快速导航指南](01-快速导航指南.md)
- [03-主题索引](03-主题索引.md)
- [04-工具索引](04-工具索引.md)
