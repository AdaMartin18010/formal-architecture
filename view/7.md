# how to do

从"理论愿景"转向"工程实操"，以下是一套可直接落地的**语义驱动架构实施手册**，包含**实施原则、五步法、工具链、组织变革与风险清单**。

---

## 一、实施黄金法则

### **法则1：语义优先，技术归零**

- **原则**：所有设计评审**先讨论DSL语义，再讨论技术实现**
- **红线**：未经DSL定义的需求，**不允许写第一行代码**
- **工具**：强制使用 **"语义契约门禁"** （Git Hook阻止无DSL的PR提交）

### **法则2：可逆性即生命线**

- **原则**：任何DSL变更必须**可反向提取**，代码与模型**双向同步**
- **实践**：CI流水线每日凌晨执行 **"反向工程校验"** ，若提取的DSL与源码DSL不一致，**自动阻塞发布**
- **度量**：`可逆性得分 = (成功提取次数 / 总构建次数) × 100%`，目标 **100%**

### **法则3：上下文显性化**

- **原则**：所有`if-else`分支必须对应**一个有名字的上下文参数**

```java
// 错误示范
if (user.getVipLevel() > 3) { ... } // 魔法数3

// 正确示范（由DSL生成）
if (context.userSegment() == UserSegment.HIGH_VALUE) { ... }
```

- **工具**：SonarQube自定义规则，**禁止硬编码分支**

---

## 二、五步法实施路线图

### **Step 0：基线评估（2周）**

**目标**：量化当前架构的"语义债务"

**动作清单**：

1. **语义债务扫描**

   ```bash
   # 使用语义爬虫工具（自定义AST解析器）
   java -jar semantic-crawler.jar --scan-path=./src \
     --extract=entities,events,rules \
     --output=semantic-debt-report.json
   ```

   **输出**：硬编码业务规则数、未上下文化的分支数、实体定义重复率

2. **建立语义资产库**
   - 创建Git仓库 `semantic-entities`，集中管理所有业务术语定义
   - 初始条目：从核心域（如订单、用户）抽取**50个最核心实体**

3. **团队语义能力诊断**
   - 问卷调查：20道题，评估团队对"语义保真"、"可逆性"的理解
   - **通过线**：全员得分>70分，否则需**前置培训**

**交付物**：《语义债务热力图》+《团队语义成熟度雷达图》

---

### **Step 1：语义防腐层构建（4-6周）**

**目标**：不改造遗留系统，先建立**统一语义接口**

**动作清单**：

1. **定义企业级语义契约（DSL）**

   ```dsl
   // 文件：contracts/order语义模型dsl
   domain OrderDomain {
     entity Order {
       id: UUID
       items: List<OrderItem>
       state: OrderState
       events: [CREATED, PAID, SHIPPED]
     }

     event PayOrder {
       orderId: UUID
       paymentMethod: PaymentMethod
       context: { deviceType, riskScore }
     }
   }
   ```

2. **生成技术桥接代码**

   ```bash
   # 使用Xtext生成器
   ./gradlew generateSemanticAPI --domain=order \
     --target=spring-cloud \
     --output-path=./order-semantic-bridge
   ```

   **产出**：Feign Client、DTO、OpenAPI Spec、Mock Server

3. **Sidecar模式注入**
   - 在遗留系统旁部署**语义代理服务**（Semantic Proxy）
   - 所有外部调用**强制通过代理**，代理将旧模型**翻译**为新语义模型

   ```yaml
   # Kubernetes部署
   apiVersion: v1
   kind: Service
   metadata:
     name: legacy-order-semantic-proxy
   spec:
     containers:
       - name: legacy-app
         image: order-app:v1
       - name: semantic-proxy
         image: semantic-bridge:latest
   ```

**度量**：代理成功翻译率 **>99.9%** ，性能损耗  **<5ms**  （P99）

---

### **Step 2：核心域语义化重构（8-12周）**

**目标**：选取**1个高变化率**的核心域，彻底DSL化

**动作清单**：

1. **领域选择标准**
   - 业务规则变更频率  **>2次/月**  （如促销、风控）
   - 代码行数  **<5万行**  （控制重构成本）
   - 团队意愿度  **>80%**  （内部试点）

2. **DSL-first开发流程**

   ```text
   Day 1-2: 业务分析师 + 架构师 → DSL设计评审
   Day 3-4: 架构师 → 生成器配置 + 自动化测试生成
   Day 5-7: 开发工程师 → 运行生成代码，仅需编写自定义的复杂算法
   ```

   **规则**：生成代码**不允许手工修改**，若有特殊需求→**修改DSL或生成器**

3. **建立语义测试金字塔**

   ```text
   语义层测试（50%）→ DSL解析 + 规则冲突检测（自动）
   契约层测试（30%）→ OpenAPI/AsyncAPI契约校验（自动）
   集成层测试（15%）→ 端到端场景（半自动）
   手工测试（5%）→ 仅用户体验（无法自动化）
   ```

**交付物**：DSL化服务的 **语义覆盖率报告**（目标 >90%）

---

### **Step 3：可逆工程体系搭建（4-6周）**

**目标**：实现DSL⇌代码的**双向绑定**

**动作清单**：

1. **构建反向提取器**

   ```java
   // 自定义Gradle插件
   task extractSemanticModel {
     doLast {
       // 从Java AST提取@SemanticEntity注解
       // 从Spring @EventListener提取事件语义
       // 对比源码DSL，生成差异报告
     }
   }
   ```

2. **CI/CD集成**

   ```yaml
   # .github/workflows/semantic-sync.yml
   on: [push]
   jobs:
     sync-check:
       steps:
         - run: ./gradlew extractSemanticModel
         - run: git diff --exit-code src/semantic/ || exit 1
         # 若DSL有差异，阻断流水线
   ```

3. **建立"语义提交"规范**

   ```text
   git commit message格式：
   semantic(entity): 新增用户信用等级字段
   technical(compiler): 优化生成器性能

   规则：所有提交必须打semantic或technical标签
   semantic提交占比目标 >60%（业务驱动）
   ```

**度量**：每日构建的**语义一致性通过率**目标 **100%**

---

### **Step 4：上下文感知运行时（6-8周）**

**目标**：让系统**动态理解**业务场景

**动作清单**：

1. **上下文参数建模**

   ```dsl
   // 定义全局上下文模型
   context BusinessContext {
     userSegment: Enum[HIGH, MID, LOW]
     riskLevel: Integer  // 0-100
     deviceType: Enum[APP, WEB, MINIAPP]
     timeSlot: Enum[PEAK, NORMAL, NIGHT]
   }
   ```

2. **语义路由引擎**

   ```java
   @Component
   public class SemanticRouter {
     public <T> T route(String operation, BusinessContext ctx,
                        Map<String, Supplier<T>> strategies) {
       // 基于机器学习或规则引擎动态选择策略
       String key = strategyResolver.resolve(operation, ctx);
       return strategies.get(key).get();
     }
   }
   ```

3. **A/B测试即语义切换**

   ```dsl
   strategy PaymentGateway {
     variants: {
       v1: { weight: 90, impl: "alipay-v1" }
       v2: { weight: 10, impl: "alipay-v2" }
     }
     routing: "userId.hashCode() % 100"
   }
   ```

   **效果**：无需发布，**DSL修改即时生效**（热加载）

---

### **Step 5：语义网格与治理（持续）**

**目标**：跨系统**语义一致**与**价值流动**

**动作清单**：

1. **事件驱动语义总线**

   ```yaml
   # AsyncAPI定义
   asyncapi: 3.0.0
   channels:
     orderPaid:
       semantics: "订单已支付，触发履约流程"
       payload: OrderPaidEvent
       subscribers: [inventory-service, wms-service, analytics-service]
   ```

2. **语义治理委员会**
   - **成员**：业务架构师（主席）+ 技术负责人 + 产品总监
   - **职责**：每周评审**语义模型变更**，确保跨域一致性
   - **工具**：使用**GitLab MR审批流**，+2 approve（1业务+1技术）

3. **语义价值追踪**

   ```sql
   -- 数据血缘查询：从"用户点击"到"GMV增长"
   SELECT * FROM semantic_lineage
   WHERE source_event = 'UserClickEvent'
   AND target_metric = 'GMV';
   ```

---

## 三、工具链选型与配置

### **DSL工具链**

| 层级 | 工具 | 配置示例 | 成本 |
|------|------|----------|------|
| **语法定义** | Xtext 2.30 | `grammar com.example.OrderDSL` | 低 |
| **图形化** | JetBrains MPS | 投影编辑器，业务人员可用 | 中 |
| **生成器** | JET/Velocity | `for (entity : domain.entities) generate...` | 低 |
| **反向提取** | JavaParser | 扫描AST注解 | 低 |
| **校验** | Eclipse Xtext Validator | 语义规则冲突检查 | 低 |

**推荐组合**：Xtext（DSL） + JavaParser（反向） + Gradle（集成）

### **运行时工具链**

| 组件 | 工具 | 作用 |
|------|------|------|
| **语义路由** | Netflix Ribbon + 自定义规则引擎 | 动态策略选择 |
| **上下文管理** | Spring Cloud Context | 线程级上下文透传 |
| **事件总线** | Kafka + CloudEvents SDK | 语义事件标准化 |
| **契约测试** | Pact + Specmatic | 语义契约验证 |
| **可观测性** | OpenTelemetry + 语义标签 | 追踪语义执行路径 |

---

## 四、组织变革：角色与技能

### **新角色：语义架构师（Semantic Architect）**

**职责**：

- 设计企业级语义元模型
- 评审DSL的语义保真度
- 维护生成器与反向提取器

**技能要求**：

- 领域驱动设计（DDD）专家
- 编译原理（AST/代码生成）入门
- **无需要求**：不必须精通具体技术栈（Spring/Go）

**配比**：每50名开发配**1名语义架构师**（类似DBA）

### **开发工程师转型**

**从**：

```java
// 写CRUD + if-else
public void createOrder(...) {
  if (user.isVip()) { ... } else { ... }
}
```

**到**：

```dsl
// 维护DSL + 编写自定义算法
rule OrderCreation {
  context: VIP -> fastTrack
  context: NORMAL -> standardProcess
}
// 仅对复杂算法手写实现
public ComplexAlgorithm implement() { ... }
```

**培训周期**：**2周**（DSL语法） + **1个月**（思维转变）

---

## 五、风险清单与规避策略

### **风险1：DSL设计过度复杂**

**症状**：DSL语法膨胀，开发者需要学习"新编程语言"
**规避**：

- **原则**：DSL**只描述"变化点"**，不描述"通用技术"（如循环、异常处理）
- **检查项**：DSL语句数 **< 业务规则数的1.5倍**

### **风险2：生成代码质量低**

**症状**：生成代码性能差、可读性差
**规避**：

- **策略**：生成器产出代码需**通过SonarQube门禁**（债务<5分钟/千行）
- **兜底**：生成代码**仅作为"初稿"**，允许手工优化（但需反向同步回DSL）

### **风险3：业务人员不参与**

**症状**：DSL成为技术团队内部工具，业务方仍通过PRD沟通
**规避**：

- **强制机制**：**需求评审会必须展示DSL**，业务方在DSL上签字而非PRD
- **工具**：使用MPS的**图形化投影**，让业务看到自己设计的规则

### **风险4：遗留系统改造停滞**

**症状**：Step 1的防腐层性能损耗过大，或翻译错误率高
**规避**：

- **策略**：**不强行统一**，允许遗留系统长期存在，但**新系统必须通过DSL接入**
- **灰度**：仅对**高频变更**模块做DSL化，低频模块保持原样

---

## 六、第一个90天计划

### **Week 1-2：破冰**

- **Day 1-3**：管理层宣讲，获得CTO+产品VP**双背书**
- **Day 4-10**：选定**1个试点团队**（5-8人），完成语义债务扫描
- **Day 11-14**：输出《语义债务报告》，设定**3个可度量目标**（如T_c2c缩短50%）

### **Week 3-6：MVE**

- **交付**：完成**1个核心域**的DSL化（如优惠券规则）
- **度量**：与对照组（传统开发）对比**交付时间**与**缺陷数**
- **milestone**：试点域的**语义覆盖率>80%**

### **Week 7-12：扩展**

- **范围**：将DSL推广到**3个关联域**（订单、支付、风控）
- **工具**：上线**语义治理平台**（MR审批+一致性检查）
- **组织**：任命**首位语义架构师**，举办2场全员培训

### **Day 90：复盘决策**

- **Go**：ROI > 3x，进入**Step 3-5**规模化
- **NoGo**：复盘根因，**调整试点域**（可能选了过低频或过高复杂度的域）

---

## 七、一句话总结

**语义驱动架构的"How to Do" = "用DSL写业务，让机器写代码，用Git管语义"**

所有理论落地的支点只有一个：**让业务变更的代价，从技术修改降级为文本编辑**。
